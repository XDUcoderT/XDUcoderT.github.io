<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mysql进阶</title>
    <link href="/2022/11/11/Mysql%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/11/11/Mysql%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql进阶"><a href="#Mysql进阶" class="headerlink" title="Mysql进阶"></a>Mysql进阶</h1><h2 id="第一章-MySQL架构和历史"><a href="#第一章-MySQL架构和历史" class="headerlink" title="第一章 MySQL架构和历史"></a>第一章 MySQL架构和历史</h2><h3 id="1-1-Mysql逻辑架构"><a href="#1-1-Mysql逻辑架构" class="headerlink" title="1.1 Mysql逻辑架构"></a>1.1 Mysql逻辑架构</h3><p>书中插图：</p><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221111142617773.png" alt="image-20221111142617773"></p><p>小林插图：</p><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221111142603109.png" alt="image-20221111142603109"></p><h4 id="1-1-1-连接管理与安全性"><a href="#1-1-1-连接管理与安全性" class="headerlink" title="1.1.1 连接管理与安全性"></a>1.1.1 连接管理与安全性</h4><ul><li>连接语句</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span><br><span class="hljs-comment"># -u 指定用户名，管理员角色名为 root；</span><br><span class="hljs-comment"># -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span><br>mysql -h$ip -u$<span class="hljs-keyword">user</span> <span class="hljs-title">-p</span><br></code></pre></td></tr></table></figure><ul><li><p>连接协议</p><ul><li><p>MYSQL是基于TCP协议进行传输的，如果用户名和密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断</p></li><li><p>所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有在新建的连接才会使用新的权限设置。</p></li></ul></li><li><p>连接数量</p><ul><li><p>如何查看mysql被多少个客户端连接了？</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">show <span class="hljs-built_in">processlist</span><br></code></pre></td></tr></table></figure></li><li><p>mysql的连接数有限制吗</p><p>mysql的最大连接数由max_connections参数控制</p></li></ul></li><li><p>空闲连接</p><ul><li><p>空闲连接会一致占用着吗？</p><p>不会，mysql定义了最大连接时长，由wait_timeout参数控制，默认是八小时</p></li><li><p>如何手动断开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> connection + <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>长短连接</p><ul><li><p>mysql的连接也和http一样，有长短连接的概念，它们的区别如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">// 短连接<br>连接 mysql 服务（TCP 三次握手）<br>执行sql<br>断开 mysql 服务（TCP 四次挥手）<br><br>// 长连接<br>连接 mysql 服务（TCP 三次握手）<br>执行sql<br>执行sql<br>执行sql<br>....<br>断开 mysql 服务（TCP 四次挥手）<br></code></pre></td></tr></table></figure></li><li><p>长连接和短链接的优缺点</p><ul><li><p>长连接可以减少建立连接和断开连接的过程，所以一般是使用长连接</p></li><li><p>但是使用长连接可能会占用内存增多</p></li></ul></li><li><p>怎样解决长连接占用内存的问题？</p><ul><li>定期断开长连接</li><li>客户端主动重置连接  MySQL 5.7 版本实现了 <code>mysql_reset_connection()</code> 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，来释放内存，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ul></li></ul></li></ul><h4 id="1-1-2优化和执行"><a href="#1-1-2优化和执行" class="headerlink" title="1.1.2优化和执行"></a>1.1.2优化和执行</h4><h5 id="1-1-2-1解析sql"><a href="#1-1-2-1解析sql" class="headerlink" title="1.1.2.1解析sql"></a>1.1.2.1解析sql</h5><ul><li><p>词法分析</p><p>mysql会根据输入的字符串识别出<strong>关键词</strong>出来，构建<strong>语法树</strong></p></li><li><p>语法分析</p><p>根据词法分析的结果，语法解析器会根据语法规则，判断输入的sql语句是否满足sql语法（表不存在或者字段不存在不在这里判断）</p></li></ul><h5 id="1-1-2-2执行sql"><a href="#1-1-2-2执行sql" class="headerlink" title="1.1.2.2执行sql"></a>1.1.2.2执行sql</h5><ol><li><p>预处理</p><ul><li>检查SQL查询语句种的表或者字段是否存在</li><li>将select * 中的 * 扩展为表上的所有列</li></ul></li><li><p>优化器</p><p>优化器主要负责将SQL查询语句的执行方案确定下来</p></li><li><p>执行器</p><p>两个经典的执行过程</p><ul><li><p>主键索引查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>查询流程</p><p>​这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录</p><ul><li>执行器第一次查询 ，会调用<strong>read_first_record函数指针</strong>指向的函数，因为优化器选择的访问类型为const，这个函数指针被指向为InnoDB引擎索引查询的接口，把条件id &#x3D; 1交给存储引擎，让存储引擎定位符合条件的第一条记录</li><li>存储引擎通过主键索引的B+树结构定位到id &#x3D; 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的结果，然后查询结束，如果记录是存在的，就会将记录返回给执行器</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录</li><li>执行器查询的过程是一个while循环，所以还会再查一次，但是因为不是第一次查询了，所以会调用read_record函数指针指向的函数，因为优化器选择的访问类型为const，这个函数指针被指向为一个永远返回-1的函数，所以调用该函数的时候，执行器退出循环</li></ul></li><li><p>全局扫描</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;iphone&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询流程：</p><p>​  这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用read_first_record函数指针指向的函数，因为优化器选择的访问类型为all，这个函数指针被执行为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li><li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户（Server层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的失手是直接显示所有记录的，是因为<strong>客户端是等查询语句查询完成后，才会显示出所有的记录</strong>）</li><li>执行器查询的过程是一个while循环，所以还会再查一次，会调用<strong>read_record函数指针</strong>指向的还是<strong>InnoDB引擎全扫描的接口</strong>，所以接着向存储引擎层要求取出后就将其返回给执行器，执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端。</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器(server层)返回了读取完毕的信息</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询</li></ul></li></ul></li></ol><h3 id="1-2-并发控制"><a href="#1-2-并发控制" class="headerlink" title="1.2 并发控制"></a>1.2 并发控制</h3><h4 id="1-2-1读写锁"><a href="#1-2-1读写锁" class="headerlink" title="1.2.1读写锁"></a>1.2.1读写锁</h4><p>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁组成的锁系统来解决问题。</p><ul><li>共享锁（读锁）</li><li>排他锁（写锁）</li></ul><h4 id="1-2-2锁粒度"><a href="#1-2-2锁粒度" class="headerlink" title="1.2.2锁粒度"></a>1.2.2锁粒度</h4><ul><li>【优点】锁粒度越小，锁定的数据量越少，系统的并发程度越高，只要相互之间不发生冲突即可</li><li>【缺点】锁粒度越小，消耗的资源越多，会影响到系统的性能</li></ul><h5 id="1-2-2-1表锁"><a href="#1-2-2-1表锁" class="headerlink" title="1.2.2.1表锁"></a>1.2.2.1表锁</h5><ul><li>用户再对表进行<strong>写操作</strong>（插入 删除 更新等）前，需要先获得<strong>写锁</strong>，这回<strong>阻塞</strong>其他用户对该表的所有<strong>读写操作</strong>。只有没有写锁的时候，其他用户才能获得读锁</li><li><strong>读锁之间不会互相阻塞</strong></li></ul><h5 id="1-2-2-2行级锁"><a href="#1-2-2-2行级锁" class="headerlink" title="1.2.2.2行级锁"></a>1.2.2.2行级锁</h5><ul><li>行级锁在存储引擎层实现，与server层无关</li></ul><h3 id="1-3事务"><a href="#1-3事务" class="headerlink" title="1.3事务"></a>1.3事务</h3><ul><li>定义：事务是一组原子性的sql查询，或者说是一个独立的工作单元</li><li>原子性:  一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作</li><li>一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态。</li><li>隔离性:  通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li><li>持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。</li></ul><h5 id="1-3-1InnoDB通过什么来保证事务的这四个特性的呢？"><a href="#1-3-1InnoDB通过什么来保证事务的这四个特性的呢？" class="headerlink" title="1.3.1InnoDB通过什么来保证事务的这四个特性的呢？"></a>1.3.1InnoDB通过什么来保证事务的这四个特性的呢？</h5><ul><li>持久性是通过redo log(重做日志)来保证的</li><li>原子性是通过undo log(回滚日志)来保证的</li><li>隔离性是通过MVCC(多版本并发控制)来保证的</li><li>一致性则是通过持久性 + 原子性 + 隔离性来保证的</li></ul><h4 id="1-3-2-并行事务的问题"><a href="#1-3-2-并行事务的问题" class="headerlink" title="1.3.2 并行事务的问题"></a>1.3.2 并行事务的问题</h4><ul><li><p>脏读</p><p>如果一个事务<strong>读</strong>到了另一个<strong>未提交事务修改过的数据</strong>，就意味着发生了脏读现象</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取账户的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取账户的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221112113509116.png" alt="image-20221112113509116"></p></li><li><p>不可重复读</p><p>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了不可重复读</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取账户的余额数据，然后继续执行代码逻辑处理，<strong>在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</strong></p><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221112113938404.png" alt="image-20221112113938404"></p></li><li><p>幻读</p><p>在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一致的情况，就意味着发生了幻读现象</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，<strong>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</strong></p></li></ul><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221112115313340.png" alt="image-20221112115313340"></p><p><strong>总结</strong></p><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的数据不一致；</li><li>幻读：前后读取的记录数量不一致。</li></ul><h4 id="1-3-3事务隔离级别有哪些"><a href="#1-3-3事务隔离级别有哪些" class="headerlink" title="1.3.3事务隔离级别有哪些"></a>1.3.3事务隔离级别有哪些</h4><ul><li><p>读未提交</p><p>指一个事务还没提交时，它做的变更就能被其他事务看到</p></li><li><p>读提交</p><p>指一个事务提交之后，它做的变更才能被其他事务看到</p></li><li><p>可重复读(默认)</p><p>指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的</p></li><li><p>串行化</p><p>会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果</p></li></ul><p>针对不同的隔离级别，并发事务时可能发生的现象也会不同。</p><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221112121857380.png" alt="image-20221112121857380"></p><p>也就是说：</p><ul><li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li><li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li><li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li><li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li></ul><h4 id="1-3-4-死锁"><a href="#1-3-4-死锁" class="headerlink" title="1.3.4 死锁"></a>1.3.4 死锁</h4><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以<strong>不同的顺序</strong>锁定资源时，就可能产生死锁，多个事务<strong>同时锁定</strong>同一个资源时，也会产生死锁。</p><p>例如：</p><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221112144837888.png" alt="image-20221112144837888"></p><p>如果两个事务都执行了第一条update数据，更新了一条数据，同时也锁定了该行数据，接着每个事务都尝试去执行第二条update数据，却发现该行已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。</p><p><strong>InnoDB处理死锁的方法：</strong></p><p>将持有最少行级排他锁的事务进行回滚</p><h4 id="1-3-5-事务日志"><a href="#1-3-5-事务日志" class="headerlink" title="1.3.5 事务日志"></a>1.3.5 事务日志</h4><p>事务日志可以帮助<strong>提高</strong>事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把修改过的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是<strong>磁盘上一小块区域内的顺序I&#x2F;O</strong>，而不随机I&#x2F;O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快的多。事务日志持久以后，内存中被修改的数据在后台可以慢慢的刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>，修改数据需要写两次磁盘</p><p>如果数据修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在<strong>重启时</strong>能够<strong>自动恢复</strong>这部分修改的数据。</p><h3 id="1-4-多版本并发控制"><a href="#1-4-多版本并发控制" class="headerlink" title="1.4 多版本并发控制"></a>1.4 多版本并发控制</h3><ul><li><p>概述：</p><p>MVCC可以认为是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。</p></li><li><p>实现方式:</p><p>MVCC的实现，是通过保存数据在某个节点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p></li><li><p>分类</p><ul><li>乐观并发控制</li><li>悲观并发控制</li></ul></li><li><p>工作方式（以可重复读为例）</p><ul><li><p>Select</p><p>InnoDB会根据以下两个条件检查每行记录</p><ol><li>InnoDB只查找行的系统版本号小于等于当前事务的系统版本号，这样可以确保事务读取的行，要么是在该事务之前就存在的或者是当前事务插入或者修改的</li><li>行的删除版本要么未被定义，妖媚大于当前事务版本号，这样可以确保事务读取到的行，在事务开始之前未被删除</li></ol></li><li><p>Insert</p><p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p></li><li><p>Delete</p><p>InnoDB为删除的每一行保存当前版本号作为删除标识</p></li><li><p>Update</p><p>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>/学习/后端开发笔记/个人笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hot100</title>
    <link href="/2022/11/01/Hot100/"/>
    <url>/2022/11/01/Hot100/</url>
    
    <content type="html"><![CDATA[<h1 id="Hot100"><a href="#Hot100" class="headerlink" title="Hot100"></a>Hot100</h1><p>Hot01</p><p><strong>题目描述</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">给定一个整数数组 nums 和一个整数目标值 <span class="hljs-keyword">target</span>，请你在该数组中找出 和为目标值 <span class="hljs-keyword">target</span>  的那 两个 整数，并返回它们的数组下标。<br><br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br><br>你可以按任意顺序返回答案。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;<span class="hljs-type">Integer</span>,<span class="hljs-type">Integer</span>&gt; map = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-keyword">get</span>(nums[i]) == <span class="hljs-keyword">null</span>)&#123;<br>                map.put(target-nums[i],i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;i,map.<span class="hljs-keyword">get</span>(nums[i])&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">用map就能解决<br></code></pre></td></tr></table></figure><p>Hot02</p><p><strong>题目描述</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br><br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br><br>你可以假设除了数字<span class="hljs-number"> 0 </span>之外，这两个数都不会以<span class="hljs-number"> 0 </span>开头。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public ListNode add<span class="hljs-constructor">TwoNumbers(ListNode <span class="hljs-params">l1</span>, ListNode <span class="hljs-params">l2</span>)</span> &#123;<br>        <span class="hljs-comment">// ListNode nl1 = reverse(l1);</span><br>        <span class="hljs-comment">// ListNode nl2 = reverse(l2);</span><br>        ListNode head = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode()</span>;<br>        ListNode node = head;<br>        <span class="hljs-built_in">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> value = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != null<span class="hljs-operator"> &amp;&amp; </span>l2 != null)&#123;<br>            num  = l1.<span class="hljs-keyword">val</span> + l2.<span class="hljs-keyword">val</span> + carry;<br>            value  = num % <span class="hljs-number">10</span>;<br>            carry = num/<span class="hljs-number">10</span>;<br>            node.next = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(<span class="hljs-params">value</span>)</span>;<br>            node = node.next;<br>            l1 = l1.next;<br>            l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l1 != null)&#123;<br>            num = l1.<span class="hljs-keyword">val</span> + carry;<br>            value  = num % <span class="hljs-number">10</span>;<br>            carry = num/<span class="hljs-number">10</span>;<br>            node.next = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(<span class="hljs-params">value</span>)</span>;<br>            node = node.next;<br>            l1 = l1.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l2 != null)&#123;<br>            num = l2.<span class="hljs-keyword">val</span> + carry;<br>            value  = num % <span class="hljs-number">10</span>;<br>            carry = num/<span class="hljs-number">10</span>;<br>            node.next = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(<span class="hljs-params">value</span>)</span>;<br>            node = node.next;<br>            l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry != <span class="hljs-number">0</span>)&#123;<br>            node.next = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(<span class="hljs-params">carry</span>)</span>;<br>        &#125;<br>        return head.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">常见的归并问题，注意边界条件就行，最后的carry是否为0判断比较重要<br></code></pre></td></tr></table></figure><p>Hot04</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs text">class Solution &#123;<br>    public int lengthOfLongestSubstring(String s) &#123;<br>        //维护一个最长的字符串<br>        //考虑用map来记录 key是字符 value是位置<br>        int maxlen = 0;<br>        Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();<br>        char[] chars = s.toCharArray();<br>        int len = chars.length;<br>        int begin = 0;<br>        for(int i = 0; i &lt; len;i++)&#123;<br>            char c = chars[i];<br>            if(map.get(c) == null)&#123;<br>                map.put(c,i);<br>            &#125;<br>            else&#123;<br>                int idx = map.get(c);<br>                for(int j = begin; j &lt;= idx;j++)&#123;<br>                    char ch = chars[j];<br>                    map.remove(ch);<br>                &#125;<br>                map.put(c,i);<br>                begin = idx + 1;<br>            &#125;<br>            maxlen = Math.max(map.size(),maxlen);<br>        &#125;<br>        maxlen = Math.max(map.size(),maxlen);<br>        for(Map.Entry entry : map.entrySet())&#123;<br>            char c = (char)entry.getKey();<br>            System.out.println(c);<br>        &#125;<br>        return maxlen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">本题是常见的滑动窗口类题目<br></code></pre></td></tr></table></figure><p>Hot05</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个字符串 s，找到 s 中最长的回文子串。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs text">class Solution &#123;<br>    public String longestPalindrome(String s) &#123;<br>        Map&lt;Integer,Character&gt; map = new HashMap&lt;&gt;();<br>        char[] chars = s.toCharArray();<br>        int len = s.length();<br>        for(int i = 0;i &lt; len;i++)&#123;<br>            map.put(i,chars[i]);<br>        &#125;<br>        int maxlen = 1;<br>        int left = 0;<br>        int right = 0;<br>        for(double i = 0; i &lt; len;i+=0.5)&#123;<br>            int temp = 0;<br>            if((int)i * 2 == (int)(i*2))<br>            temp++;<br>            for(int j = (int)i + 1;j &lt; len;j++)&#123;<br>                int idx = (int)(2*i) - j;<br>                if(idx &lt; 0)&#123;<br>                    break;<br>                &#125;<br>                if(map.get(idx) == map.get(j))&#123;<br>                    temp += 2;<br>                    if(temp &gt; maxlen)&#123;<br>                        maxlen = temp;<br>                        left = idx;<br>                        right = j;<br>                    &#125;<br>                &#125;else&#123;<br>                    break;<br>                &#125;<br>            &#125;<br>        &#125;<br>        String res = s.substring(left,right+1);<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题就是要注意回文串串中心可能是0.5的位置<br></code></pre></td></tr></table></figure><p>Hot06</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br><br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br><br>返回容器可以储存的最大水量。<br><br>说明：你不能倾斜容器。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>, result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> right - left;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minHigh</span> <span class="hljs-operator">=</span> Math.min(height[left], height[right]);<br>            result = Math.max(width * minHigh, result);<br><br>            <span class="hljs-keyword">while</span> (height[left] &lt;= minHigh &amp;&amp; left &lt; right) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (height[right] &lt;= minHigh &amp;&amp; left &lt; right) &#123;<br>                right--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题就是典型的贪心,yysy我感觉贪心的题没有固定的套路 纯靠现场想<br>这道题就是长边不可能往里缩，只有短边往里缩，那就让短边一直往里缩就好了<br></code></pre></td></tr></table></figure><p>Hot07</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请<br><br>你返回所有和为 0 且不重复的三元组。<br><br>注意：答案中不可以包含重复的三元组。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>       Arrays.sort(nums);<br>       List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n; i++)&#123;<br>            <span class="hljs-comment">//这个大循环遍历的是第一个数字</span><br>            <span class="hljs-keyword">if</span>(i &gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;<br>               <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//去除重复的</span><br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> - a;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j &gt; i+<span class="hljs-number">1</span>  &amp;&amp; nums[j] == nums[j-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//去除重复的</span><br>                &#125;<br>                <span class="hljs-keyword">while</span>(t &gt; j &amp;&amp; nums[t] + nums[j] &gt; target)&#123;<br>                    t--;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(t == j)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(nums[t] + nums[j] == target)&#123;<br>                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    list.add(nums[t]);<br>                    list.add(nums[j]);<br>                    list.add(nums[i]);<br>                    res.add(list);<br>                &#125;<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">其实就是加一维的滑动窗口，双指针解决滑动窗口问题 滑动窗口一般是从过饱和状态通过移动双指针来逼近饱和状态 双指针符合一定一动的规律<br></code></pre></td></tr></table></figure><p>Hot08</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br><br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// 数字到号码的映射</span><br>    <span class="hljs-keyword">private</span> String[] map = &#123;<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-string">&quot;mno&quot;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>,<span class="hljs-string">&quot;tuv&quot;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br><br>    <span class="hljs-comment">// 结果集</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> target;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        target = digits.length();<br>        <span class="hljs-keyword">if</span>(digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">char</span>[] chars = digits.toCharArray();<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: chars)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;2&#x27;</span>;<br>            nums[i] = index;<br>            i++;<br>        &#125;<br>        dfs(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>,nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String path,<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.length() == target)&#123;<br>            res.add(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> map[nums[idx]];<br>        <span class="hljs-type">char</span>[] cur = str.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : cur)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">curPath</span> <span class="hljs-operator">=</span> path + ch;<br>            dfs(curPath,idx+<span class="hljs-number">1</span>,nums);<br>        &#125;<br>    &#125;<br><br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">还是暴力递归<br>这道题是顺序遍历确定当前节点 而且这道题节点是必选的 <br></code></pre></td></tr></table></figure><p>Hot09</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>            fast = fast.next;<br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">常见题<br></code></pre></td></tr></table></figure><p>Hot10</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串 s ，判断字符串是否有效。<br><br>有效字符串需满足：<br><br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> chars.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> chars[i];<br>            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;(&#x27;</span> || ch == <span class="hljs-string">&#x27;[&#x27;</span> || ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                deque.addLast(ch);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(deque.size() == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> deque.getLast();<br>                <span class="hljs-keyword">if</span>((c == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; ch == <span class="hljs-string">&#x27;)&#x27;</span>) || (c == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; ch == <span class="hljs-string">&#x27;]&#x27;</span>) || (c == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; ch == <span class="hljs-string">&#x27;&#125;&#x27;</span>))&#123;<br>                    deque.removeLast();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(deque.size() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">就是简单的栈练习 注意java中栈使用双端队列实现的<br>Deque queue = new Linkedlist();<br></code></pre></td></tr></table></figure><p>Hot11</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 <br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> res;<br>        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val1</span> <span class="hljs-operator">=</span> list1.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val2</span> <span class="hljs-operator">=</span> list2.val;<br>            <span class="hljs-keyword">if</span>(val1 == val2)&#123;<br>                node.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val1);<br>                node.next.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val1);<br>                node = node.next.next;<br>                list1 = list1.next;<br>                list2 = list2.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(val1 &lt; val2)&#123;<br>                node.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val1);<br>                list1 = list1.next;<br>                node = node.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(val1 &gt; val2)&#123;<br>                node.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val2);<br>                list2 = list2.next;<br>                node = node.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list1 != <span class="hljs-literal">null</span>)&#123;<br>            node.next = list1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list2 != <span class="hljs-literal">null</span>)&#123;<br>            node.next = list2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">就是简单的归并<br></code></pre></td></tr></table></figure><p>Hot12</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 <br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n;<br>        dfs(<span class="hljs-string">&quot;(&quot;</span>,left-<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String path,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;<br>        System.out.println(path + <span class="hljs-string">&quot; &quot;</span> + left + <span class="hljs-string">&quot; &quot;</span> + right);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>            res.add(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newpath</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;)&#x27;</span>;<br>            dfs(newpath,left,right-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newpath</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;(&#x27;</span>;<br>            dfs(newpath,left-<span class="hljs-number">1</span>,right);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//上面是三个减枝直接return即可</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newpath1</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;(&#x27;</span>;<br>            dfs(newpath1,left-<span class="hljs-number">1</span>,right);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newpath2</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;)&#x27;</span>;<br>            dfs(newpath2,left,right-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">减枝的结果直接return即可 <br></code></pre></td></tr></table></figure><p>Hot13</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个只包含 &#x27;(&#x27; 和 &#x27;)&#x27; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + ((i - dp[i - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<br>                maxans = Math.max(maxans, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">动态规划 反正我他妈是不会<br></code></pre></td></tr></table></figure><p>Hot15</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br><br>如果数组中不存在目标值 target，返回 [-1, -1]。<br><br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt;= end)&#123; <br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> begin + (end - begin)/<span class="hljs-number">2</span>; <br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>                index = mid;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>                end = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                begin = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left,right&#125;;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i = index;i &gt; <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">1</span>] != nums[i])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        left = i;<br>         <span class="hljs-keyword">for</span>( i = index;i &lt; nums.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i + <span class="hljs-number">1</span>] != nums[i])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        right = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left,right&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题其实就还好啦 就是二分查找 target数就行<br></code></pre></td></tr></table></figure><p>Hot16</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; height.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max_left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//找出左边最高</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (height[j] &gt; max_left) &#123;<br>                    max_left = height[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max_right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//找出右边最高</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; height.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (height[j] &gt; max_right) &#123;<br>                    max_right = height[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//找出两端较小的</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(max_left, max_right);<br>            <span class="hljs-comment">//只有较小的一段大于当前列的高度才会有水，其他情况不会有水</span><br>            <span class="hljs-keyword">if</span> (min &gt; height[i]) &#123;<br>                sum = sum + (min - height[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题就是有点像数学题的感觉 技巧性比较强 记住一下思路就行了 遍历 然后找左右最高 然后将当前列高度与左右最高进行比较 进行判断<br></code></pre></td></tr></table></figure><p>Hot17</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span>。 <br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;Integer&gt; rest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len;i++)&#123;<br>            rest.add(nums[i]);<br>        &#125;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(rest,path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; rest,List&lt;Integer&gt; path)</span>&#123;<br>        <span class="hljs-keyword">if</span>(rest.isEmpty())&#123;<br>           res.add(path);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> rest.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size; i++)&#123;<br>            List&lt;Integer&gt; newpath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path);<br>            newpath.add(rest.get(i));<br>            List&lt;Integer&gt; newrest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(rest);<br>            newrest.remove(i);<br>            dfs(newrest,newpath);<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">就是简单的递归<br></code></pre></td></tr></table></figure><p>Hot18</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; rest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len; i++)&#123;<br>            rest.add(nums[i]);<br>        &#125;<br>        dfs(rest,path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; rest,List&lt;Integer&gt; path)</span>&#123;<br>        <span class="hljs-keyword">if</span>(rest.isEmpty())&#123;<br>            res.add(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> rest.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; rest.get(i) == rest.get(i - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            List&lt;Integer&gt; newpath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path);<br>            newpath.add(rest.get(i));<br>            List&lt;Integer&gt; newrest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(rest);<br>            newrest.remove(i);<br>            dfs(newrest,newpath);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">确实是简单的暴力递归 是全排列题型中 需要对每层进行去重的操作<br></code></pre></td></tr></table></figure><p>Hot19</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br><br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> n/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; end; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> n -i -<span class="hljs-number">1</span>;<br>            swap(matrix,i,i,t,i);<br>            swap(matrix,t,i,t,t);<br>            swap(matrix,t,t,i,t);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j &lt; t;j++)&#123;<br>                swap(matrix,j,i,t,j);<br>                swap(matrix,t,j,t-j+i,t);<br>                swap(matrix,t-j+i,t,i,t-j+i);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix,<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[x1][y1];<br>        matrix[x1][y1] = matrix[x2][y2];<br>        matrix[x2][y2] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">就是傻逼数学题 能不能死一死啊<br></code></pre></td></tr></table></figure><p>Hot20</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。<br><br>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> strs.length;<br>        Map&lt;String,List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len;i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> strs[i];<br>            <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>            Arrays.sort(chars);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newstr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>            Set&lt;String&gt; keys = map.keySet();<br>            <span class="hljs-keyword">if</span>(keys.contains(newstr))&#123;<br>                map.get(newstr).add(str);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                list.add(str);<br>                map.put(newstr,list);<br>            &#125;   <br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String,List&lt;String&gt;&gt; entry : map.entrySet())&#123;<br>            List&lt;String&gt; list = entry.getValue();<br>            res.add(list);        <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">eq</span><span class="hljs-params">(String s1,String s2)</span>&#123;<br>       <span class="hljs-type">char</span>[] chars1 = s1.toCharArray();<br>       <span class="hljs-type">char</span>[] chars2 = s2.toCharArray();<br>       <span class="hljs-keyword">if</span>(chars1.length != chars2.length)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>       &#125;<br>       Arrays.sort(chars1);<br>       Arrays.sort(chars2);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">newstr1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars1);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">newstr2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars2);<br>       <span class="hljs-keyword">return</span> newstr1.equals(newstr2);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">异位词建议用我这种方法 用map key为按字典序排序后的异位词，value就是这个key的所有异位词的list集合<br></code></pre></td></tr></table></figure><p>Hot21</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><br>子数组 是数组中的一个连续部分。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">premax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span>(num &gt; premax &amp;&amp; premax &lt; <span class="hljs-number">0</span>)&#123;<br>                premax = num;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                premax += num;<br>            &#125;<br>            max = Math.max(premax,max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这种题不是很难，感觉有点像前缀和，遍历到当前节点得到包括当前节点的最大前缀和 <br></code></pre></td></tr></table></figure><p>Hot22</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br><br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br><br>判断你是否能够到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len];<br>        dp[len - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len -<span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>; i-- )&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j &lt;= num; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i + j &lt; len)&#123;<br>                    dp[i] = dp[i] | dp[i+j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">就是简单的动态规划<br></code></pre></td></tr></table></figure><p>Hot23</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] ints : intervals)&#123;<br>            res.add(ints);<br>        &#125;<br>        res.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ints1,<span class="hljs-type">int</span>[] ints2)</span>&#123;<br>                <span class="hljs-keyword">return</span> ints1[<span class="hljs-number">0</span>] - ints2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//我认为合并区间主要有两种情况 </span><br>        <span class="hljs-comment">//1.交叉：ints1[1] &gt;= ints2[0] &amp;&amp; ints1[1] &lt; ints2[1]</span><br>        <span class="hljs-comment">//2.吞并：ints1[1] &gt; ints2[1]</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] pre = res.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> res.size();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>            ans.add(pre);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; len; i++)&#123;<br>            <span class="hljs-type">int</span>[] ints1 = pre;<br>            <span class="hljs-type">int</span>[] ints2 = res.get(i);<br>            <span class="hljs-keyword">if</span>(ints1[<span class="hljs-number">1</span>] &lt; ints2[<span class="hljs-number">0</span>])&#123;<br>                ans.add(pre);<br>                pre = ints2;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ints1[<span class="hljs-number">1</span>] &gt;= ints2[<span class="hljs-number">0</span>] &amp;&amp; ints1[<span class="hljs-number">1</span>] &lt; ints2[<span class="hljs-number">1</span>])&#123;<br>                pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;ints1[<span class="hljs-number">0</span>],ints2[<span class="hljs-number">1</span>]&#125;;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ints1[<span class="hljs-number">1</span>] &gt;= ints2[<span class="hljs-number">1</span>])&#123;<br>                pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;ints1[<span class="hljs-number">0</span>],ints1[<span class="hljs-number">1</span>]&#125;;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == len-<span class="hljs-number">1</span>)&#123;<br>                ans.add(pre);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> ans.size();<br>        <span class="hljs-type">int</span>[][] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>            result[i] = ans.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">数据结构掌握的很烂 所以写的比较复杂 但我感觉其实还好啦<br>就是考虑以下两种合并情况就行<br>1.交叉：ints1[1] &gt;= ints2[0] &amp;&amp; ints1[1] &lt; ints2[1]<br>2.吞并：ints1[1] &gt; ints2[1]<br><br></code></pre></td></tr></table></figure><p>Hot24</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个 无重叠的 ，按照区间起始端点排序的区间列表。<br><br>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,3],[6,9]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-string">[[1,5],[6,9]]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] insert(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span>[] newInterval) &#123;<br>        <span class="hljs-keyword">if</span>(newInterval.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> intervals;<br>        <span class="hljs-keyword">if</span>(intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;newInterval&#125;;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">0</span>], R = newInterval[<span class="hljs-number">1</span>], len = intervals.length, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j &lt; len &amp;&amp; intervals[j][<span class="hljs-number">1</span>] &lt; L) res.add(intervals[j++]);      <span class="hljs-comment">//重叠前直接加入List</span><br>        <span class="hljs-keyword">while</span>(j &lt; len &amp;&amp; intervals[j][<span class="hljs-number">0</span>] &lt;= R)&#123;     <span class="hljs-comment">//处理重叠区域</span><br>            L = Math.min(L, intervals[j][<span class="hljs-number">0</span>]);<br>            R = Math.max(R, intervals[j++][<span class="hljs-number">1</span>]);<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;L,R&#125;);<br>        <span class="hljs-keyword">while</span>(j &lt; len) res.add(intervals[j++]);     <span class="hljs-comment">//不会再出现重叠区域，直接加入List</span><br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">我他喵的是个煞笔<br>就直接遍历 分析三种情况 <br>while(j &lt; len &amp;&amp; intervals[j][0] &lt;= R)&#123;     //处理重叠区域<br>L = Math.min(L, intervals[j][0]);<br>R = Math.max(R, intervals[j++][1]);<br>&#125;<br>这一段写的是真的漂亮 <br>相比于上一题我if else傻逼写法 他这个while循环的条件就是必定会有合并区间 <br>然后就一直循环就行 循环体内找到左端点和右端点<br></code></pre></td></tr></table></figure><p>Hot25</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。<br><br>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：最后一个单词是“World”，长度为<span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLastWord</span><span class="hljs-params">(String s)</span> &#123;<br>        String[] list = s.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> list[list.length-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> str.length();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">水题 就是要记一下 split的用法 返回一个String数组<br></code></pre></td></tr></table></figure><p>Hot26</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。<br><br>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, down = n - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, index = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(index &lt;= n * n)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++)&#123;<br>                res[up][i] = index++;<br>            &#125;<br>            up++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> up; i &lt;= down; i++)&#123;<br>                res[i][right] = index++;<br>            &#125;<br>            right--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--)&#123;<br>                res[down][i] = index++;<br>            &#125;<br>            down--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> down; i &gt;= up; i--)&#123;<br>                res[i][left] = index++;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">我不会我是傻逼 <br>用模拟的方法 模拟这个二维数组形成的过程 对四个操作套一个while循环就可以模拟了<br></code></pre></td></tr></table></figure><p>Hot27</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br><br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br><br>问总共有多少条不同的路径？<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-comment">//从0，0到m-1，n-1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            dp[i][n-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            dp[m-<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">2</span> ;j &gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j] + dp[i][j+<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">动态规划入门题<br></code></pre></td></tr></table></figure><p>Hot28</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br><br>说明：每次只能向下或者向右移动一步。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>] = grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m-<span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> ;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> grid[i][j];<br>                <span class="hljs-keyword">if</span>(i != m-<span class="hljs-number">1</span> &amp;&amp; j != n-<span class="hljs-number">1</span>)&#123;<br>                    min += Math.min(dp[i][j+<span class="hljs-number">1</span>],dp[i+<span class="hljs-number">1</span>][j]);<br>                    dp[i][j] = min;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i != m-<span class="hljs-number">1</span>)&#123;<br>                    min += dp[i+<span class="hljs-number">1</span>][j];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j != n-<span class="hljs-number">1</span>)&#123;<br>                    min += dp[i][j+<span class="hljs-number">1</span>];<br>                &#125;<br>                dp[i][j] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">动态规划入门题+1<br></code></pre></td></tr></table></figure><p>Hot30</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br><br>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br><br>必须在不使用库的sort函数的情况下解决这个问题。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,0,2,1,1,0]</span><br>输出：<span class="hljs-string">[0,0,1,1,2,2]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">red</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;<br>                red++;<br>                list.add(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br>                list.add(red,<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                list.add(<span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len;i++)&#123;<br>            nums[i] = list.get(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">动态规划入门题+1<br></code></pre></td></tr></table></figure><p>Hot30</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br><br>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br><br>必须在不使用库的sort函数的情况下解决这个问题。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,0,2,1,1,0]</span><br>输出：<span class="hljs-string">[0,0,1,1,2,2]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">red</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;<br>                red++;<br>                list.add(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br>                list.add(red,<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                list.add(<span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len;i++)&#123;<br>            nums[i] = list.get(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">简单题 不难<br></code></pre></td></tr></table></figure><p>Hot31</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<br><br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        dfs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(),nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; path,<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> idx)</span>&#123;<br>        <span class="hljs-keyword">if</span>(idx == nums.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[idx];<br>        <span class="hljs-comment">//1.选择当前节点</span><br>        List&lt;Integer&gt; newpath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path);<br>        newpath.add(num);<br>        res.add(newpath);<br>        dfs(newpath,nums,idx+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//2.不选当前节点</span><br>        dfs(path,nums,idx+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">就是简单的递归<br></code></pre></td></tr></table></figure><p>Hot32</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br><br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; board[i].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == word.charAt(<span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (dfs(board, word, i, j, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == word.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= board.length || j &gt;= board[i].length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (word.charAt(k) != board[i][j]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> board[i][j]; <span class="hljs-comment">//记录一下</span><br>        board[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-comment">//用过了就不能用了 把他改成不可能匹配的数字</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(board, word, i + <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || <br>        dfs(board, word, i - <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || <br>        dfs(board, word, i, j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>) || <br>        dfs(board, word, i, j - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>);<br>        board[i][j] = t;<span class="hljs-comment">//改回来</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这道题就是暴力递归 但是需要标记走过的节点，然后进行回溯<br></code></pre></td></tr></table></figure><p>Hot33</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root,List&lt;Integer&gt; res)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            dfs(root.left,res);<br>        &#125;<br>        res.add(root.val);<br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>)&#123;<br>            dfs(root.right,res);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">中序遍历就是水啦<br></code></pre></td></tr></table></figure><p>Hot34</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] G = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        G[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        G[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; ++j) &#123;<br>                G[i] += G[j - <span class="hljs-number">1</span>] * G[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> G[n];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">二叉搜索树就是满足每一个根节点都满足左孩子&lt;根节点&lt;右节点 <br>并且整个树按照中序遍历递增 <br>所以就可以进行动态规划 动态规划的本质是结果缓存递推 所以不如说可以进行结果缓存递推<br>因为k个节点所能够生成的二叉搜索树是一定的<br>所以本题有缓存 而且本题还要用到笛卡尔积<br></code></pre></td></tr></table></figure><p>Hot35</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个二叉树的根节点 root ， 检查它是否轴对称。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> duichen(root.left,root.right);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">duichen</span><span class="hljs-params">(TreeNode node1,TreeNode node2)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span> &amp;&amp; node2 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span> &amp;&amp; node2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node2 == <span class="hljs-literal">null</span> &amp;&amp; node1 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node1.val != node2.val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> duichen(node1.left,node2.right) &amp; duichen(node1.right,node2.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">有效 二叉搜索树定义如下：<br><br><span class="hljs-number">1.</span>节点的左子树只包含 小于 当前节点的数。<br><span class="hljs-number">2.</span>节点的右子树只包含 大于 当前节点的数。<br><span class="hljs-number">3.</span>所有左子树和右子树自身必须也是二叉搜索树。<br>我们就根据这个来dfs<br>容易知道，这个dfs必定是带参下潜 因为要比较子树的值和<span class="hljs-built_in">max</span>以及<span class="hljs-built_in">min</span>的关系、<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>Hot36</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br><br>有效 二叉搜索树定义如下：<br><br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> duichen(root.left,root.right);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">duichen</span><span class="hljs-params">(TreeNode node1,TreeNode node2)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span> &amp;&amp; node2 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span> &amp;&amp; node2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node2 == <span class="hljs-literal">null</span> &amp;&amp; node1 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node1.val != node2.val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> duichen(node1.left,node2.right) &amp; duichen(node1.right,node2.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">我的想法就是比较两个子树是否是对称的 递归就行<br></code></pre></td></tr></table></figure><p>Hot37</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size; i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>                list.add(node.val);<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">层序遍历用队列来实现 唯一需要注意的点就是 队列的size需要提前记录一下<br></code></pre></td></tr></table></figure><p>Hot37</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树，找出其最大深度。<br><br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br><br>说明: 叶子节点是指没有子节点的节点。<br><br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定二叉树 [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]，<br><br>    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br>返回它的最大深度 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">嗯 dfs 秒 <br>感觉dfs的就是递归的思路<br></code></pre></td></tr></table></figure><p>Hot38</p><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: preorder = <span class="hljs-string">[3,9,20,15,7]</span>, inorder = <span class="hljs-string">[9,3,15,20,7]</span><br>输出: <span class="hljs-string">[3,9,20,null,null,15,7]</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 前序遍历中的第一个节点就是根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">preorder_root</span> <span class="hljs-operator">=</span> preorder_left;<br>        <span class="hljs-comment">// 在中序遍历中定位根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorder_root</span> <span class="hljs-operator">=</span> indexMap.get(preorder[preorder_root]);<br>        <br>        <span class="hljs-comment">// 先把根节点建立出来</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preorder_root]);<br>        <span class="hljs-comment">// 得到左子树中的节点数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size_left_subtree</span> <span class="hljs-operator">=</span> inorder_root - inorder_left;<br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br>        root.left = myBuildTree(preorder, inorder, preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">典型的递归 大问题和小问题 都是在一定范围内构造正确的树<br>突然想到 递归可以这么来理解<br>一个大问题可以拆成多个小问题 其中大问题和小问题的题位是一样<br>题位：对于一个问题 我们所站的位置<br>然后思考一下大问题如果转化为小问题就可以<br>本题是根据先序遍历的第一个数确定根节点 再从中序遍历中找到这个数 从而确定左子树和右子树的范围 也就是确定了小问题:在新的更小的范围内构造正确的树<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>/学习/算法/做题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题</title>
    <link href="/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><h3 id="1-Java语言有哪些特点？"><a href="#1-Java语言有哪些特点？" class="headerlink" title="1. Java语言有哪些特点？"></a>1. Java语言有哪些特点？</h3><ul><li>简单易学，有丰富的类库</li><li>面向对象 Java最重要的特性，让程序耦合度更低，内聚性更高</li><li>平台无关性，JVM</li><li>可靠安全</li><li>支持多线程</li></ul><h3 id="2-面向对象和面向过程的区别"><a href="#2-面向对象和面向过程的区别" class="headerlink" title="2.面向对象和面向过程的区别"></a>2.面向对象和面向过程的区别</h3><ul><li>面向过程是先分析解决问题的步骤，然后用函数把这些步骤实现，使用时再一步一步调用即可</li><li>面向对象是构成问题的事务分解成各个对象，用于描述某个事务再解决整个问题中发生的行为，具有<strong>封装继承多态</strong>的特点，所以<strong>易维护，易复用，易拓展。</strong></li></ul><h3 id="3-boolean类型"><a href="#3-boolean类型" class="headerlink" title="3. boolean类型"></a>3. boolean类型</h3><p>单个boolean值编译之后都是用Java虚拟机中的int类型来代替。</p><p>boolean数组使用Java虚拟机的byte数组，每个boolean元素展一个字节</p><p>补充：单个boolean使用int的原因是，对于当下32位处理器来说，一次处理数据是32位，</p><p>具有高效存取的特点</p><h3 id="4-instanceOf关键字的使用"><a href="#4-instanceOf关键字的使用" class="headerlink" title="4. instanceOf关键字的使用"></a>4. instanceOf关键字的使用</h3><p>instanceof用来测试一个对象是否是一个类的实例，返回boolean类型</p><p>boolean result  &#x3D; obj instanceof Class</p><p>其中obj是一个对象，Class表示一个类或者接口，当obj为Class的对象，或者其直接或者间接子类，或者是其接口的实现类，都返回true，其他的返回false</p><p>如果obj为null 则返回false</p><h3 id="5-Java自动拆箱装箱"><a href="#5-Java自动拆箱装箱" class="headerlink" title="5. Java自动拆箱装箱"></a>5. Java自动拆箱装箱</h3><p>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;Integer）调用方法：Integer的 valueOf(int) 方法 </p><p>拆箱就是自动将包装器类型转换为基本数据类型（Integer–&gt;int）。调用方法：Integer的 intValue方法</p><p><strong>面试题1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>         <span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>         <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>         <span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><br>         System.out.println(i1==i2);<br>         System.out.println(i3==i4);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间， 便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p><p>上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是 同一个对象，而i3和i4则是分别指向不同的对象。</p><p><strong>面试题2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <span class="hljs-type">Double</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100.0</span>;<br>         <span class="hljs-type">Double</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100.0</span>;<br>         <span class="hljs-type">Double</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">200.0</span>;<br>         <span class="hljs-type">Double</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">200.0</span>;<br><br>         System.out.println(i1==i2);<br>         System.out.println(i3==i4);<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="6-重载和重写的区别"><a href="#6-重载和重写的区别" class="headerlink" title="6.重载和重写的区别"></a>6.重载和重写的区别</h3><ul><li>重写：<ul><li><strong>发生在子类和父类之间</strong></li><li><strong>方法名，参数列表，返回类型</strong>(除过子类中方法的返回值是父类中方法返回值的子类时)都相同</li><li><strong>访问修饰符的限制大于被重写方法的修饰符</strong></li></ul></li><li>重载：<ul><li>重载OverLoad是一个类多态性的一种表现 </li><li>重载要求同名方法的<strong>参数列表不同</strong>(参数类型，参数个数甚至是参数顺序)</li><li>重载的时候，<strong>返回值类型可以相同也可以不相同</strong>。无法以返回型作为重载函数的区分标准</li></ul></li></ul><h3 id="7-equals和-x3D-x3D-的区别"><a href="#7-equals和-x3D-x3D-的区别" class="headerlink" title="7.equals和&#x3D;&#x3D;的区别"></a>7.equals和&#x3D;&#x3D;的区别</h3><ul><li>&#x3D;&#x3D;:<ul><li>&#x3D;&#x3D;比较的是变量(栈)内存中存放的(堆)内存地址，用来判断两个对象的地址是否相同，即是否指向同一个对象。比较的是真正意义上的指针操作</li><li>两边的操作数必须是同一类型的(可以是父子类之间)才能编译通过。</li><li>比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0都是相同的（为true），因为他们都指向地 址为10的堆。</li></ul></li><li>equals：<ul><li>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object 中的equals方法返回的却是&#x3D;&#x3D;的判断。</li></ul></li></ul><h3 id="8-HashCode的作用"><a href="#8-HashCode的作用" class="headerlink" title="8.HashCode的作用"></a>8.HashCode的作用</h3><p>哈希算法将集合分成若干个存储区域，每个对象可以计算出一个<strong>哈希码</strong>，可以<strong>将哈希码分组</strong>，每组分别对应某个存储区域，根据一个对象的哈希码就就可以确定对象应该存储的那个区域。</p><h3 id="9-String-StringBuffer-StringBuiler的区别是什么"><a href="#9-String-StringBuffer-StringBuiler的区别是什么" class="headerlink" title="9.String StringBuffer StringBuiler的区别是什么"></a>9.String StringBuffer StringBuiler的区别是什么</h3><ul><li><p>String是只读字符串，底层源码是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象</p></li><li><p>每次+操作 : 隐式的堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法拼接+后面的字符</p></li><li><p>StringBuffer和StringBuider他们两都继承了AbstractStringBuilder抽象类</p><p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuffer和 StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所 以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></li></ul><h3 id="10-ArrayList和LinkedList的区别"><a href="#10-ArrayList和LinkedList的区别" class="headerlink" title="10. ArrayList和LinkedList的区别"></a>10. ArrayList和LinkedList的区别</h3><ul><li><p>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。 Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有 数据, (因为删除数据以后, 需要把后面所有的数据前移)</p><p>缺点: 数组初始化必须指定初始化的长度, 否则报错</p></li><li><p>List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。 List有两个重要的实现类：ArrayList和LinkedList ArrayList: 可以看作是能够自动增长容量的数组 ArrayList的toArray方法返回一个数组 ArrayList的asList方法返回一个列表ArrayList底层的实现是Array, 数组扩容实现 </p></li><li><p>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于 ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</p></li></ul><h3 id="11-HashMap和HashTable的区别"><a href="#11-HashMap和HashTable的区别" class="headerlink" title="11.HashMap和HashTable的区别"></a>11.HashMap和HashTable的区别</h3><ol><li><p>两者父类不同</p><p>HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时 实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。</p></li><li><p>对外提供的接口不同</p><p>HashTable比HashMap多提供了elements()和contains()两个方法，elments() 方法继承自 Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。</p></li><li><p>对null的支持不同</p><ul><li>HashTable:key和​value都不能为null</li><li>HashMap:key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key对应的value为null</li></ul></li><li><p>安全性不同</p><ul><li>HashMap是线程不安全的，在多线程并发的环境下，可能会发生死锁等问题</li><li>HashTable是线程安全的。它的每个方法上都有synchronized关键字，因此可直接用于多线程中</li><li>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部 分的使用场景都是单线程。</li><li>当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。 ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为 ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</li></ul></li><li><p>初始容量大小和每次扩充容量大小不同</p></li><li><p>计算hash值的方法不同</p></li></ol><h3 id="12-Collection包结构与Collections的区别"><a href="#12-Collection包结构与Collections的区别" class="headerlink" title="12. Collection包结构与Collections的区别"></a>12. Collection包结构与Collections的区别</h3><ul><li>Collection是集合类的上级接口，子接口有Set List ArrayList Vector Stack</li><li>Collections是集合类的一个帮助类，它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。</li></ul><p>​</p><h3 id="13-Java的四种引用"><a href="#13-Java的四种引用" class="headerlink" title="13.Java的四种引用"></a>13.Java的四种引用</h3><ul><li><p>强引用：</p><ul><li><p>强引用是平常使用最多的引用，强引用在程序内存不足的时候(OOM)的时候也不会被回收，使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;str&quot;</span>);<br>System.out.println(str);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>软引用</p><ul><li><p>软引用在程序内存不足时，会被回收，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span><br><span class="hljs-comment">// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中T</span><br>SoftReference&lt;String&gt; wrf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;str&quot;</span>));<br></code></pre></td></tr></table></figure></li></ul></li><li><p>弱引用</p><ul><li><p>弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">WeakReference&lt;String&gt; wrf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;String&gt;(str);<br></code></pre></td></tr></table></figure><p>可用场景： Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是， 一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p></li></ul></li><li><p>虚引用</p><ul><li><p>虚引用的回收机制和弱引用差不多，但是它被回收之前，会被放入ReferenceQueue中。注意：其它引用是被JVM回收之后才被传入ReferenceQueue中的。由于这个机制，虚引用大多被用于引用销毁前的处理工作。</p></li><li><p>虚引用创建的时候，必须带有ReferenceQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">PhantomReference&lt;String&gt; prf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;str&quot;</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;());<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="14-泛型的使用特点"><a href="#14-泛型的使用特点" class="headerlink" title="14. 泛型的使用特点"></a>14. 泛型的使用特点</h3><p>泛型意味着编写的代码可用被不同类型的对象所重用</p><p>使用泛型的好处？</p><p>以集合的举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，只要把底层存储设置成Object即可。</p><h3 id="15-Java创建对象有几种方式"><a href="#15-Java创建对象有几种方式" class="headerlink" title="15. Java创建对象有几种方式"></a>15. Java创建对象有几种方式</h3><p>Java中提供了以下四种创建对象的方式？</p><ul><li>new创建新对象</li><li>通过反射机制</li><li>采用clone机制</li><li>通过序列化机制</li></ul><h3 id="16-有没有可能两个不相等的对象有相同的hashcode"><a href="#16-有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="16.有没有可能两个不相等的对象有相同的hashcode"></a>16.有没有可能两个不相等的对象有相同的hashcode</h3><p>有可能。在产生hash冲突时，两个不相等的对象就会有相同的hashcode值。当hash冲突产生时，一般有以下几种方式来处理：</p><ul><li>拉链法：</li></ul><p>每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单项链表进行存储</p><ul><li>开放地址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li><li>再哈希：又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个….等哈希函数计算地址，直到无冲突</li></ul><h3 id="17-深拷贝和浅拷贝的区别是什么？"><a href="#17-深拷贝和浅拷贝的区别是什么？" class="headerlink" title="17. 深拷贝和浅拷贝的区别是什么？"></a>17. 深拷贝和浅拷贝的区别是什么？</h3><ul><li>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象，换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</li><li>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值。而那些引用其他对象的变量将指向被复制的新对象。而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍</li></ul><h3 id="18-final有哪些用法"><a href="#18-final有哪些用法" class="headerlink" title="18.final有哪些用法"></a>18.final有哪些用法</h3><p>记住五点</p><ol><li>被final修饰的<strong>类</strong>不可以被继承</li><li>被final修饰的<strong>方法</strong>不可以被重写</li><li>被final修饰的<strong>变量</strong>不可以被改变，如果修饰引用，表示引用不可以变，引用指向的内容可变</li><li>被final修饰的<strong>方法</strong>，JVM会尝试将其<strong>内联</strong>，以<strong>提高运行效率</strong></li><li>被final修饰的<strong>常量</strong>，在编译阶段会<strong>存入常量池</strong>中</li></ol><h3 id="19-static都有哪些用法"><a href="#19-static都有哪些用法" class="headerlink" title="19.static都有哪些用法"></a>19.static都有哪些用法</h3><ul><li>静态变量</li><li>静态方法</li><li>静态代码块（多用于初始化操作）</li><li>静态内部类</li></ul><h3 id="20-3-0-1-x3D-x3D-0-3返回值是什么"><a href="#20-3-0-1-x3D-x3D-0-3返回值是什么" class="headerlink" title="20.3*0.1 &#x3D;&#x3D; 0.3返回值是什么"></a>20.3*0.1 &#x3D;&#x3D; 0.3返回值是什么</h3><p>false，因为有些浮点数不能完全精确的表示出来</p><h3 id="21-a-x3D-a-b与a-x3D-b有什么区别"><a href="#21-a-x3D-a-b与a-x3D-b有什么区别" class="headerlink" title="21.a&#x3D;a+b与a+&#x3D;b有什么区别"></a>21.a&#x3D;a+b与a+&#x3D;b有什么区别</h3><p>+&#x3D;操作符会隐式自动类型转换</p><p>a&#x3D;a+b不会类型转换</p><h3 id="22-try-catch-finally-try-里有return-finally还执行吗？"><a href="#22-try-catch-finally-try-里有return-finally还执行吗？" class="headerlink" title="22.try catch finally ,try 里有return finally还执行吗？"></a>22.try catch finally ,try 里有return finally还执行吗？</h3><p>执行     并且finally的执行早于 try里的return</p><p>结论：</p><ol><li><strong>不管有没有出现异常，finally块中代码都会执行</strong></li><li><strong>当try和catch中有return时，finally仍然会执行</strong></li><li><strong>finally是在return后面的结构</strong></li></ol><p>Java异常处理层次图：</p><p>java.lang.Object</p><p>​java.lang.Throwable</p><p>​java.lang.Exception</p><p>​java.lang,RuntimeException</p><p>​java.lang.Error</p><p>​java.lang.ThreadDeath</p><ul><li><p>Throwable</p><ul><li>Throwable类是Java中所有错误或者异常的超类</li></ul></li><li><p>Error</p><ul><li><p>Error是程序无法处理的错误，表示运行引用程序中较严重的问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时候JVM出现的问题。例如，Java虚拟机运行错误，比如OOM</p></li><li><p>这些错误是不可查的，因为它们在引用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</p></li></ul></li><li><p>Exception</p><ul><li>Exception是程序本身可以处理的异常</li></ul></li></ul><h3 id="23-OOM你遇到过哪些情况？"><a href="#23-OOM你遇到过哪些情况？" class="headerlink" title="23.OOM你遇到过哪些情况？"></a>23.OOM你遇到过哪些情况？</h3><ul><li><p>OOM：</p><ul><li><p>OutOfMemoryError异常</p><p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError异常的可能</p><p>Java Heap溢出</p><p>出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的 堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。</p><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是 通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。 如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。</p></li><li><p>虚拟机栈和本地方法栈溢出</p><p>如果线程请求的栈升读大于虚拟机所允许的最大深度，将会抛出StackOverflowError异常</p><p>如果虚拟机栈在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常</p></li><li><p>方法区溢出</p><p>方法区用于存放Class的相关信息，如类名 访问修饰符 常量池 字段描述 方法描述等 也有可能是方法去中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们的配置</p></li></ul></li><li><p>SOF：</p><ul><li>当程序递归太深而发生栈溢出 </li><li>栈溢出的原因：<ul><li>递归调用</li><li>大量循环或死循环</li><li>全局变量是否过多</li><li>数组 List Map数据过大</li></ul></li></ul></li></ul><h3 id="26-简述线程-程序-进程的基本概念。以及他们的关系是什么？"><a href="#26-简述线程-程序-进程的基本概念。以及他们的关系是什么？" class="headerlink" title="26 简述线程 程序 进程的基本概念。以及他们的关系是什么？"></a>26 简述线程 程序 进程的基本概念。以及他们的关系是什么？</h3><ul><li><strong>线程</strong>与进程类似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程 与进程不同的是同类的多个线程<strong>共享一块内存空间和一组系统资源</strong> 所以系统在产生一个线程或者在各个线程之间作切换工作时，负担要比进程小很多，正因为如此，线程也被称为轻量级进程。</li><li><strong>程序</strong>是含有指令和数据的文件 被存储在磁盘或其他的数据存储设备中 也就是说程序是静态的代码</li><li><strong>进程</strong>是程序的一次执行过程 是系统运行的基本单位 因此进程是动态的 系统运行一个程序即是一个进程从创建运行到消亡的构成。简单来说 一个进程就是一个执行中的程序，它在计算机中一个又一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间、内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</li><li><strong>进程和线程</strong>最大的区别在于:进程基本上都是独立的，而线程则不一定，因为同一进程中的线程极有可能会相互影响</li></ul><h3 id="27-Exception和Error包结构"><a href="#27-Exception和Error包结构" class="headerlink" title="27.Exception和Error包结构"></a>27.Exception和Error包结构</h3><p>Java可抛出(Throwable)的结构分为三种类型：被检查的异常(CheckedException)，运行时异常 (RuntimeException)，错误(Error)。</p><h3 id="28-Java-IO流结构"><a href="#28-Java-IO流结构" class="headerlink" title="28.Java IO流结构"></a>28.Java IO流结构</h3><p><img src="https://camo.githubusercontent.com/639ec442b39898de071c3e4fd098215fb48f11e9/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545362539362542392545352542432538462545352538382538362545372542312542422e706e67" alt="img"></p><h3 id="29-Java-反射的作用原理"><a href="#29-Java-反射的作用原理" class="headerlink" title="29.Java 反射的作用原理"></a>29.Java 反射的作用原理</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h4><p>反射机制是在运行时，对于任何一个类，都能够知道这个类的所有属性和方法；对于任意个对象，能够调用它的任何一个方法。在Java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><h4 id="2-哪里会用到反射机制？"><a href="#2-哪里会用到反射机制？" class="headerlink" title="2.哪里会用到反射机制？"></a>2.哪里会用到反射机制？</h4><p><strong>JDBC就是典型的反射</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(&#x27;<span class="hljs-params">com</span>.<span class="hljs-params">mysql</span>.<span class="hljs-params">jdbc</span>.Driver.<span class="hljs-params">class</span>&#x27;)</span>; <span class="hljs-comment">//加载mysql的驱动类</span><br></code></pre></td></tr></table></figure><h4 id="3-反射的实现方式"><a href="#3-反射的实现方式" class="headerlink" title="3.反射的实现方式"></a>3.反射的实现方式</h4><p>第一步：获取Class对象，有四种方法</p><p>1.Class.forName(“类的路径”)</p><p>2.类名.class</p><p>3.对象名.getClass</p><p>4.基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象</p><h4 id="4-实现Java反射的类"><a href="#4-实现Java反射的类" class="headerlink" title="4.实现Java反射的类"></a>4.实现Java反射的类</h4><ul><li>Class：表示正在运行的Java应用程序中的类和接口 注意： 所有获取对象的信息都需要Class类 来实现。 </li><li>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。 </li><li>Constructor： 提供关于类的单个构造方法的信息以及它的访问权限 </li><li>Method：提供类或接口中某个方法的信息</li></ul><h4 id="5-反射机制的优缺点"><a href="#5-反射机制的优缺点" class="headerlink" title="5.反射机制的优缺点"></a>5.反射机制的优缺点</h4><ul><li>优点：<ul><li>能够在运行时动态获取类的实例，提高灵活性；</li><li>与动态编译结合</li></ul></li><li>缺点：<ul><li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析</li><li>相对不安全，破坏了封装性</li></ul></li></ul><h3 id="30-说说List，Set，Map三者的区别"><a href="#30-说说List，Set，Map三者的区别" class="headerlink" title="30.说说List，Set，Map三者的区别"></a>30.说说List，Set，Map三者的区别</h3><p>List(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序 的对象 </p><p>Set(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。 </p><p>Map(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引 用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p><h3 id="31-Object类有哪些常用方法？大致说一下每种方法的含义"><a href="#31-Object类有哪些常用方法？大致说一下每种方法的含义" class="headerlink" title="31.Object类有哪些常用方法？大致说一下每种方法的含义"></a>31.Object类有哪些常用方法？大致说一下每种方法的含义</h3><p><strong>clone方法</strong></p><p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常，深拷贝也需要实现Cloneable，同时其成员变量为引用类型的也需要实现Cloneable，然后重写clone方法</p><p><strong>finalize方法</strong></p><p>该方法和垃圾收集器有关系，判断一个对象是否可以被回收的最后一步就是判断是否重写了此方法</p><p><strong>equals方法</strong></p><p>该方法使用频率非常高。一般equals和&#x3D;&#x3D;是不一样的。但在Object中两者是一样的。子类一般要重写这个方法</p><p><strong>hashCode方法</strong></p><p>该方法用于hash查找，重写了equals方法一般都要重写hashCode方法，这个方法在一些具有哈希功能的Collection中用到</p><p>一般必须满足</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">obj1.equals(obj2) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> true<br></code></pre></td></tr></table></figure><p>可以推出obj1.hashCode() &#x3D;&#x3D; obj2.hashCode(),但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个两个条件接近等价。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">JDK</span> <span class="hljs-number">1</span>.<span class="hljs-number">6</span>、<span class="hljs-number">1</span>.<span class="hljs-number">7</span> 默认是返回随机数； <br><span class="hljs-attribute">JDK</span> <span class="hljs-number">1</span>.<span class="hljs-number">8</span> 默认是通过和当前线程有关的一个随机数 + 三个确定值，运用 Marsaglia’s xorshift scheme 随机数算法得到的一个随机数。<br></code></pre></td></tr></table></figure><p><strong>wait 方法</strong></p><p>配合 synchronized 使用，wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥 有者，也就是具有该对象的锁。</p><p>wait() 方法一直等待，直到获得锁或者被中断。wait(long timeout) 设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p><p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p><ol><li>其他线程调用了该对象的 notify 方法；</li><li>其他线程调用了该对象的 notifyAll 方法； </li><li>其他线程调用了 interrupt 中断该线程；</li><li>时间间隔到了。 此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。</li></ol><p><strong>notify 方法</strong> </p><p>配合 synchronized 使用，该方法唤醒在该对象上等待队列中的某个线程（同步队列中的线程是给 抢占 CPU 的线程，等待队列中的线程指的是等待唤醒的线程）。</p><p><strong>notifyAll方法</strong></p><p>配合 synchronized 使用，该方法唤醒在该对象上等待队列中的所有线程</p><h3 id="32-Java创建对象有几种方式？"><a href="#32-Java创建对象有几种方式？" class="headerlink" title="32.Java创建对象有几种方式？"></a>32.Java创建对象有几种方式？</h3><p>四种 </p><ol><li><p>使用new关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure></li><li><p>通过反射方式创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">User user=User.class.newInstance();<br>Object object=(Object)Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).newInstance()<br></code></pre></td></tr></table></figure></li><li><p>通过clone方法</p></li><li><p>使用反序列化创建对象，<strong>调用ObjectInputStream类的readObject方法</strong></p><p>我们反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造函 数。一个对象实现了 Serializable 接口，就可以把对象写入到文件中，并通过读取文件来创建对 象。</p></li></ol><h3 id="33-Map和HashTable的异同点"><a href="#33-Map和HashTable的异同点" class="headerlink" title="33.Map和HashTable的异同点"></a>33.Map和HashTable的异同点</h3><ul><li><p>相同点</p><ul><li>都实现了cloneable serialble map三个接口</li></ul></li><li><p>不同点</p><ul><li><p>HashMap继承的是AbstractMap并且AbStractMap也实现了Map接口 HashTable继承Dictionary</p></li><li><p>Hashtable中大部分public修饰普通方法都是synchronized字段修饰的，是线程安全的，HashTable是非线程安全的</p></li><li><p>HashTable的key和value都不能为null 否则会报空指针异常</p><p>HashMap中的key和value都可以为null但是key为null只能有1个</p></li><li><p>Hashtable直接使用hash值 hash 值是 JDK 根据对象的地址或者字符串或者数字算出 来的 int 类型的数值。然后再使用除留余数法来获得最终的位置。用除法计算很浪费时间</p><p>HashMap为了提高效率，将哈希表的大小固定为2的次方幂，可以用位运算来代替除法 大大提高了效率</p></li><li><p>默认情况下，初始容量不同，Hashtable 的初始长度是 11，之后每次扩充容量变为之前的 2n+1（n 为上一次的长度）而 HashMap 的初始长度为 16，之后每次扩充变为原来的两倍。</p></li><li><p>HashTable是线程安全的，推荐使用HashMap来代替HashTable，如果需要线程安全搞并发的话，推荐使用COncurrentHashMap来代替HashTable</p><p>补充：</p><p>锁的实现原理:</p><p><a href="https://blog.csdn.net/qq_22343483/article/details/98510619">锁的实现原理</a></p><p>红黑树的结构：</p><p><a href="https://zhuanlan.zhihu.com/p/273829162">图解：什么是红黑树？ - 知乎 (zhihu.com)</a></p></li></ul></li></ul><h3 id="34-谈谈你对hashmap的理解"><a href="#34-谈谈你对hashmap的理解" class="headerlink" title="34.谈谈你对hashmap的理解"></a>34.谈谈你对hashmap的理解</h3><p>HashMap的底层是通过数组加单向链表实现的，数组中的<strong>每一个元素都是一个链表结构</strong>，而链表中的每一个节点都是一个Entry对象，Entry对象用来存储真正的K-V，也就是键值对的值。</p><h4 id="1-如何减少hash冲突"><a href="#1-如何减少hash冲突" class="headerlink" title="1.如何减少hash冲突"></a>1.如何减少hash冲突</h4><ol><li>干扰函数的使用，通过干扰函数，将元素hash值进行高低位的异或，使得参与运算的hash值，同时具备了原hash值高位和低位的特征，增大了随机性</li><li>散列数组需要2的倍数的长度，不仅是为了散列，也是为了提高计算hash值的效率</li></ol><h4 id="2-数组越大，碰撞越小-数组越小，碰撞越大-时间和空间如何取舍"><a href="#2-数组越大，碰撞越小-数组越小，碰撞越大-时间和空间如何取舍" class="headerlink" title="2.数组越大，碰撞越小 数组越小，碰撞越大 时间和空间如何取舍"></a>2.数组越大，碰撞越小 数组越小，碰撞越大 时间和空间如何取舍</h4><p>hashmap中<strong>数组的初始长度为16</strong>，需要在适当的时候对数组进行扩容，那么hashmap当中默认的<strong>扩容阈值为0.75</strong>，太小扩容太频繁 太大扩容成本太高</p><h4 id="3-hashmap出现hash冲突-通过拉链法处理-但是链表长度太长效率低"><a href="#3-hashmap出现hash冲突-通过拉链法处理-但是链表长度太长效率低" class="headerlink" title="3.hashmap出现hash冲突 通过拉链法处理 但是链表长度太长效率低"></a>3.hashmap出现hash冲突 通过拉链法处理 但是链表长度太长效率低</h4><ul><li>jdk8把过长的链表把过长的链表大于等于8个 或者元素个数达到64 优化为自平衡的红黑树结构，以此让定位元素的复杂度优化为O(logN)</li><li>当链表长度为小于等于6的时候 红黑树会退化为链表</li><li>之所以两个数不同 是考虑到如果hash碰撞次数在8附近徘徊，会一直发生链表和红黑树的转换</li></ul><h4 id="4-jdk1-8对hashmap的优化"><a href="#4-jdk1-8对hashmap的优化" class="headerlink" title="4.jdk1.8对hashmap的优化"></a>4.jdk1.8对hashmap的优化</h4><ol><li>数组加链表变为数组加链表或者红黑树</li><li>链表的插入方式从<strong>头插法变为尾插法</strong> <strong>可以解决jdk7当中数据丢失和数据覆盖的问题</strong></li><li>扩容的时候，1.7需要对原数组中的元素进行重新hash定位在新数组当中的位置 1.8则是采用更简单的判断逻辑位置不变或索引加就容量太小</li><li><strong>1.7先判断是否需要扩容 再插入</strong> <strong>1.8先插入再判断是否需要扩容</strong></li></ol><h4 id="5-HashMap中put方法和get方法"><a href="#5-HashMap中put方法和get方法" class="headerlink" title="5.HashMap中put方法和get方法"></a>5.HashMap中put方法和get方法</h4><p>在存储K-V键值对的时候，我们首先<strong>会调用一个hash方法</strong>，通过这个hash方法可以<strong>计算出key的Hash值</strong>，从而得到一个<strong>十进制的数字</strong>，<strong>用这个数字和数组的长度减一去取模就可以得到数组的下标</strong>，可以根据这个下标找到数组中存储的单向链表，然后把链表中的每一个key和插入的key进行一个<strong>equals的比较</strong>，如果是相等话我们就直接更新这个value值，如果都不相等话，就把新的value值put到链表中去</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-Java中实现多线程有几种方法"><a href="#1-Java中实现多线程有几种方法" class="headerlink" title="1.Java中实现多线程有几种方法"></a>1.Java中实现多线程有几种方法</h3><ol><li>继承Thread类</li><li>实现Runnable接口&#x2F;实现Callable接口</li><li>线程池</li></ol><p>​<strong>补充：</strong></p><ol><li><p>采用实现Runnable、Callable接口的方式创建线程的优缺点</p><ul><li>优点：线程类只是实现了Runnable或者Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。</li><li>缺点：比较复杂,如果要访问当前线程，则必须使用Thread.currentThread()方法</li></ul></li><li><p>采用继承Thread类的方式创建线程的优缺点</p><ul><li>优点：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获取当前线程</li><li>缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。</li></ul></li><li><p>this 和 Thread.currentThread 的区别</p><p>this指代当前所在类的实例对象，current就是字面意思指代当前正在运行的线程</p></li></ol><h3 id="2-如何停止一个正在运行的线程"><a href="#2-如何停止一个正在运行的线程" class="headerlink" title="2.如何停止一个正在运行的线程"></a>2.如何停止一个正在运行的线程</h3><ol><li><p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</p></li><li><p>使用stop方法强行终止</p><p>缺点</p><ul><li>可能使得一些请理性的工作得不到完成</li><li>对锁定的对象进行了解锁 导致数据得不到同步的处理</li></ul></li><li><p>使用interrupt方法中断线程 </p><ul><li><p>在main主线程中将创建的线程interrupt，在创建的线程run方法中检验当前线程是否interrupted，如果是则抛出一个异常，从而终止进程。</p></li><li><p>当然也可以不采用抛出异常的方法而采用直接return的方法停止进程。</p></li><li><p>interrupt仅仅是给一个停止的标记而已，并不是直接终止当前线程</p></li></ul></li></ol><h3 id="3-Synchronized的深入理解"><a href="#3-Synchronized的深入理解" class="headerlink" title="3.Synchronized的深入理解"></a>3.Synchronized的深入理解</h3><ol><li>关键词synchonized取得的锁是对象锁，而不是把一段代码或方法(函数)当作锁，所以哪个线程先执行带synchronized关键字的方法，那个线程就持有该方法所属对象的锁Lock,这时其他线程就只能呈等待状态，前提是多个线程访问的是同一个对象。但如果多个线程访问多个对象，则JVM会创建多个锁。</li><li>调用用关键字synchronized声明的方法一定是排队运行的，另外需要牢牢记住”共享”这两个字，只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本就没有同步的必要。</li><li>一旦一个线程获得了一个对象的Lock锁，那么在这个锁被释放之前 其他线程都不能访问这个对象的synchronized方法，但是可以随意调用非synchronized方法</li><li>synchronized具有锁重入的功能，也就是在使用synchronized方法时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。这也证明在一个synchronized方法&#x2F;块的内部调用本类的其他synchronized方法&#x2F;块时，是永远可以得到锁的。</li><li>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。</li><li>同步不具有继承性。</li><li>同步代码块<ul><li>当两个并发线程访问同一个对象object中的synchronized(this)同步代码块时，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</li><li>当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问该object对象的非synchronized(this)同步代码块</li><li>在使用同步synchronized(this)代码块时需要注意的是，当一个线程访问object的一个sunchronized(this)同步代码块时，其他线程对同一个object中所有其他synchronized(this)同步代码块的访问将被阻塞，这说明synchronized使用的”对象监视器”是一个。</li><li>和synchronized方法一样。synchronized(this)代码块也是锁定当前对象的。</li></ul></li></ol><h3 id="4-volatile关键字的作用"><a href="#4-volatile关键字的作用" class="headerlink" title="4.volatile关键字的作用"></a>4.volatile关键字的作用</h3><p>一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义：</p><ul><li><p>保证了不同线程对这个变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</p></li><li><p>volatile本质是在告诉jvm当前变量在寄存器(工作内存)中的值是不确定的，需要<strong>从主存中读取</strong>；<strong>synchronized</strong>则是<strong>锁定当前变量，只有当前线程可以访问该变量</strong>、方法和类级别的</p></li><li><p>volatile仅能实现变量的修改可见性，并不能保证其原子性；synchronized则可以保5证变量的修改性和原子性</p></li><li><p>volatile不会造成线程的阻塞 synchronized可能会造成现成的阻塞</p></li><li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p></li></ul><h3 id="5-notify和notifyAll有什么区别"><a href="#5-notify和notifyAll有什么区别" class="headerlink" title="5.notify和notifyAll有什么区别"></a>5.notify和notifyAll有什么区别</h3><p><strong>notify可能导致死锁，而notifyAll则不会</strong></p><p>任何时候只有一个线程可以得到锁，也就是说只有一个线程可以运行synchronized中的代码</p><p>使用notifyAll可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个</p><p>wait()应配合<strong>while循环</strong>使用，<strong>不应使用if</strong>，<strong>务必在wait()调用前后都检查条件</strong>，自己继续wait()直至条件满足再往下执行</p><p>notify() 是对notifyAll()的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致 死锁。正确的场景应该是 WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事 项，如果唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到 WaitSet中.</p><h3 id="6-sleep和wait有什么区别"><a href="#6-sleep和wait有什么区别" class="headerlink" title="6.sleep和wait有什么区别"></a>6.sleep和wait有什么区别</h3><ul><li><p>对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。</p></li><li><p>sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的<strong>监控状态依然保持着</strong>，当指定时间到了又会自动恢复运行状态。<strong>在调用sleep()方法的过程中，线程不会释放对象锁</strong></p></li><li><p>当调用wait()方法的时候，线程会<strong>放弃对象锁</strong>，进入等待此对象的等待锁定持，只有针对此对象<strong>调用notify方法</strong>后本线程才能<strong>进入对象锁定池准备</strong>，获取对象锁进入运行状态。</p></li></ul><h3 id="7-Thread类中的start-和run-方法有什么区别？"><a href="#7-Thread类中的start-和run-方法有什么区别？" class="headerlink" title="7.Thread类中的start()和run()方法有什么区别？"></a>7.Thread类中的start()和run()方法有什么区别？</h3><ul><li><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法。</p></li><li><p>直接调用run()方法的时候，只会在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程</p></li></ul><h3 id="8-为什么wait，notify-notifyAll这些方法不在thread类里面"><a href="#8-为什么wait，notify-notifyAll这些方法不在thread类里面" class="headerlink" title="8.为什么wait，notify,notifyAll这些方法不在thread类里面?"></a>8.为什么wait，notify,notifyAll这些方法不在thread类里面?</h3><p>Java提供的锁是对象级的而不是线程级的，每个对象都要有锁。由于wait notify notifyAll都是锁级别的操作，所以把他们定义在Object类中 因为锁属于对象</p><h3 id="9-为什么wait和notify方法要在同步块中调用？"><a href="#9-为什么wait和notify方法要在同步块中调用？" class="headerlink" title="9.为什么wait和notify方法要在同步块中调用？"></a>9.为什么wait和notify方法要在同步块中调用？</h3><ul><li>只有调用线程拥有某个对象的独占锁时，才能调用该对象的wait(),notify()和notifyAll()方法。否则会抛出异常。</li><li>还有一个原因是为了避免wait和notify之间产生竞态条件</li></ul><h3 id="10-Java中interrupted和isInterrupted方法的区别"><a href="#10-Java中interrupted和isInterrupted方法的区别" class="headerlink" title="10.Java中interrupted和isInterrupted方法的区别"></a>10.Java中interrupted和isInterrupted方法的区别</h3><ul><li>最主要的区别是interrupted会将状态清除而后者不会。</li></ul><h3 id="11-Java中的synchronized和ReentrantLock有何不同？"><a href="#11-Java中的synchronized和ReentrantLock有何不同？" class="headerlink" title="11 Java中的synchronized和ReentrantLock有何不同？"></a>11 Java中的synchronized和ReentrantLock有何不同？</h3><h3 id="12-有三个线程T1，T2，T3，如何保证顺序执行？"><a href="#12-有三个线程T1，T2，T3，如何保证顺序执行？" class="headerlink" title="12.有三个线程T1，T2，T3，如何保证顺序执行？"></a>12.有三个线程T1，T2，T3，如何保证顺序执行？</h3><p>用线程类中的join方法在一个线程中去调用另一个线程。</p><h3 id="13-SynchronizedMap和ConcurrentHashMap有什么区别"><a href="#13-SynchronizedMap和ConcurrentHashMap有什么区别" class="headerlink" title="13.SynchronizedMap和ConcurrentHashMap有什么区别"></a>13.SynchronizedMap和ConcurrentHashMap有什么区别</h3><p>SynchronizedMap()和Hashtable一样，实际上在调用map的所有方法时，<strong>都对整个map进行同步</strong>。而ConcurrentHashMap的实现却更加精细，<strong>它对map中的所有桶加了锁</strong>。<strong>所以只要有一个线程访问map，其他线程就无法进入map</strong>，<strong>而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程仍然可以对map进行操作。</strong></p><p>所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行数据修改，也<strong>不会抛出ConcurrentModificationException</strong></p><h3 id="14-什么是线程安全？"><a href="#14-什么是线程安全？" class="headerlink" title="14.什么是线程安全？"></a>14.什么是线程安全？</h3><p>如果代码在多线程下执行和单线程下执行永远都能获得一样的结果，那么代码就是线程安全的。</p><h4 id="补充：线程安全的级别"><a href="#补充：线程安全的级别" class="headerlink" title="补充：线程安全的级别"></a>补充：线程安全的级别</h4><ol><li>不可变<ul><li>像String Integer Long 这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</li></ul></li><li>绝对线程安全<ul><li><strong>不管运行时环境如何，调用者都不需要额外的同步措施</strong>。要做到这一点通常要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，</li></ul></li><li>相对线程安全<ul><li>相对线程安全也就是我们通常意义上所说的线程安全，像vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99％的情况下都会出现ConcurrentModificationException，也就是fail-fast机制</li></ul></li><li>线程非安全<ul><li>ArrayList LinkedList HashMap都是线程非安全的类</li></ul></li></ol><h3 id="15-Java线程池中submit-和execute-方法有什么区别"><a href="#15-Java线程池中submit-和execute-方法有什么区别" class="headerlink" title="15.Java线程池中submit()和execute()方法有什么区别"></a>15.Java线程池中submit()和execute()方法有什么区别</h3><h3 id="16-如何避免死锁"><a href="#16-如何避免死锁" class="headerlink" title="16.如何避免死锁"></a>16.如何避免死锁</h3><p>指定获得锁的顺序，举例如下：</p><ol><li>比如某个线程只有获得A锁和B锁才能对某资源进行操作，在多线程条件下，如何避免死锁</li><li>获得锁的顺序是一定的，比如规定，只有获得A锁的线程才有资格获得B锁，按顺序获取锁就可以避免死锁！！！</li></ol><h3 id="17-引用类型有哪些？有什么区别？"><a href="#17-引用类型有哪些？有什么区别？" class="headerlink" title="17.引用类型有哪些？有什么区别？"></a>17.引用类型有哪些？有什么区别？</h3><h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><h3 id="1-Spring的好处"><a href="#1-Spring的好处" class="headerlink" title="1.Spring的好处"></a>1.Spring的好处</h3><ul><li><strong>轻量</strong>：Spring是轻量的，基本的版本大约2MB</li><li><strong>控制反转</strong>，Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们</li><li><strong>面向切面的编程</strong>:Spring支持面向切面编程，并且把应用业务逻辑和系统服务分开。</li><li><strong>容器</strong>：Spring<strong>包含并管理</strong>应用中对象的<strong>生命周期</strong>和<strong>配置</strong></li><li><strong>MVC框架</strong>:Spring的WEB框架是个精心设计的框架</li><li><strong>事务管理</strong>：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务 （JTA）。</li><li><strong>异常处理</strong>：Spring提供方便的API把具体技术相关的异常转化为一致的unchecked异常</li></ul><h3 id="2-Autowired和Resource关键字的区别"><a href="#2-Autowired和Resource关键字的区别" class="headerlink" title="2.Autowired和Resource关键字的区别"></a>2.Autowired和Resource关键字的区别</h3><ol><li><p>共同点</p><p>两者都可以写在字段和setter方法上。如果都写在字段上。那么就不需要再写setter方法</p></li><li><p>不同点</p><ol><li>Autowired注解是按照类型装配依赖对象，<strong>默认情况下它要求依赖对象必须存在</strong>，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称byName来装配，可以结合@Qualifier注解一起使用</li><li>@Resource默认按照ByName自动注入。Resource有两个重要的属性：name和type，而spring将Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性则使用byType自动注入策略</li><li>@Resource装配顺序：<ol><li>如果<strong>同时制定了name和type</strong>，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</li><li>如果<strong>指定了name</strong>，则从上下文中查找名称(id)匹配的bean进行装配，找不到则抛出异常</li><li>如果<strong>指定了type</strong>，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常</li><li><strong>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配</strong>；<strong>如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配</strong></li><li>Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入</li></ol></li></ol></li></ol><h3 id="3-依赖注入的方式有几种？"><a href="#3-依赖注入的方式有几种？" class="headerlink" title="3.依赖注入的方式有几种？"></a>3.依赖注入的方式有几种？</h3><ol><li><p>构造器注入</p><p>将被依赖对象通过构造函数的参数注入给依赖对象，并在初始化对象的时候注入</p><p>优点：对象初始化完成后便可获得可使用的对象</p></li></ol><h3 id="4-说说你对SpringMVC的理解"><a href="#4-说说你对SpringMVC的理解" class="headerlink" title="4.说说你对SpringMVC的理解"></a>4.说说你对SpringMVC的理解</h3><p>什么是MVC模式</p><p>MVC是一种设计模式</p><p>MVC的原理图：</p><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221101160630942.png" alt="image-20221101160630942"></p><ul><li><p>M-model模型 </p><p>完成业务逻辑，有javaBean构成，service + dao + entity</p></li><li><p>V-View视图 </p><p>做界面的展示 jsp html</p></li><li><p>C Controller控制器</p><p>接收请求-&gt;调用模型-&gt;根据结果派发页面</p></li></ul><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221101161040087.png" alt="image-20221101161040087"></p><h3 id="5-SpringMVC常用的注解有哪些"><a href="#5-SpringMVC常用的注解有哪些" class="headerlink" title="5.SpringMVC常用的注解有哪些"></a>5.SpringMVC常用的注解有哪些</h3><p>@RequestMapping :用于处理了请求url映射的注解，可用于类或者方法上。用于类上，则表示类中的所有响应的方法都是以该地址作为父路径</p><p>@RequestBody：注解实现接收http请求的json数据，将json转化为java对象</p><p>@ResponseBody：注解实现将controller方法返回的json对象响应给客户</p><h3 id="6-谈谈你对Spring的AOP的理解"><a href="#6-谈谈你对Spring的AOP的理解" class="headerlink" title="6. 谈谈你对Spring的AOP的理解"></a>6. 谈谈你对Spring的AOP的理解</h3><p>AOP能够将那些<strong>与业务无关</strong>，却<strong>为业务模块所共同调用的逻辑或责任封装起来</strong>，<strong>便于减少系统的重复代码</strong>，降低模块间的耦合度，并有利于未来的科拓展性和可维护性。</p><p>SpringAOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理</p><h3 id="7-什么是通知呢？有哪些类型呢"><a href="#7-什么是通知呢？有哪些类型呢" class="headerlink" title="7.什么是通知呢？有哪些类型呢"></a>7.什么是通知呢？有哪些类型呢</h3><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段</p><p>Spring切面可以应用物种类型的通知：</p><ul><li>before：前置通知，在一个方法执行前被调用</li><li>after：在方法执行之后调用的通知，无论方法执行是否成功</li><li>after-returning: 仅当方法成功完成后执行的通知。</li><li>after-throwing: 在方法抛出异常退出时执行的通知。</li><li>around：在方法执行之前和之后调用的通知</li></ul><h3 id="8-说说你对Spring的IOC是怎么理解的？"><a href="#8-说说你对Spring的IOC是怎么理解的？" class="headerlink" title="8.说说你对Spring的IOC是怎么理解的？"></a>8.说说你对Spring的IOC是怎么理解的？</h3><ol><li>IOC就是<strong>控制反转</strong>，是指创建对象的控制权的转移。以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。对象和对象之间松散耦合，也利于功能的复用。DI依赖注入和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖IOC容器来动态注入对象所需要的外部资源、</li><li>最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法。</li><li>Spring的IOC有三种注入方式：<strong>构造器注入</strong>、<strong>setter注入</strong>、<strong>根据注解注入</strong></li></ol><h3 id="9-SpringIOC原理"><a href="#9-SpringIOC原理" class="headerlink" title="9.SpringIOC原理"></a>9.SpringIOC原理</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Spring通过一个配置文件描述Bean及Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。</p><h4 id="装配过程"><a href="#装配过程" class="headerlink" title="装配过程"></a>装配过程</h4><p>Spring启动时读取应用程序的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，其中Bean缓存池为HashMap实现</p><h4 id="BeanFactory基础框架设施"><a href="#BeanFactory基础框架设施" class="headerlink" title="BeanFactory基础框架设施"></a>BeanFactory基础框架设施</h4><p>BeanFactort是Spring框架的<strong>基础设施，面向Spring本身</strong>；ApplicationContext面向使用Spring框架的开发者</p><h3 id="10-SpringBean-生命周期"><a href="#10-SpringBean-生命周期" class="headerlink" title="10.SpringBean 生命周期"></a>10.SpringBean 生命周期</h3><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><ul><li>实例化一个Bean 也就是我们常说的new</li></ul><h4 id="IOC依赖注入"><a href="#IOC依赖注入" class="headerlink" title="IOC依赖注入"></a>IOC依赖注入</h4><ul><li>按照Spring上下文对实例化的Bean进行配置</li></ul><h4 id="setBeanName实现"><a href="#setBeanName实现" class="headerlink" title="setBeanName实现"></a>setBeanName实现</h4><ul><li>如果这个Bean实现了<strong>BeanNameAware</strong>接口，会调用它实现的<strong>setBeanName(String)方法</strong> 此处传递的就是Spring配置文件中Bean的id值</li></ul><h4 id="setBeanFactory实现"><a href="#setBeanFactory实现" class="headerlink" title="setBeanFactory实现"></a>setBeanFactory实现</h4><ul><li>如果这个Bean实现了BeanFactoryAware接口，会调用实现它的setBeanFactroy，setBeanFactory(BeanFactroy)传递的是Spring工厂自身(可以用这个方法来获取其它Bean)</li></ul><h4 id="setApplicationContext实现"><a href="#setApplicationContext实现" class="headerlink" title="setApplicationContext实现"></a>setApplicationContext实现</h4><ul><li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(Application)方法，传入Spring上下文 同样这个方式实现步骤4的内容，但比4更好</li></ul><h4 id="PostProcessBeforeInitialization接口实现-初始化预处理"><a href="#PostProcessBeforeInitialization接口实现-初始化预处理" class="headerlink" title="PostProcessBeforeInitialization接口实现-初始化预处理"></a>PostProcessBeforeInitialization接口实现-初始化预处理</h4><ul><li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj,String s)方法</li></ul><h4 id="init-method"><a href="#init-method" class="headerlink" title="init-method"></a>init-method</h4><ul><li>如果Bean在Spring文件中配置了init-method属性会自动调用其配置的初始化方法</li></ul><h4 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h4><ul><li>如果这个Bean关联了BeanProcessor接口，将会调用postProcessAfterInitialization(Object obj,String s)方法</li></ul><h4 id="Destory过期自动清理阶段"><a href="#Destory过期自动清理阶段" class="headerlink" title="Destory过期自动清理阶段"></a>Destory过期自动清理阶段</h4><ul><li>当Bean不在需要时，会经过清理阶段，如果Bean实现了DisposableBean接口，会调用那个其实现的destory方法</li></ul><h4 id="destory-method自配置清理"><a href="#destory-method自配置清理" class="headerlink" title="destory-method自配置清理"></a>destory-method自配置清理</h4><ul><li>最后，如果这个Bean的Spring配置中配置了destory-method属性,会调用其配置的销毁方法</li></ul><h2 id="MyBatis框架"><a href="#MyBatis框架" class="headerlink" title="MyBatis框架"></a>MyBatis框架</h2><h3 id="1-和-的区别是什么？"><a href="#1-和-的区别是什么？" class="headerlink" title="1.#{}和${}的区别是什么？"></a>1.#{}和${}的区别是什么？</h3><p><strong>#{}是预编译处理</strong>，${}是字符串替换</p><p>Mybatis在处理#{}时，会将sql中的**#{}转为？<strong>调用</strong>PrepareStatement的set方法来赋值**</p><p><strong>Mybatis在处理${}时，就是把${}替换成变量的值</strong></p><p>使用#{}可以有效的防止sql注入，提高系统安全性</p><h3 id="2-当实体类中的属性名和表中的字段名不一样，怎么办？"><a href="#2-当实体类中的属性名和表中的字段名不一样，怎么办？" class="headerlink" title="2.当实体类中的属性名和表中的字段名不一样，怎么办？"></a>2.当实体类中的属性名和表中的字段名不一样，怎么办？</h3><ol><li><p>通过在查询的sql语句中定义字段名的别名，让字段名和实体类的属性名一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=”selectorder” parametertype=”<span class="hljs-type">int</span>” resultetype=”me.gacl.domain.order”&gt;<br> select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure></li><li><p>通过来映射字段名和实体类属性名的一一对应的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;getOrder&quot;</span> parameterType=<span class="hljs-string">&quot;int&quot;</span> resultMap=<span class="hljs-string">&quot;orderresultmap&quot;</span>&gt;<br> select * from orders where order_id=#&#123;id&#125;<br> &lt;/select&gt;<br> &lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt;<br> &lt;!–用id属性来映射主键字段–&gt;<br> &lt;id property=”id” column=”order_id”&gt;<br> &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;<br> &lt;<span class="hljs-type">result</span> <span class="hljs-variable">property</span> <span class="hljs-operator">=</span> “orderno” column =”order_no”/&gt;<br> &lt;result property=”price” column=”order_price” /&gt;<br> &lt;/reslutMap&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Mysql篇"><a href="#Mysql篇" class="headerlink" title="Mysql篇"></a>Mysql篇</h2><h3 id="Mysql执行流程是怎么样的？"><a href="#Mysql执行流程是怎么样的？" class="headerlink" title="Mysql执行流程是怎么样的？"></a>Mysql执行流程是怎么样的？</h3><p>Mysql的架构分为两层：Server层和存储引擎层</p><ul><li>Server层负责建立连接、分析和执行sql<ul><li>Mysql大多数的核心功能模块都在这里实现，主要包括<strong>连接器</strong>，<strong>查询缓存</strong>，<strong>解析器</strong>，<strong>预处理器</strong>，<strong>优化器</strong>，<strong>执行器</strong>等。另外所有的内置函数(如日期、时间、教学和加密函数等)和所有跨存储引擎的功能</li></ul></li><li>存储引擎负责数据的存储和提取<ul><li>支持InnoDB、MyISAM、Memory等剁排骨存储引擎，不同的存储引擎公用一个Server层。现在最常用的存储引擎是InnoDB，从MySQL5.5开始InnoDB成了默认存储引擎，InnoDB支持索引类型是B+树</li></ul></li></ul><h4 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1.连接器"></a>1.连接器</h4><p>连接的过程需要经过TCP三次握手，因为Mysql是基于TCP协议进行传输的。</p><h5 id="如何查看Mysql服务被多少个客户端连接了？"><a href="#如何查看Mysql服务被多少个客户端连接了？" class="headerlink" title="如何查看Mysql服务被多少个客户端连接了？"></a>如何查看Mysql服务被多少个客户端连接了？</h5><p>使用show processlist命令进行查看</p><h5 id="空闲连接会一直占用吗？"><a href="#空闲连接会一直占用吗？" class="headerlink" title="空闲连接会一直占用吗？"></a>空闲连接会一直占用吗？</h5><p>不是 mysql定义了空闲连接的最大空闲时长，默认是8小时</p><h5 id="mysql的连接数有限制吗？"><a href="#mysql的连接数有限制吗？" class="headerlink" title="mysql的连接数有限制吗？"></a>mysql的连接数有限制吗？</h5><p>mysql服务支持的的最大连接数由max_connections参数控制</p><h5 id="mysql的连接和http一样，有短链接和长连接的概念"><a href="#mysql的连接和http一样，有短链接和长连接的概念" class="headerlink" title="mysql的连接和http一样，有短链接和长连接的概念"></a>mysql的连接和http一样，有短链接和长连接的概念</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">// 短连接<br>连接 mysql 服务（TCP 三次握手）<br>执行sql<br>断开 mysql 服务（TCP 四次挥手）<br><br>// 长连接<br>连接 mysql 服务（TCP 三次握手）<br>执行sql<br>执行sql<br>执行sql<br>....<br>断开 mysql 服务（TCP 四次挥手）<br></code></pre></td></tr></table></figure><ul><li>使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。</li><li>但是，使用长连接后可能会占用内存增多，因为mysql在执行查询过程中使用内存管理连接对象，这些连接只有在连接断开时才会是释放，如果长连接累计很多，将导致mysql服务占用内存太大，有可能会被系统强制杀掉，这样会发生mysql服务异常重启的现象</li></ul><h5 id="怎样解决长连接占用内存的问题"><a href="#怎样解决长连接占用内存的问题" class="headerlink" title="怎样解决长连接占用内存的问题"></a>怎样解决长连接占用内存的问题</h5><ol><li>定期断开长连接</li><li>客户端主动重置链接</li></ol><h4 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h4><p>连接器的工作完成后，客户端就可以向mysql服务发发送sql语句了，mysql服务收到sql语句后，就会<strong>解析出sql的第一个字段</strong>，看看是什么类型的语句</p><p>如果sql是查询语句 mysql就会先去查询缓存里查找缓存数据，看看之前有没有执行过这一条命令，这个缓存查询是以key-value的形式保存在内存中的，key为sql查询语句，value为sql语句查询的结果</p><p>如果查询的语句命中查询缓存，那么就会直接返回value给客户端，如果查询的语句没有命中缓存，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中</p><p><strong>补充</strong></p><p>查询缓存很鸡肋</p><p>对于更新比较频繁的表 查询缓存的命中率很低 因为只要有一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存一个查询结果很大的数据，还没有被使用的时候，刚好这个表有更新操作，查询缓存就被清空了。所以Mysql 8.0直接删除掉查询缓存</p><h4 id="3-解析sql"><a href="#3-解析sql" class="headerlink" title="3.解析sql"></a>3.解析sql</h4><p>在正式进行sql查询语句之前，mysql会先对sql语句做解析，这个工作交由<strong>解析器</strong>来完成</p><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><p>解析器会做如下两件事情。</p><ol><li>词法分析。mysql会根据输入的字符串识别出关键字，构建sql语法树，这样方便后面模块获取sql类型、表名、字段名、where条件等等</li><li>语法分析，根据词法分析的结果，语法解析器会根据语法规则，判断输入的sql语句是否满足mysql语法</li><li>如果我们输入的sql语句语法不对，就会在解析器这个阶段报错。</li><li>但是表不存在或者字段不存在，并不是在解析器里做的</li></ol><h4 id="4-执行sql"><a href="#4-执行sql" class="headerlink" title="4.执行sql"></a>4.执行sql</h4><p>经过解析器后，接着就要进入执行sql查询语句的流程了 每条select查询语句流程主要分为下面三个阶段</p><ul><li>prepare阶段 预处理阶段</li><li>optimize阶段 优化阶段</li><li>execute阶段 执行阶段</li></ul><h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><ul><li>检查sql查询语句中的<strong>表或者字段</strong>是否存在</li><li>将Select * 中的 *<strong>号 扩展为表上的所有列</strong></li></ul><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>经过预处理阶段后，还需要为sql查询语句先<strong>指定一个执行计划，</strong>这个工作交由[优化器]来完成</p><ul><li>优化器主要负责将sql查询语句的执行方案确定下来，比如在表里面有多个索引的时候，<strong>优化器会基于查询成本的考虑，来决定使用哪个索引</strong></li></ul><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>经历完优化器后，就确定了执行方案，接下来mysql就真正开始执行语句了，这个过程是由执行器来完成的，在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。接下来，用三种方式执行过程。</p><h5 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h5 id="全局扫描"><a href="#全局扫描" class="headerlink" title="全局扫描"></a>全局扫描</h5><h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>执行一条sql查询语句的过程</p><ol><li>连接器：建立连接，管理连接，校验用户身份</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。</li><li>解析sql，通过解析器对sql查询语句进行词法分析，语法分析，然后构建语法树，方便后序模块读取表名、字段、语句类型。</li><li>执行sql：执行sql共有三个阶段<ol><li>预处理阶段：检查表或者字段是否存在；将select中的 * 扩展为表上所有列</li><li>优化阶段：基于<strong>查询成本</strong>的考虑，选择查询成本最小的执行计划</li><li>执行阶段：根据执行计划执行sql查询语句，从存储引擎读取记录，返回给客户端。</li></ol></li></ol><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引的定义就是<strong>帮助存储引擎快速获取数据的一种数据结构</strong>，形象的说就是<strong>索引是数据的目录</strong></p><p>所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法</p><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li>按【数据结构】分类：B+Tree索引、hash索引、Full-text索引</li><li>按【物理存储】分类：聚簇索引(主键索引)、二级索引(辅助索引)</li><li>按【字段特性】分类：主键索引、唯一索引、普通索引、前缀索引。</li><li>按【字段个数】分类：单列索引、联合索引</li></ul><p>在创建表时。InnoDB存储引擎根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）</li><li>如果没有主键，就选择第一个不包含NULL值的唯一列作为聚簇索引的索引键</li><li>在上面两个都没有的情况下，InnoDB将自动生成一个隐式自增id列作为聚簇索引的索引键</li></ul><p>其它索引都属于辅助索引。也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是B+Tree索引</p><h3 id="按【数据结构】分类"><a href="#按【数据结构】分类" class="headerlink" title="按【数据结构】分类"></a>按【数据结构】分类</h3><p>B+树索引</p><p>B+Tree是一种多叉树，<strong>叶子节点才存放数据</strong>，<strong>非叶子节点只存放索引</strong>，而且<strong>每个叶子节点里的数据是按主键顺序存放</strong>的。每一层父节点的索引值都会出现在下层叶子节点的索引值中，<strong>因此在叶子节点中，包括了所有的索引值信息</strong>，而且每一个叶子节点都指向下一个叶子节点，形成一个链表</p><p>主键索引的B+ Tree如图所示</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/btree.drawio.png" alt="主键索引 B+Tree"></p><h4 id="通过主键查询商品数据的过程"><a href="#通过主键查询商品数据的过程" class="headerlink" title="通过主键查询商品数据的过程"></a>通过主键查询商品数据的过程</h4><p>比如，我们执行了下面这条查询语句，这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：</p><ul><li>将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；</li><li>在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；</li><li>在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。</li></ul><p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I&#x2F;O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I&#x2F;O 操作。</p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</strong></p><h4 id="为什么Mysql-InnoDB选择B-Tree作为索引的数据结构"><a href="#为什么Mysql-InnoDB选择B-Tree作为索引的数据结构" class="headerlink" title="为什么Mysql InnoDB选择B+Tree作为索引的数据结构"></a>为什么Mysql InnoDB选择B+Tree作为索引的数据结构</h4><ul><li>B+ Tree vs B Tree<ul><li><strong>B+ Tree只在叶子节点存储数据 而B树的非叶子节点也要存储数据</strong> 所以<strong>B+Tree的单个节点的数据量更小</strong> 在相同的磁盘I&#x2F;O下，就能查询更多的节点</li><li>另外B+Tree叶子节点采用的是双链表连接，适合mysql中常见的<strong>基于范围</strong>的顺序查找</li></ul></li><li>B+ Tree vs 二叉树<ul><li>对于有 <strong>N 个叶子节点</strong>的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 <strong>d 表示节点允许的最大子节点个数为 d 个</strong>。</li><li>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，<strong>B+Tree 的高度依然维持在 3~4 层左右</strong>，也就是说<strong>一次数据查询操作只需要做 3~4 次的磁盘 I&#x2F;O 操作就能查询到目标数据</strong></li><li>**而二叉树的每个父节s点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>**，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 <strong>I&#x2F;O 次数要更多。</strong></li></ul></li><li>B+ Tree vs hash<ul><li>Hash在做等值查询的时候效率很快 搜索复杂度为O(1)</li><li>但是<strong>Hash表不适合做范围查询</strong>，<strong>它更适合做等值的查询</strong>，这也是B + Tree索引要比Hash表索引有着更广泛的场景的原因</li></ul></li></ul><h3 id="按【字段特性】分类："><a href="#按【字段特性】分类：" class="headerlink" title="按【字段特性】分类："></a>按【字段特性】分类：</h3><ul><li><p>主键索引</p><ul><li><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name  (<br>  ....<br>  <span class="hljs-keyword">PRIMARY</span> KEY (index_column_1) <span class="hljs-keyword">USING</span> BTREE<br>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>唯一索引</p><ul><li><p>唯一索引建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值</p></li><li><p>在创建表时，创建唯一索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name  (<br>  ....<br>  <span class="hljs-keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>普通索引</p><ul><li><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为UNIQUE。</p></li><li><p>在创建表时，创建普通索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name  (<br>  ....<br>  INDEX(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>前缀索引</p><ul><li><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为char、varchar、binary、varbinary的列上</p></li><li><p>使用前缀索引的目的是为了减少索引占用的储存空间，提升查询效率</p></li><li><p>在创建表时，创建前缀索引的方式如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name(<br>    column_list,<br>    INDEX(column_name(length))<br>); <br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h3><p>从字段个数的角度来看，索引分为单列索引，联合索引</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引</li><li>建立在多列上的索引称为联合索引</li></ul><h4 id="什么时候需要-x2F-不需要创建索引"><a href="#什么时候需要-x2F-不需要创建索引" class="headerlink" title="什么时候需要&#x2F;不需要创建索引"></a>什么时候需要&#x2F;不需要创建索引</h4><p>索引最大的好处就是提高查询速度，但是索引也是有缺点的,比如：</p><ul><li>需要<strong>占用物理空间</strong>，数量越大，占用空间越大</li><li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增大而增大</li><li><strong>会降低表的增删改的效率</strong>，因为每次增删改索引 ，B+树为了维护索引有序性，都需要进行<strong>动态维护</strong></li></ul><p>所以索引不是万能钥匙，需要根据场景来使用</p><h4 id="什么时候使用索引？"><a href="#什么时候使用索引？" class="headerlink" title="什么时候使用索引？"></a>什么时候使用索引？</h4><ul><li><strong>字段有唯一性限制的</strong>，比如商品编码</li><li><strong>经常用于where</strong>查询条件的字段，这样能提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引</li><li>经常用于<strong>Group By 和 Order By</strong>的字段，<strong>这样在查询的时候就不需要再去做一次排序了</strong>，因为我们都已经直到了建立索引之后B+树都是已经排序好的</li></ul><h4 id="什么时候不需要索引？"><a href="#什么时候不需要索引？" class="headerlink" title="什么时候不需要索引？"></a>什么时候不需要索引？</h4><ul><li>Where条件，Group by Order by 里用不到的字段，索引的价值是快速定位 如果起不到定位的字段是不需要创建索引的，因为索引是会占用物理空间的。</li><li><strong>字段中存在大量重复数据，不需要创建索引</strong>，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li><strong>表数据太少的时候</strong>，不需要创建索引；</li><li><strong>经常更新的字段不用创建索引</strong>，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h3 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h3><p>挖个坑</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png" alt="img"></p><h3 id="从数据页的角度看B-树"><a href="#从数据页的角度看B-树" class="headerlink" title="从数据页的角度看B+树"></a>从数据页的角度看B+树</h3><h3 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h3><ul><li><p><strong>原子性</strong>：一个事务中的所有操作，<strong>要么全部完成</strong>，<strong>要么全部不完成</strong>，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样</p></li><li><p><strong>一致性</strong>：是指事务操作前和操作后，数据满足<strong>完整性约束</strong>，<strong>数据库保持一致性状态。</strong></p></li><li><p><strong>隔离性</strong>：数据库允许<strong>多个并发事务</strong>同时对其数据进行读写和修改的能力，隔离性可以<strong>防止多个事务并发执行时由于交叉执行而导致数据的不一致</strong></p></li><li><p><strong>持久性</strong>：事务处理结束后，对数据的<strong>修改就是永久的</strong>，即便系统故障也不会丢失</p><p>”吃一个源“</p></li></ul><h3 id="InnoDB引擎通过什么技术来保证事务的这四个特性？"><a href="#InnoDB引擎通过什么技术来保证事务的这四个特性？" class="headerlink" title="InnoDB引擎通过什么技术来保证事务的这四个特性？"></a>InnoDB引擎通过什么技术来保证事务的这四个特性？</h3><ul><li>持久性是通过redo log 重做日志来保证的</li><li>原子性是通过 undo log 回滚日志来保证的</li><li>隔离性是通过 <strong>MVCC 多版本并发控制</strong>来保证的</li><li>一致性是通过持久性 + 原子性 + 隔离性来保证</li></ul><h3 id="并行事务会发生什么问题"><a href="#并行事务会发生什么问题" class="headerlink" title="并行事务会发生什么问题"></a>并行事务会发生什么问题</h3><p>Mysql服务端是允许多个客户端连接的，这意味这mysql会出现同时处理多个事务的情况</p><p>处理多个事务的时候，就会出现  脏读 不 、可重复读 幻读  的问题</p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>如果一个事务读到了另一个<strong>未提交事务修改过的数据</strong> 就意味着发生了<strong>脏读</strong></p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>在一个事务内多次读取同一个数据 如果出现前后两次读到的数据不一样的情况，就意味着发生了不可重复读现象</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后查询到的记录数量不一样的情况，就意味着发生了幻读现象</p><h3 id="事务的隔离级别有哪些"><a href="#事务的隔离级别有哪些" class="headerlink" title="事务的隔离级别有哪些"></a>事务的隔离级别有哪些</h3><p>对于脏读 不可重复读 幻读 </p><p>sql标准提出了四种隔离级别来规避这种现象，隔离级别越高，性能效率就越低</p><ul><li><p>读未提交： 指一个事务还没提交时，他做的变更就能被其它事务看到</p></li><li><p>读提交：指一个事务提交之后，他做的变更才能被其它事务看到</p></li><li><p>可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的  （默认）</p><p>一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的</p></li><li><p>串行化：会对记录加上<strong>读写锁</strong>，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，<strong>后访问的事务必须等前一个事务执行完成</strong>，才能继续执行；</p></li><li><p>针对不同的隔离级别，并发事务时可能发生的现象也不同</p></li></ul><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221108153319849.png" alt="image-20221108153319849"></p><p>也就是说：</p><ol><li>在读未提交的隔离级别下，可能会发生脏读、不可重复读和幻读现象</li><li>在读提交的隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象</li><li>在可重复读隔离级别下，可能发生幻读现象，但是不可能发生脏读和不可重复读现象</li><li>在串行化隔离级别下，脏读、不可重复读和幻读现象都不可能会发生</li></ol><h3 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h3><h3 id="Mysql有哪些锁"><a href="#Mysql有哪些锁" class="headerlink" title="Mysql有哪些锁"></a>Mysql有哪些锁</h3><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>要使用全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其它线程执行以下操作，都会被阻塞</p><ul><li>对数据的增删改操作</li><li>对表结构的更改操作 alter table 、drop table等</li></ul><p>如果要释放全局锁，则要执行这条命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure><h4 id="全局锁的应用场景是什么"><a href="#全局锁的应用场景是什么" class="headerlink" title="全局锁的应用场景是什么"></a>全局锁的应用场景是什么</h4><p>全局锁主要应用于做全库<strong>逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据和预期的不一样</p><h4 id="加全局锁又会带来什么缺点呢"><a href="#加全局锁又会带来什么缺点呢" class="headerlink" title="加全局锁又会带来什么缺点呢"></a>加全局锁又会带来什么缺点呢</h4><p>加上全局锁，意味着整个数据苦都是只读状态 那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能数据，而不能更新数据，这样会造成业务停滞</p><h2 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h2><h3 id="1-为什么要用缓存？"><a href="#1-为什么要用缓存？" class="headerlink" title="1.为什么要用缓存？"></a>1.为什么要用缓存？</h3><p>使用缓存的目的就是提升读写性能，而实际业务场景下，更多的就是为了<strong>提升读写性能</strong>，带来更好的性能，带来更高的并发量。Redis的读写性能比Mysql好的多，我们就可以吧Mysql中的<strong>热点数据</strong>缓存到Redis中，提升读写性能，同时也<strong>减轻了Mysql的读写压力</strong></p><h3 id="2-使用Redis有哪些好处？"><a href="#2-使用Redis有哪些好处？" class="headerlink" title="2.使用Redis有哪些好处？"></a>2.使用Redis有哪些好处？</h3><ul><li>读取速度快，因为<strong>数据存在内存</strong>中，所以数据存取快</li><li><strong>支持多种数据结构</strong>，包括字符串、列表、集合、有序集合、哈希等</li><li><strong>支持事务</strong>，且<strong>操作遵守原子性</strong>，即对数据的操作要么都执行，要么都不支持</li><li>还<strong>拥有其他丰富的功能</strong>，队列、主从复制、集群、数据持久化等功能。</li></ul><h3 id="3-为什么Redis单线程模型效率也能那么高"><a href="#3-为什么Redis单线程模型效率也能那么高" class="headerlink" title="3.为什么Redis单线程模型效率也能那么高"></a>3.为什么Redis单线程模型效率也能那么高</h3><ol><li><strong>C语言实现</strong>，效率高</li><li><strong>纯内存</strong>操作</li><li>基于<strong>IO多路复用机制</strong>提升Redis的I&#x2F;O效率</li><li><strong>丰富的数据结构</strong></li></ol><h3 id="4-Redis到底是单线程还是多线程"><a href="#4-Redis到底是单线程还是多线程" class="headerlink" title="4.Redis到底是单线程还是多线程"></a>4.Redis到底是单线程还是多线程</h3><ul><li>Redis6.0版本之前的单线程是指其网络I&#x2F;O和键值对读写是由一个线程完成的</li><li>Redis6.0引入的多线程指的是网络请求过程采用了多线程，而键值对读写命令任然是单线程处理的，所以Redis依然是并发安全的</li></ul><h3 id="5-Redis底层数据是如何用跳表来存储的"><a href="#5-Redis底层数据是如何用跳表来存储的" class="headerlink" title="5.Redis底层数据是如何用跳表来存储的"></a>5.Redis底层数据是如何用跳表来存储的</h3><p>跳表：将有序链表改造为支持近似“折半查找”算法，可以进行快速的插入、删除、查找操作。</p><p><img src="C:\Users\TC\AppData\Roaming\Typora\typora-user-images\image-20221104205304032.png" alt="image-20221104205304032"></p><h3 id="6-Redis-key过期了为什么内存没有释放？"><a href="#6-Redis-key过期了为什么内存没有释放？" class="headerlink" title="6.Redis key过期了为什么内存没有释放？"></a>6.Redis key过期了为什么内存没有释放？</h3><ul><li>Set命令如果不设置过期时间，那么Redis会自动擦除这个key的过期时间</li><li>Redis对于过期key的处理一般有惰性删除和定式删除两种册略<ul><li>惰性删除：当读&#x2F;写一个已经过期的key时，会触发惰性删除册略，判断key是否过期，如果过期了直接删除掉这个key</li><li>定时删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期(默认每100ms)主动淘汰一批过期的key，这里的一批<strong>只是部分过期key</strong>，所以可能会出现部分key已经过期但还没有被清理掉的情况，导致内存并没有释放</li></ul></li></ul><h3 id="7-Redis没设置过期时间为什么被Redis主动删除了"><a href="#7-Redis没设置过期时间为什么被Redis主动删除了" class="headerlink" title="7.Redis没设置过期时间为什么被Redis主动删除了"></a>7.Redis没设置过期时间为什么被Redis主动删除了</h3><p>当Redis已用<strong>内存超过maxmemory限定时，触发主动清理策略</strong></p><p><strong>主动清理策略</strong>主要分为以下三类</p><ol><li>针对<strong>设置了过期时间</strong>的key做处理<ol><li>volatile-ttl : 在筛选时，会针对设置了过期时间的键值对，根据<strong>过期时间的先后进行</strong>删除，<strong>越早过期的越先被删除。</strong></li><li>volatile-random： 就像它的名称一样，在设置了过期时间的键值对中，进行<strong>随机</strong>删除。</li><li>volatile-LRU:会使用LRU算法筛选设置了过期时间的键值对删除</li><li>volatile-LFU:会使用LFU算法筛选设置了过期时间的键值对删除</li></ol></li><li>针对<strong>所有key</strong>做处理<ol><li>allkeys-random： 从所有键值对中随机选择并删除数据</li><li>allkeys-LRU：使用LRU算法在所有数据中进行筛选删除</li><li>allkeys： 使用LFU算法在所有数据中进行筛选删除</li></ol></li><li><strong>不处理</strong><ol><li>noevction： 不会剔除任何数据，拒绝写入操作并返回客户端错误信息</li></ol></li></ol><h3 id="8-Redis淘汰算法LRU和LFU的区别"><a href="#8-Redis淘汰算法LRU和LFU的区别" class="headerlink" title="8.Redis淘汰算法LRU和LFU的区别"></a>8.Redis淘汰算法LRU和LFU的区别</h3><ol><li>LRU算法 ：淘汰很久没有被访问的数据，一最近一次访问<strong>时间</strong>作为参考</li><li>LFU算法：淘汰最近一段时间被访问你<strong>次数</strong>最少的数据，以次数作为参考，绝大多数情况我们都可以用LRU策略，当存在大量的<strong>热点缓存数据</strong>时，LFU更好</li></ol><h3 id="9-Redis持久化机制"><a href="#9-Redis持久化机制" class="headerlink" title="9.Redis持久化机制"></a>9.Redis持久化机制</h3><ol><li><p>RDB持久化方式</p><p>将某一个时刻的内存快照，<strong>以二进制的方式写入磁盘</strong></p><p>手动触发：</p><ul><li>save命令，使Redis处于阻塞状态，直到RDB持久化完成，才会响应其它客户端发来的指令，所以在生产环境下不建议</li><li>bgsave命令。<strong>fork出一个子进程执行持久化</strong>，主进程只在fork过程中有短暂的阻塞，子进程创建之后，主进程就可响应客户端请求<ul><li>父进程和子进程共享一块内存空间，利用操作系统的”写时拷贝“，如果父进程写的话就会copy一个副本，在副本中修改数据</li></ul></li></ul><p>自动触发：</p><ul><li>save m n 在m秒内 如果有n个键发生改变 则自动触发持久化，通过bgsave执行，如果设置多个，只要满足其一就会触发，配置文件中有默认配置(可以注释掉)</li><li>flushall: 清空redis所有的数据库，flushdb清空当前redis所在库数据(默认是0号数据库)，会清空RDB文件</li><li>主从同步：全量同步时会自动触发bgsave命令，生成rdb发送给从节点</li></ul><p>优点：</p><p>​1.整个Redis数据库将只包含一个文件dump.rdb，方便持久化</p><p>​2.容灾性好，方便备份</p><p>​3.性能最大化。fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能</p><p>​4.数据集大时，比AOF启动效率高</p><p>缺点：</p><ol><li>数据安全性低，RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</li><li>由于RDB是通过fork子进程来协助完成持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，会占用cpu</li></ol></li></ol><p>2.AOF</p><p>​以日志的形式记录服务器所处理的写、删除操作，查询操作不会记录，以文本的方式记录，可以打开看到详细的操作记录，调操作系统命令进程刷盘</p><ol><li>所有写命令都会追加到AOF缓冲中</li><li>AOF缓冲区根据对应的策略向硬盘进行同步操作</li><li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的命令</li><li>当Redis重启时，可以加载AOF文件进行数据恢复</li></ol><p>同步策略：</p><ol><li>每秒同步：异步完成，效率很高，一旦系统出现宕机现象，那么这一秒中内修改的数据将会丢失</li><li>每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢一条</li><li>不同步，由操作系统控制</li></ol><p>优点：</p><ul><li>数据安全</li><li>通过append模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性的问题</li><li>AOF机制的rewrite模式。定期对AOF文件进行重写，以达到压缩的目的</li></ul><p>缺点：</p><ul><li>AOF文件比RDB大，且恢复速度慢</li><li>数据集大的时候，启动效率低</li><li>运行效率没有RDB高</li></ul><p>10.Redis过期键的删除策略</p><p>​Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间，Redis的过期策略就是指当Redis中缓存的key过期时，Redis如何处理</p><ul><li>惰性过期：只有当访问一个key时，才会判断该key是否已经过期，过期则清除，该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li>定期过期：每隔一定的时间，会扫描<strong>一定数量</strong>的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个这种方案。</li></ul><p>Redis中同时使用了惰性过期和定时过期两种过期策略</p>]]></content>
    
    
    <categories>
      
      <category>/学习/面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股废柴</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客网Java刷题</title>
    <link href="/2022/09/06/%E7%89%9B%E5%AE%A2%E7%BD%91Java%E5%88%B7%E9%A2%98/"/>
    <url>/2022/09/06/%E7%89%9B%E5%AE%A2%E7%BD%91Java%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1、JDK8之前版本，HashMap的数据结构是怎样的？"><a href="#1、JDK8之前版本，HashMap的数据结构是怎样的？" class="headerlink" title="1、JDK8之前版本，HashMap的数据结构是怎样的？"></a>1、JDK8之前版本，HashMap的数据结构是怎样的？</h3><p><strong>答</strong> ： 数组+链表&#x2F;红黑树<br>1、HashMap 底层的数据是数组被成为哈希桶（默认的初始值为 16 ），每个桶存放的是链表，链表中的每个节点，就是 HashMap 中的每个元素。<br>2、在 JDK 8 当链表长度大于等于 8 时，就会转成红黑树的数据结构，以提升查询和插入的效率。<br>HashMap在Node数组中进行哈希查找,使用链接法处理冲突,冲突较少时使用链表,目前版本当冲突的键达到8时,会把链表转换为红黑树.</p><h3 id="2、假设有以下代码"><a href="#2、假设有以下代码" class="headerlink" title="2、假设有以下代码"></a>2、假设有以下代码</h3><p><strong>String s &#x3D; “hello”；String t &#x3D; “hello”；char c [ ] &#x3D; {‘h’,’e’,’l’,’l’,’o’}；</strong><br><strong>返回false的是：</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">s.<span class="hljs-keyword">equals</span> (t)；<br>t.<span class="hljs-keyword">equals</span> (c)；<br>s==t<br>t.<span class="hljs-keyword">equals</span> (<span class="hljs-literal">new</span> <span class="hljs-built_in">String</span> (<span class="hljs-string">&quot;hello&quot;</span>))；<br></code></pre></td></tr></table></figure><p><strong>答：</strong> B<br>    本题我们需要掌握三个知识 ： </p><ol><li><p>“&#x3D;&#x3D; 和 equals的区别” ： </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">== 的作用：<br>基本类型：比较值是否相等<br>引用类型：比较内存地址值是否相等<br>equals 的作用:<br>只能用于引用类型：默认情况下，比较内存地址值是否相等。可以按照需求逻辑，重写对象的equals方法。<br></code></pre></td></tr></table></figure></li><li><pre><code class="hljs">String两种创建对象的方式</code></pre><p>String str &#x3D; “123”;</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">通过引号直接创建字符串对象，先会先从常量池中判断是否存在 “123” 对象，如果不存在，则会在常量池中创建该对象，并且返回常量池中 “123” 对象的引用给 str；如果存在 “123” 话，则直接返回常量池中 “123” 的对象引用。<br></code></pre></td></tr></table></figure></li></ol><p>String str &#x3D; new String(“123”); 　　</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">首先 “123” 是一个常量字符串，因此会先在常量池中创建 “123” 字符串对象，然后在堆中再创建一个字符串对象，将 “123” 的字符数组复制到堆中新创建的对象的字符数组上，因此该方式不仅会在堆中，还会在常量池中创建 “123” 字符串对象。str最终指向的是堆中的字符串对象<br></code></pre></td></tr></table></figure><h3 id="3、下列代码打印出的结果为"><a href="#3、下列代码打印出的结果为" class="headerlink" title="3、下列代码打印出的结果为"></a>3、下列代码打印出的结果为</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> output = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">inti</span>)<br>    &#123;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e)<br>        &#123;<br>            output += <span class="hljs-string">&quot;2&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125; <span class="hljs-keyword">finally</span><br>        &#123;<br>            output += <span class="hljs-string">&quot;3&quot;</span>;<br>        &#125;<br>        output += <span class="hljs-string">&quot;4&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)<br>    &#123;<br>        <span class="hljs-title function_">foo</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(output);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>答：</strong> 首先是foo(0),在try代码块中未抛出异常，finally是无论是否抛出异常必定执行的语句，<br>所以 output +&#x3D; “3”;然后是 output +&#x3D; “4”;<br>执行foo(1)的时候，try代码块抛出异常，进入catch代码块，output +&#x3D; “2”;<br>前面说过<strong>finally是必执行的</strong>，<strong>即使return也会执行</strong>output +&#x3D; “3”<br>由于catch代码块中有return语句，最后一个output +&#x3D; “4”不会执行。<br>所以结果是3423</p><h3 id="4、下面是java语言的基本特性是？（）"><a href="#4、下面是java语言的基本特性是？（）" class="headerlink" title="4、下面是java语言的基本特性是？（）"></a>4、下面是java语言的基本特性是？（）</h3><p>A.封装<br>B.多态<br>C.继承<br>D.高效<br><strong>答：</strong> 封装 继承 多态 还有个抽象（ABC）</p><h3 id="4、Servlet的生命周期"><a href="#4、Servlet的生命周期" class="headerlink" title="4、Servlet的生命周期"></a>4、Servlet的生命周期</h3><p>Servlet的生命周期一般可以用三个方法来表示：<br>init()：仅执行一次，负责在装载Servlet时初始化Servlet对象<br>service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。<br>destory()：在停止并且卸载Servlet时执行，负责释放资源</p><h3 id="5、能用来修饰interface的有（）"><a href="#5、能用来修饰interface的有（）" class="headerlink" title="5、能用来修饰interface的有（）"></a>5、能用来修饰interface的有（）</h3><p>接口是用来被类实现的，它的权限当然默认是公共的为public。接口内的方法也默认为public abstract，是公共权限的抽象方法。<br>但是在jdk1.8后，接口中也可以有default修饰的静态方法，但是这个方法一定要有方法体。我们可以通过接口名.方法名的方式直接调用该方法。</p><h3 id="6、执行以下程序后的输出结果是（）"><a href="#6、执行以下程序后的输出结果是（）" class="headerlink" title="6、执行以下程序后的输出结果是（）"></a>6、执行以下程序后的输出结果是（）</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-built_in">StringBuffer</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(<span class="hljs-string">&quot;A&quot;</span>); <br>        <span class="hljs-built_in">StringBuffer</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(<span class="hljs-string">&quot;B&quot;</span>); <br>        <span class="hljs-keyword">operator</span>(a, b); <br>        System.out.println(a + <span class="hljs-string">&quot;,&quot;</span> + b); <br>    &#125; <br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>(<span class="hljs-built_in">StringBuffer</span> x, <span class="hljs-built_in">StringBuffer</span> y) &#123; <br>        x.append(y); y = x; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>StringBuffer a &#x3D; newStringBuffer(“A”);<br>StringBuffer b &#x3D; newStringBuffer(“B”);<br>此时内存中的状态如下图所示：<br><img src="/./images/1662277611406.png" alt="enter description here"></p><p>publicstaticvoidoperator(StringBuffer x, StringBuffer y) {<br>    x.append(y); y &#x3D; x;<br>}<br>进入如下方法后,内存中的状态为：<br><img src="/./images/1662277625158.png" alt="enter description here"></p><p> x.append(y);<br>这条语句执行后,内存的状态为：</p><p><img src="/./images/1662277638189.png" alt="enter description here"><br> y &#x3D; x;<br>这条语句执行后,内存的状态为：</p><p><img src="/./images/1662277655335.png" alt="enter description here"><br>当operator方法执行完毕后内存中的状态为：<br><strong>因为方法执行完毕，局部变量消除。</strong><br>有内存中的状态,可以知道最后的结果。<br><img src="/./images/1662277664139.png" alt="enter description here"></p><h3 id="7、一般用-创建InputStream对象-表示从标准输入中获取数据-用-创建OutputStream对象，表示输出到标准输出设备中"><a href="#7、一般用-创建InputStream对象-表示从标准输入中获取数据-用-创建OutputStream对象，表示输出到标准输出设备中" class="headerlink" title="7、一般用()创建InputStream对象,表示从标准输入中获取数据,用()创建OutputStream对象，表示输出到标准输出设备中"></a>7、一般用()创建InputStream对象,表示从标准输入中获取数据,用()创建OutputStream对象，表示输出到标准输出设备中</h3><p>A.System.in System.out<br>B.System.out System.in<br>C.System.io.in System.io.out<br>D.System.io.out System.io.in</p><p>A</p><h3 id="8、关于ASCII码和ANSI码，以下说法不正确的是（）"><a href="#8、关于ASCII码和ANSI码，以下说法不正确的是（）" class="headerlink" title="8、关于ASCII码和ANSI码，以下说法不正确的是（）"></a>8、关于ASCII码和ANSI码，以下说法不正确的是（）</h3><p>A.标准ASCII只使用7个bit<br>B.在简体中文的Windows系统中，ANSI就是GB2312<br>C.ASCII码是ANSI码的子集<br>D.ASCII码都是可打印字符<br><strong>答：</strong> D<br><strong>ANSCII和ANSI核心区别：</strong><br>ASCII面向美国以及一些西欧文字编码方案<br>ANSI编码包含ASCII之外还有其他国家自己的编码方案</p><p>ASCII(American Standard Code for Information Interchange,美国信息交换标准代码)<br><strong>ASCII是什么：</strong><br>ASCII一种标准的单字节字符编码方案<br><strong>ASCII特性:</strong><br>ASCII 保留前 32 个代码（数字 0-31 十进制）用于控制字符：代码最初不打算表示可打印信息（0-127与ANSI编码重叠)</p><p>ANSI(American National Standards Institute,美国国家标准学会)<br><strong>ANSI是什么：</strong><br>ANSI一种字符代码<br><strong>ANSI特性：</strong></p><h2 id="ANSI编码仅在前128（0-127）个与ASCII码相同，之后的字符全是某个国家语言的所有字符。"><a href="#ANSI编码仅在前128（0-127）个与ASCII码相同，之后的字符全是某个国家语言的所有字符。" class="headerlink" title="ANSI编码仅在前128（0-127）个与ASCII码相同，之后的字符全是某个国家语言的所有字符。"></a>ANSI编码仅在前128（0-127）个与ASCII码相同，之后的字符全是某个国家语言的所有字符。</h2><p>ANSI编码用了8个位（最多256种组合可以表示256个不同的字<br>ANSCI编码两个字节最多可以存储的字符数目是2的16次方，即65536个字符<br>各国有各国的标准。受制于当时的条件，不同语言之间的ANSI码之间不能互相转换<br>在简体中文Windows操作系统中，ANSI 编码代表 GB2312编码；<br>在繁体中文Windows操作系统中，ANSI编码代表Big5；<br>在日文Windows操作系统中，ANSI 编码代表 JIS 编码。</p><h3 id="9、往OuterClass类的代码段中插入内部类声明-哪一个是错误的"><a href="#9、往OuterClass类的代码段中插入内部类声明-哪一个是错误的" class="headerlink" title="9、往OuterClass类的代码段中插入内部类声明, 哪一个是错误的:"></a>9、往OuterClass类的代码段中插入内部类声明, 哪一个是错误的:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">OuterClass</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> f=<span class="hljs-number">1.0f</span>;<br>    <span class="hljs-comment">//插入代码到这里</span><br>&#125;<br></code></pre></td></tr></table></figure><p>A.class InnerClass{<br>    public static float func(){return f;}<br>}<br>B.bstract class InnerClass{<br>    public abstract float func(){}<br>}<br>C.static class InnerClass{<br>    protected static float func(){return f;}<br>}<br>D.public class InnerClass{<br>     static float func(){return f;}<br>}</p><p><strong>答：</strong><br>主要考核了这几个知识点：<br>1.静态内部类才可以声明静态方法<br>2.静态方法不可以使用非静态变量<br>3.抽象方法不可以有函数体</p><h3 id="10、以下那些代码段能正确执行"><a href="#10、以下那些代码段能正确执行" class="headerlink" title="10、以下那些代码段能正确执行"></a>10、以下那些代码段能正确执行</h3><p>public static void main(String args[]) {<br>    byte a &#x3D; 3;<br>    byte b &#x3D; 2;<br>    b &#x3D; a + b;<br>    System.out.println(b);<br>}</p><p>public static void main(String args[]) {<br>    byte a &#x3D; 127;<br>    byte b &#x3D; 126;<br>    b &#x3D; a + b;<br>    System.out.println(b);<br>}</p><p>public static void main(String args[]) {<br>    byte a &#x3D; 3;<br>    byte b &#x3D; 2;<br>    a+&#x3D;b;<br>    System.out.println(b);<br>}</p><p>public static void main(String args[]) {<br>    byte a &#x3D; 127;<br>    byte b &#x3D; 127;<br>    a+&#x3D;b;<br>    System.out.println(b);<br>}</p><p><strong>答：</strong><img src="/./images/1662299525999.png" alt="enter description here"><br>CD +&#x3D;会进行自动强制转换<br>摘自韩顺平笔记</p><h3 id="11、Java的一些概念，下面哪些描述是正确的："><a href="#11、Java的一些概念，下面哪些描述是正确的：" class="headerlink" title="11、Java的一些概念，下面哪些描述是正确的：(    )"></a>11、Java的一些概念，下面哪些描述是正确的：(    )</h3><p>A.所有的Java异常和错误的基类都是java.lang.Exception, 包括java.lang.RuntimeException<br>B.通过try … catch … finally语句，finally中的语句部分无论发生什么异常都会得到执行<br>C.java中所有的数据都是对象<br>D.Java通过垃圾回收回收不再引用的变量，垃圾回收时对象的finallize方法一定会得到执行<br>E.Java是跨平台的语言，无论通过哪个版本的Java编写的程序都能在所有的Java运行平台中运行<br>F.Java通过synchronized进行访问的同步，synchronized作用非静态成员方法和静态成员方法上同步的目标是不同的</p><p><strong>答：</strong>  A.异常是Exception 错误是ERROR<br>         C.基本类型不是对象<br>         D.finalize]这个方法一个对象只能执行一次, 只能在第一次进入被回收的队列, 而且对象所属于的类重写了finalize方法才会被执行, 第二次进入回收队列时, 不会再执行finalize方法, 而是直接被二次标记, 在下一次,GC的时候被清理.<br>         E.java跨平台，但是低版本的JRE不能运行高版本的<br>         F.非静态方法锁的是实例的对象：多个非静态方法同时加了synchronized，互不影响，静态锁的是类：多个静态方法加了synchronized，如果其中一个方法被锁了，其他的静态方法是拿不到锁的，没法执行，只有等该方法执行结束，其它静态方法才能拿到锁</p><h3 id="下面关于变量及其范围的陈述哪些是不正确的（）"><a href="#下面关于变量及其范围的陈述哪些是不正确的（）" class="headerlink" title="下面关于变量及其范围的陈述哪些是不正确的（）"></a>下面关于变量及其范围的陈述哪些是不正确的（）</h3><p> 实例变量是类的成员变量<br>实例变量用关键字static声明<br>在方法中定义的局部变量在该方法被执行时创建<br>局部变量在使用前必须被初始化<br><strong>答：</strong> BC<br>C.不是局部变量在该方法被执行&#x2F;调用时创建，而是应该为在该变量被声明并赋值时创建，可以理解为“当代码执行到该变量被赋值的代码时才被创建”</p><h3 id="12、下面哪些接口直接继承自Collection接口（）"><a href="#12、下面哪些接口直接继承自Collection接口（）" class="headerlink" title="12、下面哪些接口直接继承自Collection接口（）"></a>12、下面哪些接口直接继承自Collection接口（）</h3><p>A.List<br>B.Map<br>C.Set<br>D.Iterator</p><p><strong>答：</strong> AC见下图<br><img src="/./images/1662304474513.png" alt="enter description here"></p><h3 id="13、有关finally语句块说法正确的是（-）"><a href="#13、有关finally语句块说法正确的是（-）" class="headerlink" title="13、有关finally语句块说法正确的是（ ）"></a>13、有关finally语句块说法正确的是（ ）</h3><p>A.不管catch是否捕获异常，finally语句块都是要被执行的<br>B.在try语句块或catch语句块中执行到System.exit(0)直接退出程序<br>C.finally块中的return语句会覆盖try块中的return返回<br>D.finally 语句块在 catch语句块中的return语句之前执行<br><strong>答：</strong> ABC<br>A选项：<br><img src="/./images/1662305821345.png" alt="enter description here"></p><p><img src="/./images/1662305910334.png" alt="enter description here"><br>说明A选项正确，无论try中是否有异常，都会执行finally语句</p><p>B选项：<br><img src="/./images/1662306266132.png" alt="enter description here"></p><p>B选项正确，如果执行System.exit(0) 程序会直接退出不管return语句</p><p>C选项 ：<br>覆盖前：<br><img src="/./images/1662307013475.png" alt="enter description here"></p><p>覆盖后：</p><p><img src="/./images/1662306954574.png" alt="enter description here"><br>对于d选项：<br>return语句会先于finally语句块执行但值会被保存且不返回，转而先去运行finally语句块，之后再返回</p>]]></content>
    
    
    <categories>
      
      <category>/学习/面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股废柴</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>parameterType和@Param的区别</title>
    <link href="/2022/09/03/parameterType%E5%92%8C@Param%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/09/03/parameterType%E5%92%8C@Param%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="parameterType-用法"><a href="#parameterType-用法" class="headerlink" title="parameterType 用法"></a>parameterType 用法</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">该参数是<span class="hljs-keyword">select</span>、<span class="hljs-keyword">insert</span>等其他的标签中的参数，用于数据的录入使用，该参数只表示一个参数类型，但是如果有多个参数的话，就不要使用该参数了，在讲解该参数之前，我们一定要先有这样的一种意识，如果让我们设计，那么应该怎么设计参数和<span class="hljs-keyword">sql</span>占位符的匹配，这里其实就是按照两种方式类型和名称。<br></code></pre></td></tr></table></figure><h2 id="一、一个参数"><a href="#一、一个参数" class="headerlink" title="一、一个参数"></a>一、一个参数</h2><p>对于这种一个参数的这种其实没有必要写parameterType，而且还有就是多个参数的时候也没有必要写parameterType，也就是说，其实该参数的存在是不是特别必要的。其中@Param和parameterType 二者存其一即可。看名字就能知道ParameterType是按照类型进行匹配，而@Param是按照名字进行匹配，因此可以联想下，多个参数的时候按名字匹配即可，对于按照类型就不能匹配了。如下是该参数标识的类型对应的别名</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">别名                        映射的类型<br>_byte                       <span class="hljs-type">byte</span><br>_long                       <span class="hljs-type">long</span><br>_short                       <span class="hljs-type">short</span><br>_int                       int<br>_integer                       int<br>_double                       <span class="hljs-type">double</span><br>_float                       float<br>_boolean                       <span class="hljs-type">boolean</span><br><span class="hljs-type">string</span>                       <span class="hljs-type">String</span><br><span class="hljs-type">byte</span>                       <span class="hljs-type">Byte</span><br><span class="hljs-type">long</span>                       <span class="hljs-type">Long</span><br><span class="hljs-type">short</span>                       <span class="hljs-type">Short</span><br>int                          <span class="hljs-type">Integer</span><br><span class="hljs-type">integer</span>                       <span class="hljs-type">Integer</span><br><span class="hljs-type">double</span>                       <span class="hljs-type">Double</span><br>float                       Float<br><span class="hljs-type">boolean</span>                       <span class="hljs-type">Boolean</span><br><span class="hljs-type">date</span>                       <span class="hljs-type">Date</span><br><span class="hljs-type">decimal</span>                       BigDecimal<br>bigdecimal                     BigDecimal<br><span class="hljs-type">object</span>                       <span class="hljs-type">Object</span><br>map                          Map        <br>hashmap                       HashMap<br>list                       List<br>arraylist                    ArrayList<br>collection                    Collection<br><span class="hljs-keyword">iterator</span>                       <span class="hljs-keyword">Iterator</span><br></code></pre></td></tr></table></figure><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h3><h4 id="1-只含parameterType"><a href="#1-只含parameterType" class="headerlink" title="1.只含parameterType"></a>1.只含parameterType</h4><p>则只按照类型匹配，而不会考虑名字的匹配</p><p>SOACoupon parameterTypeOneParam(Integer id);</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;parameterTypeOneParam&quot;</span> parameterType=<span class="hljs-string">&quot;int&quot;</span> resultType=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tbl_coupon <span class="hljs-keyword">where</span> id = <span class="hljs-meta">#&#123;3333333&#125;</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="2-只含有-Param"><a href="#2-只含有-Param" class="headerlink" title="2.只含有@Param"></a>2.只含有@Param</h4><p>这种就会只按照名字匹配，而不是按照类型匹配了，如果名字不同，则会异常</p><p>SOACoupon parameterTypeOneParam(@Param(“idd”) Integer id);</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;parameterTypeOneParam&quot;</span> resultType=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tbl_coupon <span class="hljs-keyword">where</span> id = <span class="hljs-meta">#&#123;idd&#125;</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><p>3.都不包含<br>都不包含，则默认按照类型匹配，主要是占位符那里有个占位符，入参有一个参数，匹配一下即可</p><p>SOACoupon parameterTypeOneParam(Integer id);</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;parameterTypeOneParam&quot;</span> resultType=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tbl_coupon <span class="hljs-keyword">where</span> id = <span class="hljs-meta">#&#123;idddd&#125;</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><p>4.都包含<br>都包含，则按照名字匹配，这个时候其实parameterType已经没有什么作用了</p><p>SOACoupon parameterTypeOneParam(@Param(“id”) Integer id);</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;parameterTypeOneParam&quot;</span> parameterType=<span class="hljs-string">&quot;int&quot;</span> resultType=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tbl_coupon <span class="hljs-keyword">where</span> id = <span class="hljs-meta">#&#123;id&#125;</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><p>2.集合类型<br>对于集合类型的话，这里也是要考虑@Param和parameterType 这两个的区别的</p><p>1.只含parameterType<br>只包含parameterType，则当前就是表示只用这个的类型，则在xml中进行循环的时候，要按照类型来识别了</p><p>SOACoupon parameterTypeOne1(List<Integer> ids);<br>如下collection中必须用list才行，因为这里已经是按照类型来进行识别了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne1&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id in<br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>#&#123;item&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>limit 1<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.只含@Param<br>则表示当前是要用名字来进行识别，则就没有必要写parameterType了，也就是两者都存在的时候，其中一个parameterType是会失效的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">SOACoupon parameterTypeOne1(@Param(&quot;idList&quot;) List<span class="hljs-tag">&lt;<span class="hljs-name">Integer</span>&gt;</span> ids);<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne1&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id in<br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;idList&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>#&#123;item&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>limit 1<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.都不包含<br>则上报错误，主要是由于collection中是要写名字，因此必须至少有个名字或者类型才行</p><p>4.都包含<br>都包含，则采用名字进行匹配，类型的话是有问题的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">SOACoupon parameterTypeOne1(@Param(&quot;ids&quot;) List<span class="hljs-tag">&lt;<span class="hljs-name">Integer</span>&gt;</span> ids);<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne1&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id in<br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>#&#123;item&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>limit 1<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.Map类型<br>1.只含parameterType<br>这种其实就是按照类型匹配，这个时候，对应的占位符采用的是只有key</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">SOACoupon parameterTypeOne2(Map&lt;String, Object&gt; parasms);<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne2&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id=#&#123;key&#125; and status=#&#123;status&#125; limit 1;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.只含@Param<br>如果是注解，则是按照名字匹配，那么怎么匹配呢，这样就是需要xml中这么写了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">SOACoupon parameterTypeOne2(@Param(&quot;map&quot;) Map&lt;String, Object&gt; parasms);<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne2&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id=#&#123;map.key&#125; and status=#&#123;map.status&#125; limit 1;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.都不包含<br>对于这种都不包含的，则上报异常</p><pre><code class="hljs">&lt;select id=&quot;parameterTypeOne2&quot; resultType=&quot;org.mallcai.common.model.SOACoupon&quot;&gt;    select * from tbl_coupon where id=#&#123;key&#125; and status=#&#123;status&#125; limit 1;&lt;/select&gt;</code></pre><p>4.都包含</p><p>都包含，则按照名字进行匹配，也就是说，一旦出现名字，则就只能按照名字进行匹配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">SOACoupon parameterTypeOne2(@Param(&quot;maps&quot;) Map&lt;String, Object&gt; parasms);<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne2&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id=#&#123;maps.key&#125; and status=#&#123;maps.status&#125; limit 1;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4.实体类型<br>1.只含parameterType<br>只包含parameterType，则跟上面map是一样的，就是按照key进行匹配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">SOACoupon parameterTypeOne3(SOACoupon coupon);<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne3&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;SOACoupon&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.只含@Param<br>只包含@Param，则跟上面的map是一样的，也是要通过名字进行访问才行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">SOACoupon parameterTypeOne3(@Param(&quot;coup&quot;)SOACoupon coupon);<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne3&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id=#&#123;coup.id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.都不包含<br>都不包含，则采用类型进行识别</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">SOACoupon parameterTypeOne3(SOACoupon coupon);<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne3&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id=#&#123;coup.id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4.都包含<br>都包含，则默认按照名字进行匹配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">SOACoupon parameterTypeOne3(@Param(&quot;coup&quot;) SOACoupon coupon);<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeOne3&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;SOACoupon&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id=#&#123;coup.id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>二、多个参数<br>对于多参数的，则就无法直接通过参数类型来识别了，而是必须要通过@Param来进行识别<br>SOACoupon parameterTypeMulti1(@Param(“id”)Integer id, @Param(“couponName”)String couponName);</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parameterTypeMulti1&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.mallcai.common.model.SOACoupon&quot;</span>&gt;</span><br>select * from tbl_coupon where id=#&#123;id&#125; and coupon_name = #&#123;couponName&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;select id=&quot;parameterTypeMulti1&quot; resultType=&quot;org.mallcai.common.model.SOACoupon&quot;&gt;    select * from tbl_coupon where id=#&#123;id&#125; and coupon_name = #&#123;couponName&#125;&lt;/select&gt;</code></pre><p>总结 ： 有@Param(“别名”)那么就是按照名称匹配<br>占位符内写名称<br>没有@Param 就按照类型匹配</p>]]></content>
    
    
    <categories>
      
      <category>/学习/后端开发笔记/个人笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/09/03/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/09/03/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>先序：头、左、右<br>中序：左、头、右<br>后序：左、右、头</p><h2 id="递归方式实现二叉树的前、中、后序遍历"><a href="#递归方式实现二叉树的前、中、后序遍历" class="headerlink" title="递归方式实现二叉树的前、中、后序遍历"></a>递归方式实现二叉树的前、中、后序遍历</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">package</span> class10;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code02_RecursiveTraversalBT</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node left;<br><span class="hljs-keyword">public</span> Node right;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br>value = v;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//模板</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-comment">//完成了最小的任务</span><br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 1</span><br>f(head.left);<br><span class="hljs-comment">// 2</span><br>f(head.right);<br><span class="hljs-comment">// 3</span><br>&#125;<br><br><span class="hljs-comment">// 先序打印所有节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pre</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-comment">//完成了最小的任务</span><br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>System.out.println(head.value);<br>pre(head.left);<br>pre(head.right);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>in(head.left);<br>System.out.println(head.value);<br>in(head.right);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pos</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>pos(head.left);<br>pos(head.right);<br>System.out.println(head.value);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>);<br>head.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>head.left.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">4</span>);<br>head.left.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br>head.right.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">6</span>);<br>head.right.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">7</span>);<br><br>pre(head);<br>System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>in(head);<br>System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>pos(head);<br>System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">递归就是做任务嘛，这里我想引用一下《算法 第4版》中对递归的说明<br>“编写递归代码时最重要的有以下三点<br>  1.递归总有一个最简单的情况——方法的第一条语句总是包含return的条件语句<br>  2.递归调用总是去尝试解决一个规模更小的问题，这样递归才能收敛到最简单的情况。<br>  3.递归调用的父问题和尝试解决的子问题之间不应该有交集。”<br></code></pre></td></tr></table></figure><h2 id="非递归实现二叉树前、中、后序遍历"><a href="#非递归实现二叉树前、中、后序遍历" class="headerlink" title="非递归实现二叉树前、中、后序遍历"></a>非递归实现二叉树前、中、后序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> class10;<br><br><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code03_UnRecursiveTraversalBT</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node left;<br><span class="hljs-keyword">public</span> Node right;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br>value = v;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pre</span><span class="hljs-params">(Node head)</span> &#123;<br><br>System.out.print(<span class="hljs-string">&quot;pre-order: &quot;</span>);<br><span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>stack.add(head);<br><span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>head = stack.pop();<br>System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>stack.push(head.right);<br>&#125;<br><span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>stack.push(head.left);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in</span><span class="hljs-params">(Node cur)</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;in-order: &quot;</span>);<br><span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br><span class="hljs-keyword">while</span> (!stack.isEmpty() || cur != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>stack.push(cur);<br>cur = cur.left;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cur = stack.pop();<br>System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);<br>cur = cur.right;·<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pos1</span><span class="hljs-params">(Node head)</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);<br><span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>s1.push(head);<br><span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;<br>head = s1.pop(); <span class="hljs-comment">// 头 右 左</span><br>s2.push(head);<br><span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>s1.push(head.left);<br>&#125;<br><span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>s1.push(head.right);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 左 右 头</span><br><span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;<br>System.out.print(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125;<br>System.out.println();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pos2</span><span class="hljs-params">(Node h)</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);<br><span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span>) &#123;<br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>stack.push(h);<br><span class="hljs-type">Node</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>c = stack.peek();<br><span class="hljs-keyword">if</span> (c.left != <span class="hljs-literal">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;<br>stack.push(c.left);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-literal">null</span> &amp;&amp; h != c.right) &#123;<br>stack.push(c.right);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.print(stack.pop().value + <span class="hljs-string">&quot; &quot;</span>);<br>h = c;<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>);<br>head.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>head.left.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">4</span>);<br>head.left.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br>head.right.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">6</span>);<br>head.right.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">7</span>);<br><br>pre(head);<br>System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>in(head);<br>System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>pos1(head);<br>System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>pos2(head);<br>System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">感觉用栈来实现就是自定义任务<br>1.先序就是 先完成头节点的任务，再看有没有右孩子的任务右就压入栈中，再看左孩子。这样就能保证先完成的是左孩子的任务再完成右孩子的任务。因为二叉树的特殊性，所以头的任务必定是最先完成的，最终就是头左右的顺序<br><br>2.中序遍历比较难以理解，就是用cur来模拟整个遍历过程<br><br>3.后序遍历就就是在先序遍历的基础上做一些改动<br>准备两个栈，第一个栈实现头右左的顺序，每次遍历到第一个栈中的元素就压入第二个栈中去，就可以实现左右头的顺序。<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>/学习/算法/算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2022/08/30/%E5%9B%BE/"/>
    <url>/2022/08/30/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="点结构的描述"><a href="#点结构的描述" class="headerlink" title="点结构的描述"></a>点结构的描述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value; <span class="hljs-comment">//点的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> in;  <span class="hljs-comment">//入度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> out;      <span class="hljs-comment">//出度</span><br><span class="hljs-keyword">public</span> ArrayList&lt;Node&gt; nexts; <span class="hljs-comment">//邻居点</span><br><span class="hljs-keyword">public</span> ArrayList&lt;Edge&gt; edges;<span class="hljs-comment">//邻接边</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-built_in">this</span>.value = value;<br>in = <span class="hljs-number">0</span>;<br>out = <span class="hljs-number">0</span>;<br>nexts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="边结构的描述"><a href="#边结构的描述" class="headerlink" title="边结构的描述"></a>边结构的描述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> weight; <span class="hljs-comment">//边的权重</span><br><span class="hljs-keyword">public</span> Node from;<span class="hljs-comment">//来自的点</span><br><span class="hljs-keyword">public</span> Node to;   <span class="hljs-comment">//去向的点</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Edge</span><span class="hljs-params">(<span class="hljs-type">int</span> weight, Node from, Node to)</span> &#123;<br><span class="hljs-built_in">this</span>.weight = weight; <br><span class="hljs-built_in">this</span>.from = from;<br><span class="hljs-built_in">this</span>.to = to;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图结构的描述"><a href="#图结构的描述" class="headerlink" title="图结构的描述"></a>图结构的描述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;<br><span class="hljs-keyword">public</span> HashSet&lt;Edge&gt; edges;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">()</span> &#123;<br>nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构造图结构"><a href="#构造图结构" class="headerlink" title="构造图结构"></a>构造图结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphGenerator</span> &#123;<br><span class="hljs-comment">// matrix 所有的边</span><br><span class="hljs-comment">// N*3 的矩阵</span><br><span class="hljs-comment">// [weight, from节点上面的值，to节点上面的值]</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// [ 5 , 0 , 7]</span><br><span class="hljs-comment">// [ 3 , 0,  1]</span><br><span class="hljs-comment">// </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Graph <span class="hljs-title function_">createGraph</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br><span class="hljs-type">Graph</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;<br> <span class="hljs-comment">// 拿到每一条边， matrix[i] </span><br><span class="hljs-type">int</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> matrix[i][<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> matrix[i][<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> matrix[i][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">if</span> (!graph.nodes.containsKey(from)) &#123;<br>graph.nodes.put(from, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(from));<br>&#125;<br><span class="hljs-keyword">if</span> (!graph.nodes.containsKey(to)) &#123;<br>graph.nodes.put(to, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(to));<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">fromNode</span> <span class="hljs-operator">=</span> graph.nodes.get(from);<br><span class="hljs-type">Node</span> <span class="hljs-variable">toNode</span> <span class="hljs-operator">=</span> graph.nodes.get(to);<br><span class="hljs-type">Edge</span> <span class="hljs-variable">newEdge</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>(weight, fromNode, toNode);<br>fromNode.nexts.add(toNode);<br>fromNode.out++;<br>toNode.in++;<br>fromNode.edges.add(newEdge);<br>graph.edges.add(newEdge);<br>&#125;<br><span class="hljs-keyword">return</span> graph;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的宽度优先遍历"><a href="#图的宽度优先遍历" class="headerlink" title="图的宽度优先遍历"></a>图的宽度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code01_BFS</span> &#123;<br><br><span class="hljs-comment">// 从node出发，进行宽度优先遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(Node start)</span> &#123;<br><span class="hljs-comment">//边界条件 是否全部没有</span><br><span class="hljs-keyword">if</span> (start == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//利用队列 + Set（作为注册中心）实现宽度优先遍历</span><br>Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-comment">//初始化队列和注册中心</span><br>queue.add(start);<br>set.add(start);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-comment">//弹出队头元素</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br><span class="hljs-comment">//每次弹出的时候对该节点执行操作，这里就用打印来代替</span><br>System.out.println(cur.value);<br><span class="hljs-comment">//弹出之后遍历该节点的所有邻居节点，如果已经注册过，就不加入到队列中，否则先注册在加入到队列中</span><br><span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;<br><span class="hljs-keyword">if</span> (!set.contains(next)) &#123;<br>set.add(next);<br>queue.add(next);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的深度优先搜索"><a href="#图的深度优先搜索" class="headerlink" title="图的深度优先搜索"></a>图的深度优先搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code02_DFS</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node node)</span> &#123;<br>   <span class="hljs-comment">//边界条件</span><br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//利用栈和set(作为注册中心)来实现</span><br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-comment">//初始化栈和注册中心</span><br>stack.add(node);<br>set.add(node);<br>System.out.println(node.value);<br><span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br><span class="hljs-comment">//每次弹出栈顶元素</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br><span class="hljs-comment">//遍历每个邻居节点</span><br><span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;<br><span class="hljs-comment">//如果没有注册，就要把这条路径走完</span><br><span class="hljs-keyword">if</span> (!set.contains(next)) &#123;<br><span class="hljs-comment">//将已经弹出的再压回去</span><br>stack.push(cur);<br><span class="hljs-comment">//压入未注册的邻居节点</span><br>stack.push(next);<br><span class="hljs-comment">//将邻居节点注册</span><br>set.add(next);<br><span class="hljs-comment">//对压入节点进行操作</span><br>System.out.println(next.value);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">对于宽度优先遍历，因为每个元素一定只有一次弹出的机会，所以就在弹出的时候对他进行操作<br>对于深度优先搜索，因为每个元素一定只有一次主动压入的机会，所以就在压入的时候对他进行操作<br>栈中的元素就是当前的路径<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>/学习/算法/算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未归档题目</title>
    <link href="/2022/08/25/%E6%9C%AA%E5%BD%92%E6%A1%A3/"/>
    <url>/2022/08/25/%E6%9C%AA%E5%BD%92%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>主站004</p><hr><p><strong>题目描述</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。<br><br>算法的时间复杂度应该为 <span class="hljs-constructor">O(<span class="hljs-params">log</span> (<span class="hljs-params">m</span>+<span class="hljs-params">n</span>)</span>) 。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public double find<span class="hljs-constructor">MedianSortedArrays(<span class="hljs-params">int</span>[] <span class="hljs-params">nums1</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">nums2</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> length1 = nums1.length, length2 = nums2.length;<br>        <span class="hljs-built_in">int</span> totalLength = length1 + length2;<br>        <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span><span class="hljs-operator"> == </span><span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">int</span> midIndex = totalLength<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>            double median = get<span class="hljs-constructor">KthElement(<span class="hljs-params">nums1</span>, <span class="hljs-params">nums2</span>, <span class="hljs-params">midIndex</span> + 1)</span>;<br>            return median;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">int</span> midIndex1 = totalLength<span class="hljs-operator"> / </span><span class="hljs-number">2</span> - <span class="hljs-number">1</span>, midIndex2 = totalLength<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>            double median = (get<span class="hljs-constructor">KthElement(<span class="hljs-params">nums1</span>, <span class="hljs-params">nums2</span>, <span class="hljs-params">midIndex1</span> + 1)</span> + get<span class="hljs-constructor">KthElement(<span class="hljs-params">nums1</span>, <span class="hljs-params">nums2</span>, <span class="hljs-params">midIndex2</span> + 1)</span>)<span class="hljs-operator"> / </span><span class="hljs-number">2.0</span>;<br>            return median;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//找到两个数组第k小的数模板（二分）</span><br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">KthElement(<span class="hljs-params">int</span>[] <span class="hljs-params">nums1</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">nums2</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span><br><span class="hljs-comment">         * 这里的 &quot;/&quot; 表示整除</span><br><span class="hljs-comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span><br><span class="hljs-comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span><br><span class="hljs-comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span><br><span class="hljs-comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span><br><span class="hljs-comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-built_in">int</span> length1 = nums1.length, length2 = nums2.length;<br>        <span class="hljs-comment">//index1和index2的记录左右指针的起始位置</span><br>        <span class="hljs-built_in">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//kthElement记录所求的值</span><br>        <span class="hljs-built_in">int</span> kthElement = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 边界情况</span><br>            <span class="hljs-comment">//1.某一个数组用完了，也就是对应下面那个Math.min中length1/length2项</span><br>            <span class="hljs-comment">//那么就直接从另一个数组中取数字就行</span><br>            <span class="hljs-keyword">if</span> (index1<span class="hljs-operator"> == </span>length1) &#123;<br>                return nums2<span class="hljs-literal">[<span class="hljs-identifier">index2</span> + <span class="hljs-identifier">k</span> - <span class="hljs-number">1</span>]</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (index2<span class="hljs-operator"> == </span>length2) &#123;<br>                return nums1<span class="hljs-literal">[<span class="hljs-identifier">index1</span> + <span class="hljs-identifier">k</span> - <span class="hljs-number">1</span>]</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果只取一个数，那么就直接比较最前面两个数就行</span><br>            <span class="hljs-keyword">if</span> (k<span class="hljs-operator"> == </span><span class="hljs-number">1</span>) &#123;<br>                return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(nums1<span class="hljs-literal">[<span class="hljs-identifier">index1</span>]</span>, nums2<span class="hljs-literal">[<span class="hljs-identifier">index2</span>]</span>);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 正常情况</span><br>            <span class="hljs-built_in">int</span> half = k<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">int</span> newIndex1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(index1 + half, length1) - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> newIndex2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(index2 + half, length2) - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> pivot1 = nums1<span class="hljs-literal">[<span class="hljs-identifier">newIndex1</span>]</span>, pivot2 = nums2<span class="hljs-literal">[<span class="hljs-identifier">newIndex2</span>]</span>;<br>            <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2) &#123;<br>                k -= (newIndex1 - index1 + <span class="hljs-number">1</span>);<br>                index1 = newIndex1 + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k -= (newIndex2 - index2 + <span class="hljs-number">1</span>);<br>                index2 = newIndex2 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">本题可谓是二分法的高级操作<br>其实看到<span class="hljs-built_in">log</span>就应想到二分<br>两个数组找到第k小的数字可以看作是归并排序的拓展，可以作为模板记住<br></code></pre></td></tr></table></figure><hr><p>主站092</p><hr><p><strong>题目描述</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">给你单链表的头指针 head 和两个整数 <span class="hljs-built_in">left</span> 和 <span class="hljs-built_in">right</span> ，其中 <span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span> 。请你反转从位置 <span class="hljs-built_in">left</span> 到位置 <span class="hljs-built_in">right</span> 的链表节点，返回 反转后的链表 。<br><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode reverseBetween(ListNode head, int left, int right) &#123;<br>        boolean flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//边界条件</span><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span> || left == right )&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span>)&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//先找到left前面的节点和right后面的节点</span><br>        ListNode preLeft = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        <span class="hljs-keyword">while</span>(left &gt; <span class="hljs-number">1</span>)&#123;<br>            preLeft = preLeft.next;<br>            left--;<br>        &#125;<br>        ListNode aftRight = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        <span class="hljs-keyword">while</span>(right &gt; <span class="hljs-number">0</span>)&#123;<br>            aftRight = aftRight.next;<br>            right--;<br>        &#125;<br>        <br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Left</span> = aftRight.next;<br>        <br>        <span class="hljs-comment">//断开</span><br>        aftRight.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//aftRight为先置前节点</span><br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = preLeft.next;<br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Right</span> = preLeft.next;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Head</span> != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Right</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = <span class="hljs-keyword">new</span><span class="hljs-type">Left</span>;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Left</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Right</span>;<br>        &#125;<br>        preLeft.next = aftRight;  <br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Left</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题是反转链表Ⅰ的升级版，本质差不多，注意边界条件的把握<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>/学习/算法/做题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-08-21围棋复盘</title>
    <link href="/2022/08/25/%E5%9B%B4%E6%A3%8B%E5%A4%8D%E7%9B%98/"/>
    <url>/2022/08/25/%E5%9B%B4%E6%A3%8B%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1）陶晨-黑-vs山东徐浚恒-白"><a href="#1）陶晨-黑-vs山东徐浚恒-白" class="headerlink" title="1）陶晨(黑)vs山东徐浚恒(白)"></a>1）陶晨(黑)vs山东徐浚恒(白)</h2><p>对局总览<br><img src="/img/go/%E6%A1%83%E6%BA%90%E5%9B%B4%E6%A3%8B%E8%A7%92%E6%AF%94%E8%B5%9Bvs%E5%BE%90%E6%B5%9A%E6%81%92.gif" alt="对局总览"></p><p><img src="/img/go/%E6%A1%83%E6%BA%90%E5%9B%B4%E6%A3%8B%E8%A7%92%E6%AF%94%E8%B5%9Bvs%E5%BE%90%E6%B5%9A%E6%81%921.png" alt="实战图1"></p><p>行棋至此大致五五开，白下，白棋如何消去上面的黑势成了当前最重要的问题，A位置漏是好手，比较考验黑棋，实战选择了B位置靠三三的下法</p><p><img src="/img/go/%E6%A1%83%E6%BA%90%E5%9B%B4%E6%A3%8B%E8%A7%92%E6%AF%94%E8%B5%9Bvs%E5%BE%90%E6%B5%9A%E6%81%922.png" alt="实战图2"><br>黑棋吃住角 围住了上方实地，白棋左边很难办，拆的近略不满，拆的远（像实战一样）黑棋则可以直接动出，黑优势</p><p><img src="/img/go/%E6%A1%83%E6%BA%90%E5%9B%B4%E6%A3%8B%E8%A7%92%E6%AF%94%E8%B5%9Bvs%E5%BE%90%E6%B5%9A%E6%81%927.png" alt="实战图3"><br>白棋拖是本局的败招，有加厚黑棋之嫌，直接把上方白棋送掉，大亏</p><p><img src="/img/go/%E6%A1%83%E6%BA%90%E5%9B%B4%E6%A3%8B%E8%A7%92%E6%AF%94%E8%B5%9Bvs%E5%BE%90%E6%B5%9A%E6%81%923.png" alt="实战图4"><br>黑区滚一圈心情很愉快，此时白棋应当在B位置拔而不是立，白立黑粘又是先手，白亏。</p><p><img src="/img/go/%E6%A1%83%E6%BA%90%E5%9B%B4%E6%A3%8B%E8%A7%92%E6%AF%94%E8%B5%9Bvs%E5%BE%90%E6%B5%9A%E6%81%924.png" alt="实战图5"><br>白棋打入是比较冒险的一手，个人认为应当在下方A位置逼住黑棋，再找机会</p><p><img src="/img/go/%E6%A1%83%E6%BA%90%E5%9B%B4%E6%A3%8B%E8%A7%92%E6%AF%94%E8%B5%9Bvs%E5%BE%90%E6%B5%9A%E6%81%925.png" alt="实战图6"><br>白棋上方小活一块，但同时也让黑棋成了很多空，白棋打入结果并不好</p><p><img src="/img/go/%E6%A1%83%E6%BA%90%E5%9B%B4%E6%A3%8B%E8%A7%92%E6%AF%94%E8%B5%9Bvs%E5%BE%90%E6%B5%9A%E6%81%926.png" alt="实战图7"><br>收官阶段，白棋此时下出问题手，黑棋靠，白棋B位挡住是本手，不应该在下方夹，实战被黑棋先手破空，白亏损巨大</p>]]></content>
    
    
    <categories>
      
      <category>/娱乐/围棋</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快乐围棋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offerⅡ</title>
    <link href="/2022/08/25/%E5%89%91%E6%8C%87offer%E2%85%A1/"/>
    <url>/2022/08/25/%E5%89%91%E6%8C%87offer%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p>剑指offerⅡ05</p><p><strong>题目描述</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">给定一个字符串数组 <span class="hljs-built_in">words</span>，请计算当两个字符串 <span class="hljs-built_in">words</span>[i] 和 <span class="hljs-built_in">words</span>[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;abcw&quot;</span>,<span class="hljs-string">&quot;baz&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;fxyz&quot;</span>,<span class="hljs-string">&quot;abcdef&quot;</span>]<br>输出: <span class="hljs-number">16</span> <br>解释: 这两个单词为 <span class="hljs-string">&quot;abcw&quot;</span>, <span class="hljs-string">&quot;fxyz&quot;</span>。它们不包含相同字符，且长度的乘积最大。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> maxProduct(String[] words) &#123;<br>        //利用位掩码 <br>        // 如果有相同的字母与完返回就不是<span class="hljs-number">0</span><br>        <span class="hljs-type">int</span> wordsLen = words.length;<br>        <span class="hljs-type">int</span>[] mask = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[wordsLen];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; wordsLen; i++)&#123;<br>            <span class="hljs-type">int</span> letterLen = words[i].length();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; letterLen ; j++)&#123;<br>                <span class="hljs-type">int</span> loc = words[i].charAt(j) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span> &lt;&lt; loc) &amp; mask[i]) == <span class="hljs-number">0</span>)&#123;<br>                    mask[i] += (<span class="hljs-number">1</span> &lt;&lt; loc);<br>                &#125;<br>            &#125;    <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; wordsLen ; i++)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(mask[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> maxProd = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; wordsLen ; i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ;j &lt; wordsLen ;j++)&#123;<br>               <span class="hljs-keyword">if</span>((mask[i] &amp; mask[j]) == <span class="hljs-number">0</span>)&#123;<br>                   maxProd = words[i].length() * words[j].length() &gt; maxProd ? words[i].length() * words[j].length() : maxProd;<br>                &#125;<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProd;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题主要就是考察判断两个字符串中是否有相同字母<br>利用与运算快速实现<br></code></pre></td></tr></table></figure><hr><p>剑指offerⅡ06</p><p><strong>题目描述</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。<br><br>函数应该以长度为 <span class="hljs-number">2</span> 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 <span class="hljs-number">0</span> 开始计数 ，所以答案数组应当满足 <span class="hljs-number">0</span> &lt;= answer<span class="hljs-selector-attr">[0]</span> &lt; answer<span class="hljs-selector-attr">[1]</span> &lt; numbers<span class="hljs-selector-class">.length</span> 。<br><br>假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。<br>输入：numbers = <span class="hljs-selector-attr">[1,2,4,6,10]</span>, target = <span class="hljs-number">8</span><br>输出：<span class="hljs-selector-attr">[1,3]</span><br>解释：<span class="hljs-number">2</span> 与 <span class="hljs-number">6</span> 之和等于目标数 <span class="hljs-number">8</span> 。因此 index1 = <span class="hljs-number">1</span>, index2 = <span class="hljs-number">3</span> 。<br><br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：numbers = [1,2,4,6,10], target = 8<br>输出：[1,3]<br>解释：2 与<span class="hljs-number"> 6 </span>之和等于目标数<span class="hljs-number"> 8 </span>。因此 index1 = 1, index2 =<span class="hljs-number"> 3 </span>。<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length; ++i) &#123;<br>            <span class="hljs-keyword">int</span> low = i + <span class="hljs-number">1</span>, high = numbers.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//这里只需要找一个，所以小于等于</span><br>            <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>                <span class="hljs-keyword">int</span> mid = (high - low) / <span class="hljs-number">2</span> + low;<br>                <span class="hljs-keyword">if</span> (numbers[mid] == <span class="hljs-keyword">target</span> - numbers[i]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, mid&#125;;<br>                &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(numbers[mid] &gt; <span class="hljs-keyword">target</span> - numbers[i])</span> </span>&#123;<br>                    high = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    low = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用二分查找，注意边界条件的控制<br></code></pre></td></tr></table></figure><p>剑指offerⅡ07</p><hr><p><strong>题目描述</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 <span class="hljs-selector-tag">a</span> ，<span class="hljs-selector-tag">b</span> ，c ，使得 <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> + c = <span class="hljs-number">0</span> ？请找出所有和为 <span class="hljs-number">0</span> 且 不重复 的三元组。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,0,1,2,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>]<br>输出：[[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,2],[<span class="hljs-string">-1</span>,0,1]]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// 不能重复使用</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 排序--升序 -- 归并排序</span><br><span class="hljs-comment">        2. 固定一个值 -- for 0 ~ lens-3</span><br><span class="hljs-comment">        3. 剩下2个值在右区间进行双指针 -- 参考前题</span><br><span class="hljs-comment">        4. 考虑重复组合的问题 -- 去重，有两种重复情况</span><br><span class="hljs-comment">            1. 第一个固定的值存在重复</span><br><span class="hljs-comment">            2. 第二第三个值的组合存在重复</span><br><span class="hljs-comment">         */</span><br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 排序</span><br>        Arrays.sort(nums);<br><br>        <span class="hljs-comment">// 遍历固定第一个值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length<span class="hljs-number">-2</span>; i++) &#123;<br>            <span class="hljs-comment">// 解决第一个固定值重复的问题</span><br>            <span class="hljs-comment">// 例如排序后的[-4,-1,-1,0,1,2] -1,-1处存在首数字重复</span><br>            <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> curTarget = -nums[i];<br>            <span class="hljs-built_in">int</span> left = i+<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> right = nums.length<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span> (right&gt;left) &#123;<br>                <span class="hljs-built_in">int</span> tmpSum = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (tmpSum &gt; curTarget)<br>                    right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmpSum &lt; curTarget)<br>                    left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                    list.<span class="hljs-keyword">add</span>(nums[i]);<br>                    list.<span class="hljs-keyword">add</span>(nums[left]);<br>                    list.<span class="hljs-keyword">add</span>(nums[right]);<br>                    res.<span class="hljs-keyword">add</span>(list);<br><br>                    <span class="hljs-comment">// 解决第二第三个固定值重复的问题</span><br>                    <span class="hljs-comment">// 例如排序后的[-2,0,0,2,2] -2固定下，0，0，2，2会重复组合出0,2</span><br>                    <span class="hljs-comment">// 短路运算，第一个条件保证大前提，第二个语句运用前置++运算符更新指针</span><br>                    <span class="hljs-keyword">while</span> (left&lt;right &amp;&amp; nums[left]==nums[++left]);<br>                    <span class="hljs-keyword">while</span> (left&lt;right &amp;&amp; nums[right]==nums[--right]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这道题是三元和 还是利用固定法，另外两个的和我们要保证遍历不重不漏，所以利用前后双指针遍历<br></code></pre></td></tr></table></figure><p>剑指offerⅡ08</p><hr><p><strong>题目描述</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">给定一个含有 n 个正整数的数组和一个正整数 <span class="hljs-keyword">target</span> 。<br><br>找出该数组中满足其和 ≥ <span class="hljs-keyword">target</span> 的长度最小的 连续子数组 [numsl, numsl+<span class="hljs-number">1</span>, ..., numsr<span class="hljs-number">-1</span>, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 <span class="hljs-number">0</span> 。<br><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> minSubArrayLen(<span class="hljs-built_in">int</span> s, <span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-keyword">Integer</span>.MAX_VALUE;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>, <span class="hljs-keyword">end</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">end</span> &lt; n) &#123;<br>            // 每次右指针先往右移动一位<br>            // 然后让左指针向右移动直到不符合题意为止<br>            <span class="hljs-built_in">sum</span> += nums[<span class="hljs-keyword">end</span>];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">sum</span> &gt;= s) &#123;<br>                ans = Math.<span class="hljs-built_in">min</span>(ans, <span class="hljs-keyword">end</span> - start + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">sum</span> -= nums[start];<br>                start++;<br>            &#125;<br>            <span class="hljs-keyword">end</span>++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == <span class="hljs-keyword">Integer</span>.MAX_VALUE ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用滑动窗口的思路，先向右移动右指针直到满足条件，然后向右移动左指针，直到满足条件，然后继续移动右指针，依此循环<br>“右定左动”<br></code></pre></td></tr></table></figure><p>剑指offerⅡ09</p><hr><p><strong>题目描述</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[10,5,2,6]</span>, k = 100<br>输出: 8<br>解释: 8 个乘积小于 100 的子数组分别为: <span class="hljs-comment">[10]</span>, <span class="hljs-comment">[5]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[6]</span>, <span class="hljs-comment">[10,5]</span>, <span class="hljs-comment">[5,2]</span>, <span class="hljs-comment">[2,6]</span>, <span class="hljs-comment">[5,2,6]</span>。<br>需要注意的是 <span class="hljs-comment">[10,5,2]</span> 并不是乘积小于100的子数组。<br><br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>    public <span class="hljs-type">int</span> numSubarrayProductLessThanK(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> n = nums.length, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">prod</span> = <span class="hljs-number">1</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-built_in">prod</span> *= nums[j];<br>            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; <span class="hljs-built_in">prod</span> &gt;= k) &#123;<br>                <span class="hljs-built_in">prod</span> /= nums[i];<br>                i++;<br>            &#125;<br>            ret += j - i + <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用滑动窗口的思路，先向右移动右指针直到满足条件，然后向右移动左指针，直到满足条件，然后继续移动右指针，依此循环<br>“右定左动”<br></code></pre></td></tr></table></figure><p>剑指offerⅡ10</p><hr><p><strong>题目描述</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入:nums = <span class="hljs-comment">[1,1,1]</span>, k = 2<br>输出: 2<br>解释: 此题 <span class="hljs-comment">[1,1]</span> 与 <span class="hljs-comment">[1,1]</span> 为两种不同的情况<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> subarraySum(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer,Integer&gt; mp = <span class="hljs-keyword">new</span> HashMap &lt; &gt; ();<br>        mp.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//pre记录前缀和的值</span><br>            pre += nums[i];<br>            <span class="hljs-comment">//每次查看前面有没有满足条件的pre[j]</span><br>            <span class="hljs-keyword">if</span> (mp.containsKey(pre - k)) &#123;<br>                <span class="hljs-keyword">count</span> += mp.get(pre - k);<br>            &#125;<br>            mp.put(pre, mp.getOrDefault(pre, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用了前缀和 + 哈希表的经典搭配 就是以和为键，以次数为值，构造哈希表<br><br></code></pre></td></tr></table></figure><p>剑指offerⅡ11</p><hr><p><strong>题目描述</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个二进制数组 nums , 找到含有相同数量的<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 1 </span>的最长连续子数组，并返回该子数组的长度。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [0,1]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> findMaxLength(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        HashMap&lt;<span class="hljs-type">Integer</span>,<span class="hljs-type">Integer</span>&gt; hp = <span class="hljs-built_in">new</span> HashMap&lt;<span class="hljs-type">Integer</span>,<span class="hljs-type">Integer</span>&gt;();<br>        hp.put(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i&lt; nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> num = nums[i];<br>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br>                res++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> res<span class="hljs-comment">--;</span><br>            <span class="hljs-keyword">if</span>(hp.containsKey(res))&#123;<br>                <span class="hljs-type">int</span> newLen = i - hp.<span class="hljs-keyword">get</span>(res);<br>                maxLen = Math.max(maxLen,newLen);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                hp.put(res,i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用了前缀和 + 哈希表的经典搭配 以值为键，以下标为值<br><br></code></pre></td></tr></table></figure><p>剑指offerⅡ12</p><hr><p><strong>题目描述</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给你一个整数数组 nums ，请计算数组的 中心下标 。<br><br>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。<br><br>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。<br><br>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 <span class="hljs-string">-1</span> 。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,7,3,6,5,6]<br>输出：3<br>解释：<br>中心下标是<span class="hljs-number"> 3 </span>。<br>左侧数之和 sum = nums[0] + nums[1] + nums[2] =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 11 </span>，<br>右侧数之和 sum = nums[4] + nums[5] =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 11 </span>，二者相等。<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> pivotIndex(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> length = nums.length;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span> ;i&lt; length ;i++)&#123;<br>            <span class="hljs-keyword">sum</span> += nums[i];<br>        &#125;<br>        <span class="hljs-built_in">int</span> leftSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span> == nums[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span> ;i&lt; length<span class="hljs-number">-1</span> ;i++)&#123;<br>            leftSum += nums[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span> * leftSum + nums[i] == <span class="hljs-keyword">sum</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span> == nums[length<span class="hljs-number">-1</span>]) <span class="hljs-keyword">return</span> length<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题比较简单，直接前缀和遍历<br></code></pre></td></tr></table></figure><p>剑指offerⅡ14</p><hr><p><strong>题目描述</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">给定两个字符串 <span class="hljs-built_in">s1</span> 和 <span class="hljs-built_in">s2</span>，写一个函数来判断 <span class="hljs-built_in">s2</span> 是否包含 <span class="hljs-built_in">s1</span> 的某个变位词。<br><br>换句话说，第一个字符串的排列之一是第二个字符串的 子串 。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入: <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;ab&quot;</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;eidbaooo&quot;</span><br>输出: True<br>解释: <span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">&quot;ba&quot;</span>).<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(<span class="hljs-type">String</span> s1, <span class="hljs-type">String</span> s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">length</span>(), m = s2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (n &gt; m) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 比较两个字符串映射数组</span><br>        <span class="hljs-comment">// 利用Arrays.equals比较</span><br>        <span class="hljs-type">int</span>[] cnt1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] cnt2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">// 先比较前n个是否相等</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ++cnt1[s1.<span class="hljs-built_in">charAt</span>(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            ++cnt2[s2.<span class="hljs-built_in">charAt</span>(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Arrays.<span class="hljs-built_in">equals</span>(cnt1, cnt2)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从n+1开始进1出1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &lt; m; ++i) &#123;<br>            ++cnt2[s2.<span class="hljs-built_in">charAt</span>(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --cnt2[s2.<span class="hljs-built_in">charAt</span>(i - n) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (Arrays.<span class="hljs-built_in">equals</span>(cnt1, cnt2)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">本题利用维护滑动窗口，保证窗口长度固定为<span class="hljs-built_in">s1</span>的长度<br></code></pre></td></tr></table></figure><p>剑指offerⅡ15</p><hr><p><strong>题目描述</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个字符串 s 和 <span class="hljs-selector-tag">p</span>，找到 s 中所有 <span class="hljs-selector-tag">p</span> 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br><br>变位词 指字母相同，但排列不同的字符串。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的变位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的变位词。<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; findAnagrams(String s, String p) &#123;<br>        List&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> length1 = s.length();<br>        <span class="hljs-type">int</span> length2 = p.length();<br>        <span class="hljs-keyword">if</span>(length1 &lt; length2) <span class="hljs-keyword">return</span> list;<br>        <span class="hljs-type">int</span>[] mask1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] mask2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; length2 ;i++)&#123;<br>            mask1[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++ ;<br>            mask2[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++ ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(mask1,mask2))&#123;<br>            list.<span class="hljs-keyword">add</span>(<span class="hljs-number">0</span>);   <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = length2;i &lt; length1 ;i++)&#123;<br>            mask1[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++ ;<br>            mask1[s.charAt(i - length2) - <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">--;</span><br>            <span class="hljs-keyword">if</span>(Arrays.equals(mask1,mask2))&#123;<br>                list.<span class="hljs-keyword">add</span>(i-length2+<span class="hljs-number">1</span>);   <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">本题和上题一致，利用维护滑动窗口，保证窗口长度固定为<span class="hljs-selector-tag">p</span>的长度，然后进一出一来遍历<br></code></pre></td></tr></table></figure><p>剑指offerⅡ16</p><hr><p><strong>题目描述</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子字符串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLongestSubstring(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-comment">// 哈希集合，记录每个字符是否出现过</span><br>        Set&lt;Character&gt; occ = <span class="hljs-keyword">new</span> HashSet&lt;Character&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> n = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br>        <span class="hljs-built_in">int</span> rk = -<span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;                                                                           <br>                <span class="hljs-comment">// 左指针向右移动一格，移除一个字符</span><br>                occ.remove(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span> - 1)</span>);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (rk + <span class="hljs-number">1</span> &lt; n<span class="hljs-operator"> &amp;&amp; </span>!occ.contains(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">rk</span> + 1)</span>)) &#123;<br>                <span class="hljs-comment">// 不断地移动右指针</span><br>                occ.add(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">rk</span> + 1)</span>);<br>                ++rk;<br>            &#125;<br>            <span class="hljs-comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span><br>            ans = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(ans, rk - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题运用滑动窗口，左定右动<br></code></pre></td></tr></table></figure><p>剑指offerⅡ17</p><hr><p><strong>题目描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定两个字符串 s 和 <span class="hljs-built_in">t</span> 。返回 s 中包含 <span class="hljs-built_in">t</span> 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 <span class="hljs-string">&quot;&quot;</span> 。<br><br>如果 s 中存在多个符合条件的子字符串，返回任意一个。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span> <br>解释：最短子字符串 <span class="hljs-string">&quot;BANC&quot;</span> 包含了字符串 t 的所有字符 &#x27;A&#x27;、&#x27;B&#x27;、&#x27;C&#x27;<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    Map&lt;Character, Integer&gt; ori = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;<span class="hljs-literal">()</span>;<br>    Map&lt;Character, Integer&gt; cnt = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;<span class="hljs-literal">()</span>;<br><br>    public String min<span class="hljs-constructor">Window(String <span class="hljs-params">s</span>, String <span class="hljs-params">t</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> tLen = t.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; tLen; i++) &#123;<br>            <span class="hljs-built_in">char</span> c = t.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>;<br>            ori.put(c, ori.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">c</span>, 0)</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> len = Integer.MAX_VALUE, ansL = -<span class="hljs-number">1</span>, ansR = -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> sLen = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; sLen) &#123;<br>            ++r;<br>            <span class="hljs-keyword">if</span> (r &lt; sLen<span class="hljs-operator"> &amp;&amp; </span>ori.contains<span class="hljs-constructor">Key(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">r</span>)</span>)) &#123;<br>                cnt.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">r</span>)</span>, cnt.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">r</span>)</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (check<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>l &lt;= r) &#123;<br>                <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; len) &#123;<br>                    len = r - l + <span class="hljs-number">1</span>;<br>                    ansL = l;<br>                    ansR = l + len;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ori.contains<span class="hljs-constructor">Key(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">l</span>)</span>)) &#123;<br>                    cnt.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">l</span>)</span>, cnt.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">l</span>)</span>, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                &#125;<br>                ++l;<br>            &#125;<br>        &#125;<br>        return ansL<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.substring(ansL, ansR);<br>    &#125;<br><br>    public boolean check<span class="hljs-literal">()</span> &#123;<br>        Iterator iter = ori.entry<span class="hljs-constructor">Set()</span>.iterator<span class="hljs-literal">()</span>; <br>        <span class="hljs-keyword">while</span> (iter.has<span class="hljs-constructor">Next()</span>) &#123; <br>            Map.Entry entry = (Map.Entry) iter.next<span class="hljs-literal">()</span>; <br>            Character key = (Character) entry.get<span class="hljs-constructor">Key()</span>; <br>            Integer <span class="hljs-keyword">val</span> = (Integer) entry.get<span class="hljs-constructor">Value()</span>; <br>            <span class="hljs-keyword">if</span> (cnt.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">key</span>, 0)</span> &lt; <span class="hljs-keyword">val</span>) &#123;<br>                return <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <br>        return <span class="hljs-literal">true</span>; <br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">本题还是经典的滑动窗口，右定左动（一般取最小值是右定左动，最大值是左定右动）<br>本题的右定左动中<span class="hljs-string">&quot;左动&quot;</span>的条件判断条件上比较复杂，需要比较两个<span class="hljs-built_in">map</span>的值<br></code></pre></td></tr></table></figure><p>剑指offerⅡ18</p><hr><p><strong>题目描述</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个字符串 s ，验证 s 是否是 回文串 ，只考虑字母和数字字符，可以忽略字母的大小写。<br><br>本题中，将空字符串定义为有效的 回文串 。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;amanaplanacanalpanama&quot;</span> 是回文串<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public boolean is<span class="hljs-constructor">Palindrome(String <span class="hljs-params">s</span>)</span> &#123;<br>        s = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;<br>        <span class="hljs-built_in">int</span> length = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">begin</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">end</span> = length-<span class="hljs-number">1</span>;<br>    <br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!is<span class="hljs-constructor">Ok(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">begin</span>)</span>)<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>                <span class="hljs-keyword">begin</span>++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!is<span class="hljs-constructor">Ok(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">end</span>)</span>)<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-keyword">begin</span> &lt;<span class="hljs-keyword">end</span>)&#123;<br>                <span class="hljs-keyword">end</span>--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">begin</span>)</span>!=s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">end</span>)</span>)&#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-keyword">begin</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">end</span>);<br>                return <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">begin</span>++;<br>            <span class="hljs-keyword">end</span>--;<br>        &#125;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    public boolean is<span class="hljs-constructor">Ok(<span class="hljs-params">char</span> <span class="hljs-params">c</span>)</span>&#123;<br>        return ((c &gt;= <span class="hljs-character">&#x27;0&#x27;</span><span class="hljs-operator"> &amp;&amp; </span>c &lt;= <span class="hljs-character">&#x27;9&#x27;</span>)<span class="hljs-operator"> || </span>(c &gt;= <span class="hljs-character">&#x27;a&#x27;</span><span class="hljs-operator"> &amp;&amp; </span>c &lt;= <span class="hljs-character">&#x27;z&#x27;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br>本题比较水，对于大小写不敏感的题我们直接用<span class="hljs-built_in">str</span>.toLowerCase将其全部转为小写<br>注意一下边界就行<br></code></pre></td></tr></table></figure><p>剑指offerⅡ19</p><hr><p><strong>题目描述</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个非空字符串 s，请判断如果 最多 从字符串中删除一个字符能否得到一个回文字符串。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aba&quot;</span><br>输出: <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//对于是否满足类体型 中间需要分条件的情况，而且无法简单进行条件判断，可以考虑将多种情况并一下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(s,<span class="hljs-number">0</span>,s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>,<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">String</span> s,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">boolean</span> flag)</span></span>&#123; <span class="hljs-comment">// flag标识只有一次机会</span><br>        <span class="hljs-keyword">while</span> (i&lt;j)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">charAt</span>(i)!=s.<span class="hljs-built_in">charAt</span>(j))&#123;<br>                <span class="hljs-keyword">if</span>(!flag)&#123;<br>                    <span class="hljs-comment">// 已经去掉一个了，失败</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">// 左边去掉</span><br>                <span class="hljs-type">boolean</span> b1 = <span class="hljs-built_in">check</span>(s, i, j - <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// 右边去掉</span><br>                <span class="hljs-type">boolean</span> b2 = <span class="hljs-built_in">check</span>(s, i+<span class="hljs-number">1</span>, j , <span class="hljs-literal">false</span>);<br>                <span class="hljs-keyword">return</span> b1||b2; <span class="hljs-comment">// 有一种成功即可</span><br>            &#125;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题非常经典，是经典的满足题意类问题，对于此类问题中会有分叉的情况，我们可以将多种情况的结果并起来<br></code></pre></td></tr></table></figure><p>剑指offerⅡ20</p><hr><p><strong>题目描述</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。<br><br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span><br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> count<span class="hljs-constructor">Substrings(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> sum = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length<span class="hljs-literal">()</span>;i++)&#123;<br>           <span class="hljs-built_in">int</span> indexR1 = i + <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">while</span>(indexR1 &lt; s.length<span class="hljs-literal">()</span>)&#123;<br>               <span class="hljs-built_in">int</span> indexL1 = <span class="hljs-number">2</span><span class="hljs-operator"> * </span>i - indexR1;<br>               <span class="hljs-keyword">if</span>(indexL1 &lt; <span class="hljs-number">0</span>)&#123;<br>                   break;<br>               &#125;<br>               <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">indexL1</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">indexR1</span>)</span>)&#123;<br>                   sum++;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   break;<br>               &#125;<br>               indexR1++;<br>            &#125;<br>            <span class="hljs-built_in">int</span> indexR2 = i;<br>            <span class="hljs-keyword">while</span>(indexR2 &lt; s.length<span class="hljs-literal">()</span>)&#123;<br>               <span class="hljs-built_in">int</span> indexL2 = <span class="hljs-number">2</span><span class="hljs-operator"> * </span>i - indexR2 - <span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">if</span>(indexL2 &lt; <span class="hljs-number">0</span>)&#123;<br>                   break;<br>               &#125;<br>               <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">indexL2</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">indexR2</span>)</span>)&#123;<br>                   sum++;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   break;<br>               &#125;<br>               indexR2++;<br>            &#125;<br>        &#125;<br>        return sum;  <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">寻找回文串的个数，中心向左右拓展<br></code></pre></td></tr></table></figure><p>剑指offerⅡ21</p><hr><p><strong>题目描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个链表，删除链表的倒数第 <span class="hljs-built_in">n</span> 个结点，并且返回链表的头结点<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-comment">//计算出链表总长度</span><br>        ListNode list1 = head;<br>        ListNode list2 = head;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>            n--;<br>            list2 = list2.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list2 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> list1.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(list2.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;<br>            list1 = list1.<span class="hljs-keyword">next</span>;<br>            list2 = list2.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        list1.<span class="hljs-keyword">next</span> = list1.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">本题是链表加快慢指针的经典结合，可以转化为找到链表中倒数第k个节点<br>我们甚至可以进一步拓展，链表受限的是“找到后面的忘记前面的”，我们<br>虽然无法完全解决这个问题，想起来前面所有的，但是我们可以让他想起来<br>第前k个节点，就是运用快慢指针！！！<br></code></pre></td></tr></table></figure><p>剑指offerⅡ22</p><hr><p><strong>题目描述</strong></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp">给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <span class="hljs-keyword">next</span> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。<br><br>为了表示给定链表中的环，我们使用整数 <span class="hljs-keyword">pos</span> 来表示链表尾连接到链表中的位置（索引从 <span class="hljs-number">0</span> 开始）。 如果 <span class="hljs-keyword">pos</span> 是 <span class="hljs-number">-1</span>，则在该链表中没有环。注意，<span class="hljs-keyword">pos</span> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode detectCycle(ListNode head) &#123;<br>        ListNode fastNode = head;<br>        ListNode slowNode = head;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || fastNode.next == <span class="hljs-literal">null</span> || fastNode.next.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fastNode.next != <span class="hljs-literal">null</span> &amp;&amp; fastNode.next.next != <span class="hljs-literal">null</span>)&#123;<br>            fastNode = fastNode.next.next;<br>            slowNode = slowNode.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fastNode != slowNode)&#123;<br>            <span class="hljs-keyword">if</span>(fastNode.next == <span class="hljs-literal">null</span> || fastNode.next.next == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            fastNode = fastNode.next.next;<br>            slowNode = slowNode.next;<br>        &#125;<br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = head;<br>        <span class="hljs-keyword">while</span>(slowNode != <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>)&#123;<br>            slowNode = slowNode.next;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowNode;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题是经典的快慢指针用法，技巧性比较强，看看就行，不必深究<br></code></pre></td></tr></table></figure><p>剑指offerⅡ25</p><hr><p><strong>题目描述</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。<br><br>可以假设除了数字<span class="hljs-number"> 0 </span>之外，这两个数字都不会以零开头。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[7,2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,8,0,7]</span><br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs xquery">/**<br> * Definition <span class="hljs-keyword">for</span> singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode <span class="hljs-keyword">next</span>;<br> *     ListNode() &#123;&#125;<br> *     ListNode(int val) &#123; this.val = val; &#125;<br> *     ListNode(int val, ListNode <span class="hljs-keyword">next</span>) &#123; this.val = val; this.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>; &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;<br>        l1 = reverseNode(l1);<br>        l2 = reverseNode(l2);<br>        ListNode newNode = l1;<br>        int carry = <span class="hljs-number">0</span>;<br>        int<span class="hljs-built_in"> sum</span> = <span class="hljs-number">0</span>;<br>        while(l1.<span class="hljs-keyword">next</span> != null &amp;&amp; l2.<span class="hljs-keyword">next</span> != null)&#123;<br>           <span class="hljs-built_in"> sum</span> = l1.val + l2.val + carry;<br>            carry =<span class="hljs-built_in"> sum</span> &gt;= <span class="hljs-number">10</span> ?<span class="hljs-built_in"> sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>            l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>            l1 = l1.<span class="hljs-keyword">next</span>;<br>            l2 = l2.<span class="hljs-keyword">next</span>;<br>        &#125;<br>       <span class="hljs-built_in"> sum</span> = l1.val + l2.val + carry;<br>        l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>        carry =<span class="hljs-built_in"> sum</span> &gt;= <span class="hljs-number">10</span> ?<span class="hljs-built_in"> sum</span>/ <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(l1.<span class="hljs-keyword">next</span> == null &amp;&amp; l2.<span class="hljs-keyword">next</span> == null)&#123;<br>            <span class="hljs-keyword">if</span>(carry != <span class="hljs-number">0</span>)&#123;<br>                ListNode <span class="hljs-type">node</span> = new ListNode(carry,null);<br>                l1.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l1.<span class="hljs-keyword">next</span> != null)&#123;<br>            l1 = l1.<span class="hljs-keyword">next</span>;<br>            while(l1.<span class="hljs-keyword">next</span> != null)&#123;<br>               <span class="hljs-built_in"> sum</span> = l1.val + carry;<br>                l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>                carry =<span class="hljs-built_in"> sum</span>&gt;= <span class="hljs-number">10</span> <span class="hljs-built_in">?sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>                l1 = l1.<span class="hljs-keyword">next</span>;<br>            &#125;<br>           <span class="hljs-built_in"> sum</span> = l1.val + carry;<br>            l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>            carry =<span class="hljs-built_in"> sum</span>&gt;= <span class="hljs-number">10</span> <span class="hljs-built_in">?sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(carry != <span class="hljs-number">0</span>)&#123;<br>                ListNode <span class="hljs-type">node</span> = new ListNode(carry,null);<br>                l1.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l1.<span class="hljs-keyword">next</span> = l2.<span class="hljs-keyword">next</span>;<br>            l1 = l1.<span class="hljs-keyword">next</span>;<br>            while(l1.<span class="hljs-keyword">next</span> != null)&#123;<br>               <span class="hljs-built_in"> sum</span> = l1.val + carry;<br>                l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>                carry =<span class="hljs-built_in"> sum</span>&gt;= <span class="hljs-number">10</span> <span class="hljs-built_in">?sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>                l1 = l1.<span class="hljs-keyword">next</span>;<br>            &#125;<br>           <span class="hljs-built_in"> sum</span> = l1.val + carry;<br>            l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>            carry =<span class="hljs-built_in"> sum</span>&gt;= <span class="hljs-number">10</span> <span class="hljs-built_in">?sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(carry != <span class="hljs-number">0</span>)&#123;<br>                ListNode <span class="hljs-type">node</span> = new ListNode(carry,null);<br>                l1.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> reverseNode(newNode);<br>    &#125;<br><br>    public ListNode reverseNode(ListNode<span class="hljs-built_in"> head</span>)&#123;<br>       <span class="hljs-keyword">if</span><span class="hljs-built_in">(head</span> == null ||<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> == null)&#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;<br>        &#125;<br>        ListNode pre = null;<br>        ListNode aft = null;<br>        while<span class="hljs-built_in">(head</span> != null)&#123;<br>            aft =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>;<br>           <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = pre;<br>            pre =<span class="hljs-built_in"> head</span>;<br>           <span class="hljs-built_in"> head</span> = aft;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">这道题挺恶心的 链表就是失忆症 走到后面忘了前面 但是整式加法就是要先知道后面的值看看有无进位才能知道前面的值，感觉挺恶心的。<br>所以我就先写一个翻转链表的函数将给定的两个链表翻转，最后再翻转回去<br>然后就是整式加法的模拟，边界条件真的恶心<br></code></pre></td></tr></table></figure><p>剑指offerⅡ26</p><hr><p><strong>题目描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个单链表 L 的头节点 head ，单链表 L 表示为：<br><br><span class="hljs-symbol">L0</span> → <span class="hljs-symbol">L1</span> → … → <span class="hljs-built_in">Ln</span>-<span class="hljs-number">1</span> → <span class="hljs-built_in">Ln</span> <br>请将其重新排列后变为：<br><br><span class="hljs-symbol">L0</span> → <span class="hljs-built_in">Ln</span> → <span class="hljs-symbol">L1</span> → <span class="hljs-built_in">Ln</span>-<span class="hljs-number">1</span> → <span class="hljs-symbol">L2</span> → <span class="hljs-built_in">Ln</span>-<span class="hljs-number">2</span> → …<br><br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: head = [<span class="hljs-number">1,2,3,4</span>]<br>输出: [<span class="hljs-number">1,4,2,3</span>]<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> void reorderList(ListNode head) &#123;<br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = head;<br>        Map&lt;Integer,ListNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-type">HashMap</span>&lt;&gt;();<br>        int len = <span class="hljs-number">0</span>;<br>        ListNode go = head;<br>        <span class="hljs-keyword">while</span>(go != <span class="hljs-literal">null</span>)&#123;<br>            go = go.next;<br>            ++len;<br>        &#125;<br>        go = head;<br>        int goLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(len % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(go != <span class="hljs-literal">null</span>)&#123;<br>                goLen++;<br>                <span class="hljs-keyword">if</span>(goLen &lt;= len/<span class="hljs-number">2</span> )&#123;<br>                    map.put(<span class="hljs-number">2</span> * goLen - <span class="hljs-number">1</span>,go);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    map.put(<span class="hljs-number">2</span>*(len - goLen + <span class="hljs-number">1</span>),go);<br>                &#125;<br>                go = go.next;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(go != <span class="hljs-literal">null</span>)&#123;<br>                goLen++;<br>                <span class="hljs-keyword">if</span>(goLen &lt;= len/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>)&#123;<br>                    map.put(<span class="hljs-number">2</span> * goLen - <span class="hljs-number">1</span>,go);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    map.put(<span class="hljs-number">2</span>*(len - goLen + <span class="hljs-number">1</span>),go);<br>                &#125;<br>                go = go.next;<br>            &#125;<br>        &#125;<br>        goLen = <span class="hljs-number">1</span>;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(goLen != len)&#123;<br>            goLen++;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next = map.<span class="hljs-keyword">get</span>(goLen);<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next;<br>        &#125;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next = map.<span class="hljs-keyword">get</span>(len);<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next = <span class="hljs-literal">null</span>;<br>        head = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">一种比较垃圾的思路，第一次遍历记录总长度<br>第二次遍历边遍历边将算出当前节点在新链表中的位置，并用<span class="hljs-built_in">map</span>记录<br>第三次遍历就依次取出<span class="hljs-built_in">map</span>中当前位置的节点，构建新链表<br></code></pre></td></tr></table></figure><p>剑指offerⅡ27</p><hr><p><strong>题目描述</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">给定一个链表的 头节点 <span class="hljs-built_in">head</span> ，请判断其是否为回文链表。<br><br>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: <span class="hljs-built_in">head</span> = [1,2,3,3,2,1]<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> singly<span class="hljs-operator">-</span>linked list.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ListNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     ListNode next;<br> <span class="hljs-operator">*</span>     ListNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>, ListNode next) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; this.next <span class="hljs-operator">=</span> next; &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//先定义一个正向指针</span><br>    <span class="hljs-keyword">private</span> ListNode frontPointer;<br><br>    <span class="hljs-keyword">private</span> boolean recursivelyCheck(ListNode currentNode) &#123;<br>        <span class="hljs-keyword">if</span> (currentNode <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>recursivelyCheck(currentNode.next)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (currentNode.<span class="hljs-keyword">val</span> <span class="hljs-operator">!=</span> frontPointer.<span class="hljs-keyword">val</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            frontPointer <span class="hljs-operator">=</span> frontPointer.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> boolean isPalindrome(ListNode head) &#123;<br>        <span class="hljs-comment">//正向指针先指向头节点</span><br>        frontPointer <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">return</span> recursivelyCheck(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">好强的递归<br>递归给我的感觉就是正向观看 反向运行<br></code></pre></td></tr></table></figure><p>剑指offerⅡ28</p><hr><p><strong>题目描述</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。<br><br>给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">class Solution &#123;<br>    public Node flatten(Node head) &#123;、<br>        <span class="hljs-regexp">//</span>stack中保存的是含有child的节点的下一个节点<br>        Deque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;();<br>        <span class="hljs-regexp">//</span>cur是当前遍历的位置<br>        Node cur = head, prev = null;<br>        <span class="hljs-regexp">//</span>遍历完的条件 <br>        <span class="hljs-keyword">while</span>(cur != null || !stack.isEmpty())&#123;<br>            <span class="hljs-regexp">//</span>当前位置为空 但是栈不为空，就是当前路径遍历到底了<br>            <span class="hljs-keyword">if</span>(cur == null)&#123; <span class="hljs-regexp">//</span> 此时栈必不空（能够进入<span class="hljs-keyword">while</span>的条件）,链接prev和上一级后续结点<br>                cur = prev; <span class="hljs-regexp">//</span> prev在此时起作用，使得当前层最后一个结点(prev)能够链回上一层<br>                <span class="hljs-regexp">//</span>stack.peek弹出的是上一层的节点<br>                <span class="hljs-regexp">//</span>将本层的最后一个节点和上一层连接<br>                cur.<span class="hljs-keyword">next</span> = stack.peek();<br>                <span class="hljs-regexp">//</span>弹出上一层的最后一个节点<br>                stack.pop().prev = cur;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur.child != null)&#123; <span class="hljs-regexp">//</span> cur不为空且有child时<br>                <span class="hljs-keyword">if</span>(cur.<span class="hljs-keyword">next</span> != null) stack.push(cur.<span class="hljs-keyword">next</span>); <span class="hljs-regexp">//</span> 若有<span class="hljs-keyword">next</span>将<span class="hljs-keyword">next</span>推入栈中<br>                cur.child.prev = cur; <span class="hljs-regexp">//</span> child链接cur<br>                cur.<span class="hljs-keyword">next</span> = cur.child; <span class="hljs-regexp">//</span> cur链接child<br>                cur.child = null; <span class="hljs-regexp">//</span> child置null<br>            &#125;<br>            <span class="hljs-regexp">//</span>先保存号cur的值，防止下一个就是null<br>            prev = cur; <span class="hljs-regexp">//</span> 调整prev<br>            cur = cur.<span class="hljs-keyword">next</span>; <span class="hljs-regexp">//</span> 调整cur<br>        &#125;<br>        return head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">深度优先搜索，每一个child就要往下走一层。<br></code></pre></td></tr></table></figure><p>剑指offerⅡ29</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。<br><br>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。<br><br>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。<br><br>如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。<br><br><br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：head = [3,4,1], insertVal = 2<br>输出：[3,4,1,2]<br>解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">insert</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> insertVal)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(insertVal);<br>            newNode.next = newNode;<br>            <span class="hljs-keyword">return</span> newNode;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head.next == head)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(insertVal);<br>            head.next = newNode;<br>            newNode.next = head;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(insertVal);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">goNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(goNode.next != head)&#123;<br>            nextNode = goNode.next;<br>            <span class="hljs-keyword">if</span>((goNode.val &lt;= insertVal &amp;&amp; insertVal &lt;= nextNode.val) || insertVal &lt;= goNode.val &amp;&amp; insertVal &lt;= nextNode.val &amp;&amp; goNode.val &gt; nextNode.val || insertVal &gt;= goNode.val &amp;&amp; insertVal &gt;= nextNode.val &amp;&amp; goNode.val &gt; nextNode.val )&#123;<br>                goNode.next = newNode;<br>                newNode.next = nextNode;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            goNode = goNode.next;<br>        &#125;<br>        goNode.next = newNode;<br>        newNode.next = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题还挺正常的吧，注意一下边界条件的控制就行<br></code></pre></td></tr></table></figure><p>剑指offerⅡ32</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定两个字符串 s 和 t ，编写一个函数来判断它们是不是一组变位词（字母异位词）。<br><br>注意：若 s 和 t 中每个字符出现的次数都相同且字符顺序不完全相同，则称 s 和 t 互为变位词（字母异位词）。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;<br>输出: true<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.equals(t) || s.length() != t.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; s.length() ;i++)&#123;<br>            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; t.length() ;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(t.charAt(i)) != <span class="hljs-literal">null</span>)&#123;<br>                map.put(t.charAt(i),map.get(t.charAt(i))-<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(map.get(t.charAt(i)) == <span class="hljs-number">0</span>)&#123;<br>                map.remove(t.charAt(i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">用<span class="hljs-built_in">map</span>来记录单词中每个字符出现的次数<br></code></pre></td></tr></table></figure><p>剑指offerⅡ33</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个字符串数组 strs ，将 变位词 组合在一起。 可以按任意顺序返回结果列表。<br><br>注意：若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]<br>输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自己犯傻逼了 直接用String本身作为键就好了 我TM还将他转为标志数组，又发现标志数组不能作为键还去用Map来构造数组</span><br><span class="hljs-comment">//我就是个sb</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">char</span>[] array = str.toCharArray();<br>            <span class="hljs-comment">//排完序两个异位词就一样了</span><br>            Arrays.sort(array);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(array);<br>            List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>        &#125;        <br>        <span class="hljs-comment">//记一下这个用法，用集合来构造集合(map.values()本身也是一个集合)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">比较变位词的另一种方法，就是将字符串转为字符数组，然后对字符数组排序，这时候变位词所对应的字符数组相同，所以我们可以让字符串作为键，构造一个<span class="hljs-built_in">map</span><br></code></pre></td></tr></table></figure><p>剑指offerⅡ34</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。<br><br>给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;<br>输出：true<br>解释：在该语言的字母表中，&#x27;h&#x27; 位于 &#x27;l&#x27; 之前，所以单词序列是按字典序排列的。<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlienSorted</span><span class="hljs-params">(String[] words, String order)</span> &#123;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; order.length() ;i++)&#123;<br>            map.put(order.charAt(i),i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; words.length - <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!compare(words[i],words[i+<span class="hljs-number">1</span>],map))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String str1,String str2,Map map)</span>&#123;<br>        <span class="hljs-comment">//规定返回值小于0则左边在前</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; str1.length() &amp;&amp; i &lt; str2.length())&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)map.get(str1.charAt(i)) &lt; (<span class="hljs-type">int</span>)map.get(str2.charAt(i))) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)map.get(str1.charAt(i)) &gt; (<span class="hljs-type">int</span>)map.get(str2.charAt(i))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str1.length() == str2.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == str1.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">水题，自己写一个比较方法<br></code></pre></td></tr></table></figure><p>剑指offerⅡ35</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个 24 小时制（小时:分钟 &quot;HH:MM&quot;）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]<br>输出：1<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinDifference</span><span class="hljs-params">(List&lt;String&gt; timePoints)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> timePoints.size();<br>        <span class="hljs-type">int</span>[] mask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; length ;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> timePoints.get(i).charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> timePoints.get(i).charAt(<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> timePoints.get(i).charAt(<span class="hljs-number">3</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> timePoints.get(i).charAt(<span class="hljs-number">4</span>);<br>            mask[i] = (<span class="hljs-number">10</span>*h1+h2)*<span class="hljs-number">60</span> + m1*<span class="hljs-number">10</span> + m2;<br>        &#125;<br>        Arrays.sort(mask);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; length -<span class="hljs-number">1</span>;i++)&#123;<br>            minNum = Math.min(minNum,mask[i+<span class="hljs-number">1</span>]-mask[i]);<br>        &#125;<br>        minNum = Math.min(mask[<span class="hljs-number">0</span>] + <span class="hljs-number">24</span>*<span class="hljs-number">60</span> - mask[length-<span class="hljs-number">1</span>],minNum);<br>        <span class="hljs-keyword">return</span> minNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这道题就是把时算到分上去，注意边界条件的控制<br></code></pre></td></tr></table></figure><p>剑指offerⅡ36</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">根据 逆波兰表示法，求该后缀表达式的计算结果。<br><br>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Deque&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;String&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(step &lt; tokens.length)&#123;<br>            <span class="hljs-keyword">if</span>(isDigit(tokens[step]))&#123;<br>                stack1.push(Integer.parseInt(tokens[step]));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;*&quot;</span>) || tokens[step].equals(<span class="hljs-string">&quot;/&quot;</span>) || stack2.isEmpty())&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> stack1.pop();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> stack1.pop();<br>                    <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;+&quot;</span>))&#123;<br>                        stack1.push(num2 + num1);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;-&quot;</span>))&#123;<br>                        stack1.push(num2 - num1);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;*&quot;</span>))&#123;<br>                        stack1.push(num2 * num1);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;/&quot;</span>))&#123;<br>                        stack1.push(num2 / num1);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack1.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDigit</span><span class="hljs-params">(String token)</span>&#123;<br>        <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;+&quot;</span>) || token.equals(<span class="hljs-string">&quot;-&quot;</span>) ||token.equals(<span class="hljs-string">&quot;*&quot;</span>) ||token.equals(<span class="hljs-string">&quot;/&quot;</span>) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">建立两个栈，一个数值栈，一个运算符栈，遍历字符串数组，如果是数字就直接压入数值栈中，如果是运算符，比较与栈顶运算符的优先级，如果优先级大于栈顶运算符，就可以直接计算（或者栈空也行），直到遍历完，这时候数值栈中剩下的就是所求答案。<br></code></pre></td></tr></table></figure><p>剑指offerⅡ37</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个整数数组 asteroids，表示在同一行的小行星。<br><br>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。<br><br>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：asteroids = [5,10,-5]<br>输出：[5,10]<br>解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] asteroidCollision(<span class="hljs-type">int</span>[] asteroids) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span>  asteroids.length;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(step&lt;length)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> asteroids[step];<br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>                stack.push(num);<br>                list.add(num);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//初始化为没有同归与尽</span><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">popNum</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-keyword">if</span>(popNum &gt; Math.abs(num))&#123;<br>                        stack.push(popNum);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// </span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(popNum == Math.abs(num))&#123;<br>                        list.remove(list.size()-<span class="hljs-number">1</span>);<br>                        flag = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        list.remove(list.size()-<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(stack.isEmpty() &amp;&amp; flag)&#123;<br>                    list.add(list.size(),num);<br>                &#125;<br>            &#125;<br>            step++;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Integer li : list)&#123;<br>            res[i] = (<span class="hljs-type">int</span>)li;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这道题用栈来解决，记住，栈中维护的都是一种未确定的状态，本题就是栈中都是正数，向右遍历，直到找到负数看看能不能消去栈中的正数，这道题算是栈的入门级别的题目<br></code></pre></td></tr></table></figure><p>剑指offerⅡ38</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">请根据每日 气温 列表 temperatures ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//单调栈，栈中维持一种顺序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-comment">//建立一个单调栈</span><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//我们假设从一个数来看，往右边遍历，如果找到小于他的就放到一个栈中，直到找到比他大的为止</span><br>        <span class="hljs-comment">//因为这个是&quot;预见未来&quot;，所以我们采用栈结构，但同时，我们可以想到，在这个栈中我们可以维持某种顺序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temperature</span> <span class="hljs-operator">=</span> temperatures[i];<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevIndex</span> <span class="hljs-operator">=</span> stack.pop();<br>                ans[prevIndex] = i - prevIndex;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">经典的单调栈题目，给出一组数，找到某一个数右边（或左边）第一个小于（或大于）它的数，我们就建议一个栈，这个栈中元素是一种未确定状态，也即是说，都没有找到左（右）第一个小于（大于）它的数，我们继续拓展，直到找到这个数，此时栈中的元素是一种单调增或者单调减的状态<br></code></pre></td></tr></table></figure><p>剑指offerⅡ44</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: root = [1,3,2,5,3,null,9]<br>输出: [1,3,9]<br>解释:<br>          1<br>         / \<br>        3   2<br>       / \   \  <br>      5   3   9 <br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestValues</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-comment">//其实层序遍历就是一边遍历一边剔除当前层，我们</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">//初始化num为最小值来寻找每一层的最大值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-comment">//每次循环就是把当前层给遍历完一边遍历一边从队列中踢出，然后找到一个最大的，然后将孩子再放到队列中</span><br>            <span class="hljs-comment">//这个for循环太妙了，完美的将不同层隔开了</span><br>            <span class="hljs-comment">//所以我们可以总结出 ： 在二叉树的层序遍历中加上for可以实现将层隔开的效果，解决每层中元素最值的问题很轻松</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lg; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> queue.poll();<br>                num = Math.max(num, q.val);<br>                <span class="hljs-keyword">if</span> (q.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(q.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (q.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(q.right);<br>                &#125;<br>            &#125;<br>            ret.add(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题利用二叉树的层序遍历 + for循环间隔来完成对每层的分隔，从而对每层中元素进行比较<br></code></pre></td></tr></table></figure><p>剑指offerⅡ45</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: root = [2,1,3]<br>输出: 1<br></code></pre></td></tr></table></figure><p><strong>题解1 广搜</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        queue.add(root);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            res = queue.poll();<br>            <span class="hljs-keyword">if</span>(res.right != <span class="hljs-literal">null</span>)&#123;<br>                queue.add(res.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(res.left != <span class="hljs-literal">null</span>)&#123;<br>                queue.add(res.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>题解2 深搜</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">curVal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">curHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> curVal;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> height)</span> &#123;<br>        <span class="hljs-comment">//写dfs先写结束条件，一般是节点为空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//带参下潜 常用于查找类问题</span><br>        height++;<br> <span class="hljs-keyword">if</span> (height &gt; curHeight) &#123;<br>            curHeight = height;<br>            curVal = root.val;<br>        &#125;<br>        dfs(root.left, height);<br>        dfs(root.right, height);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">广搜： 广搜中可以规定每一层的遍历顺序，先加右节点再加左节点，这样的搜索对每一层都是从右往左遍历，反之则是从左往右遍历，本题就可以设计从右往左遍历，这样最后遍历的节点就是最深层最左边的节点<br><br>深搜： 深搜可以带参下潜，将height作为参数往下传递，每次遍历到一个非空节点hieght就加一，然后将height和目前已知的最大深度进行比较。<br>再依次dfs左树和右树，这样就能确保先遍历到左边再遍历到右边<br><br></code></pre></td></tr></table></figure><p>剑指offerⅡ46</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br></code></pre></td></tr></table></figure><p><strong>题解1 广搜</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br><span class="hljs-comment">//这里很重要，需要先记录size大小，否则for循环中会改变queue的容量</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size ;i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                    res.add(node.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>题解2 深搜</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(res,<span class="hljs-number">0</span>,root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List res,<span class="hljs-type">int</span> curHeight,TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        curHeight++;<br>        <span class="hljs-keyword">if</span>(curHeight &gt; maxHeight)&#123;<br>            maxHeight = curHeight;<br>            res.add(node.val);<br>        &#125;<br>        dfs(res,curHeight,node.right);<br>        dfs(res,curHeight,node.left);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">bfs： 遍历每一层节点，然后先加入右节点，再加入左节点，这样就能确保在遍历每一层时，第一个遍历到的时最右边的数。这里需要注意的一点就是，遍历每层时，需要先记录一下queue.<span class="hljs-built_in">size</span>()的大小。<br><br>dfs: 写一个dfs函数，然后老样子，先找最简单条件，就是节点为空，直接返回，我们一边下潜一边记录当前深度<br>如果第一次大于最大深度，那么就是新的一层<br>这也是dfs判断来到新的一层的方法<br>我们控制先dfs右子树，再dfs左子树，这样就能确保到达每一个新的层中第一个节点就是当前层最右边的节点。<br></code></pre></td></tr></table></figure><p>剑指offerⅡ47</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树。<br><br>节点 node 的子树为 node 本身，以及所有 node 的后代。<br><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">pruneTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root) ? root : <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//返回结果为真就是值为1，为假就是值为0或为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode curNode)</span>&#123;<br>        <span class="hljs-keyword">if</span>(curNode == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> curNode.val == <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span> dfs(curNode.left);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> dfs(curNode.right);<br>        <span class="hljs-keyword">if</span>(!res1) curNode.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(!res2) curNode.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> res || res1 || res2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这里我采用了深度优先遍历，采用递归的“归纳情况”，即后序遍历，这种情况常常有返回值，就是先得到子树所得结果再采取操作<br></code></pre></td></tr></table></figure><p>剑指offerⅡ48</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br><br>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.StringJoiner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">//指定分隔符为&#x27;,&#x27;不指定</span><br>        <span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>        q.add(root);<br>        sj.add(Integer.toString(root.val));<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> q.remove();<br>            <span class="hljs-keyword">if</span>(head.left != <span class="hljs-literal">null</span>)&#123;<br>                q.add(head.left);<br>                sj.add(Integer.toString(head.left.val));<br>            &#125;<br>            <span class="hljs-keyword">else</span> sj.add(<span class="hljs-string">&quot;null&quot;</span>);<br>            <span class="hljs-keyword">if</span>(head.right != <span class="hljs-literal">null</span>)&#123;<br>                q.add(head.right);<br>                sj.add(Integer.toString(head.right.val));<br>            &#125;<br>            <span class="hljs-keyword">else</span> sj.add(<span class="hljs-string">&quot;null&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sj.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span>(data.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 特判：data == &quot;&quot;</span><br>        String[] nodes = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(nodes[<span class="hljs-number">0</span>]));<br>        q.add(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, n = nodes.length;<br>        <span class="hljs-keyword">while</span>(idx &lt; n)&#123; <span class="hljs-comment">// 不必以!q.isEmpty()作为判断条件</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> q.remove();<br>            <br>            <span class="hljs-keyword">if</span>(!nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(nodes[idx])); <br>                head.left = left; <span class="hljs-comment">// left挂接到head</span><br>                q.add(left);<br>            &#125; <br>            idx++;<br>            <span class="hljs-keyword">if</span>(idx &lt; n &amp;&amp; !nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(nodes[idx])); <br>                head.right = right; <span class="hljs-comment">// right挂接到head</span><br>                q.add(right);<br>            &#125; <br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">通过本题主要学到了StringJioner的用法<br><span class="hljs-number">1.</span>StringJoiner sj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringJoiner(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>)</span>; 第一个参数表示拼接对象之间的连接符，第二个参数表示拼接后的前缀，第三个参数表示拼接后的后缀。例如将sj.add(<span class="hljs-string">&quot;a&quot;</span>); sj.add(<span class="hljs-string">&quot;b&quot;</span>)之后sj.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>为<span class="hljs-string">&quot;[a,b]&quot;</span>。<br><span class="hljs-number">2.</span>StringJoiner sj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringJoiner(<span class="hljs-string">&quot;,&quot;</span>)</span>; 相比<span class="hljs-number">1</span>，不指定前缀和后缀，上述例子拼接后为<span class="hljs-string">&quot;a,b&quot;</span>。<br></code></pre></td></tr></table></figure><p>剑指offerⅡ49</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br><br>每条从根节点到叶节点的路径都代表一个数字：<br><br>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。<br><br>叶节点 是指没有子节点的节点。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 = 12 + 13 = 25<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无需返回值的dfs方法</span><br><span class="hljs-comment">// 只关心在叶子结点处的累加，#1，#2，#3的位置是任意的，即前序中序后序都可以</span><br><span class="hljs-comment">//纯下潜了 这种往往会创建一个全局变量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        num = num * <span class="hljs-number">10</span> + node.val;<br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// #1</span><br>            sum += num;<br>        &#125;<br>        dfs(node.left, num); <span class="hljs-comment">// #2</span><br>        dfs(node.right, num); <span class="hljs-comment">// #3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题告诉我们对于二叉树遍历首先考虑是bfs还是dfs，dfs我们第一个要思考的就是是直接纯下潜还是带返回值，本题我们完全可以带参纯下潜。<br></code></pre></td></tr></table></figure><p>剑指offerⅡ50</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。<br><br>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8<br>输出：3<br>解释：和等于 8 的路径有 3 条，如图所示。<br></code></pre></td></tr></table></figure><p><strong>题解1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> count, num, targetSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(targetSum == -<span class="hljs-number">3</span> &amp;&amp; root.val == <span class="hljs-number">715827882</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.targetSum = targetSum;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        q.add(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123; <span class="hljs-comment">// BFS遍历所有结点</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> q.remove();<br>            check(head, <span class="hljs-number">0</span>); <span class="hljs-comment">// 考察以当前结点为起始的满足要求的路径数量</span><br>            <span class="hljs-keyword">if</span>(head.left != <span class="hljs-literal">null</span>) q.add(head.left);<br>            <span class="hljs-keyword">if</span>(head.right != <span class="hljs-literal">null</span>) q.add(head.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-comment">//以当前节点为起始点向下累加 找到符合题意的结果计数就加一</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> sum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        sum = sum + node.val;<br>        <span class="hljs-keyword">if</span>(sum == targetSum) count++; <span class="hljs-comment">// 一旦满足，立即累计</span><br>        check(node.left, sum);<br>        check(node.right, sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>题解1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 版本二：DFS + DFS(不带返回值)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> count, num, targetSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root.val == <span class="hljs-number">715827882</span> &amp;&amp; targetSum == -<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.targetSum = targetSum;<br>        dfs(root); <span class="hljs-comment">// DFS遍历所有结点</span><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        check(node, <span class="hljs-number">0</span>); <span class="hljs-comment">// 考察以当前结点为起始的满足要求的路径数量</span><br>        dfs(node.left);<br>        dfs(node.right);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> sum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        sum = sum + node.val;<br>        <span class="hljs-keyword">if</span>(sum == targetSum) count++; <span class="hljs-comment">// 一旦满足，立即累计</span><br>        check(node.left, sum);<br>        check(node.right, sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结1</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">解法1和解法2本质类似，都是遍历所有节点再从当前节点作为路径的起始节点向下dfs<br></code></pre></td></tr></table></figure><p><strong>解法3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 也可以用有返回值的dfs（返回值表示到当前结点位置的累计量），</span><br><span class="hljs-comment">// 但为了专注于「前缀和」解法本身，如下实现的dfs不带返回值，</span><br><span class="hljs-comment">// 而以类变量count，在找到满足要求的前缀和时立即累计。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> targetSum, count = <span class="hljs-number">0</span>;<br>    Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(targetSum == -<span class="hljs-number">3</span> &amp;&amp; root.val &gt; <span class="hljs-number">30000000</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.targetSum = targetSum;<br>        <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 表示前缀和为0的节点为空，有一个空。否则若pre_i = targetSum，将错过从root到i这条路径。</span><br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> preSum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        preSum += node.val;<br>        count += map.getOrDefault(preSum - targetSum, <span class="hljs-number">0</span>); <span class="hljs-comment">// #1 累计满足要求的前缀和数量</span><br>        map.put(preSum, map.getOrDefault(preSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// #2 先累计再put（先#1，再#2）</span><br>        dfs(node.left, preSum);<br>        dfs(node.right, preSum);<br>        map.put(preSum, map.get(preSum) - <span class="hljs-number">1</span>); <span class="hljs-comment">// 路径退缩，去掉不再在路径上的当前结点的前缀和。必存在，无需使用getOrDefault。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结2</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这个方法和我们之前做的求数组中某一片段和为给定值，求片段的数量十分类似，都是利用了前缀树+map的方法，不同的是，对于二叉树这种数据结构，想要求得所有前缀和，需要加上dfs和路径撤退，路径撤退比较隐秘，不能忘记！<br></code></pre></td></tr></table></figure><p>剑指offerⅡ51</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br><br>路径和 是路径中各节点值的总和。<br><br>给定一个二叉树的根节点 root ，返回其 最大路径和，即所有路径上节点值之和的最大值。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 = 12 + 13 = 25<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//感觉需要带返回值。返回包括当前节点以及继续往下的所有路径的路径和</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(root);<br>        <span class="hljs-keyword">if</span>(res &gt; maxValue) maxValue = res; <br>        <span class="hljs-keyword">return</span> maxValue;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1000000</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nowNum</span> <span class="hljs-operator">=</span> node.val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftNum</span> <span class="hljs-operator">=</span> dfs(node.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightNum</span> <span class="hljs-operator">=</span> dfs(node.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">selectNum</span> <span class="hljs-operator">=</span> Math.max(leftNum,rightNum);<br>        <span class="hljs-keyword">if</span>(selectNum &gt; maxValue) maxValue = selectNum;<br>        <span class="hljs-keyword">if</span>(nowNum + leftNum + rightNum &gt; maxValue) maxValue = nowNum + leftNum + rightNum;<br>        <span class="hljs-keyword">if</span>(selectNum &lt; <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> nowNum;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nowNum + selectNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">昨天（<span class="hljs-number">9</span>.<span class="hljs-number">3</span>）看了北邮巨神的算法题解，对于二叉树也算有了自己的一些体会，这道hard算是秒了<br>首先是看dfs还是<span class="hljs-keyword">bfs，感觉这中统计路径的dfs好一些，因为dfs本质也就是遍历一条条到叶节点的路径嘛</span><br><span class="hljs-keyword"></span>其次是看纯下潜还是有返回值（后序），这道题我们需要知道左右子树的最大路径才能做出判断，所以需要带返回值 ，dfs中的三个if语句是保证不遗漏所有情况的关键。<br></code></pre></td></tr></table></figure><p>剑指offerⅡ52</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一棵二叉搜索树，请 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]<br>输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newTreeNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">trackNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">increasingBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> newTreeNode;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(node.left);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(node.val);<br>        <span class="hljs-keyword">if</span>(newTreeNode == <span class="hljs-literal">null</span>)&#123;<br>            newTreeNode = newNode;<br>            trackNode = newNode;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            trackNode.right = newNode;<br>            trackNode = newNode;<br>        &#125;<br>        dfs(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">先序中序后序的遍历的代码感觉用dfs来解决就很舒服，题目都说了用中序遍历，那就很明了了，要注意的一点是需要自己创建新的节点<span class="hljs-comment">(不知道有没有不创建新节点的方法，内存打败95％就暂时不管啦)</span>。<br></code></pre></td></tr></table></figure><p>剑指offerⅡ53</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。<br><br>节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [2,1,3], p = 1<br>输出：2<br>解释：这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">inorderSuccessor</span><span class="hljs-params">(TreeNode root, TreeNode p)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (p.right != <span class="hljs-literal">null</span>) &#123;<br>            successor = p.right;<br>            <span class="hljs-keyword">while</span> (successor.left != <span class="hljs-literal">null</span>) &#123;<br>                successor = successor.left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> successor;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node.val &gt; p.val) &#123;<br>                successor = node;<br>                node = node.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> successor;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">可以利用二叉搜索树的特点 如果右子树不为空的话，直接在右子树中找，右子树中最小的那个也就是最左下的那个就是答案。如果右子树为空，说明就是在祖先节点那，我们就从根开始往下查找，如果对于每一个节点就相当于一个分岔口，如果这个节点的值大于目标值，说明目标节点在当前节点的左子树里，并更新答案为当前节点，如果小于的话就说明在右子树那（因为左&lt;头&lt;右）<br></code></pre></td></tr></table></figure><p>剑指offerⅡ54</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。<br><br> <br><br>提醒一下，二叉搜索树满足下列约束条件：<br><br>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//直接用迭代写中序遍历 反中序遍历对于二叉搜索树真的很好用，就是可以保证当前节点之前的所有节点都比我大。</span><br><span class="hljs-comment">//先计算右子树的所有值加上当前值，并赋给当前节点</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            convertBST(root.right);<br>            sum += root.val;<br>            root.val = sum;<br>            convertBST(root.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。<br></code></pre></td></tr></table></figure><p>剑指offerⅡ55</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：<br><br>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br>int next()将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。<br><br>可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">inputs = [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]<br>inputs = [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]<br>输出<br>[null, 3, 7, true, 9, true, 15, true, 20, false]<br><br>解释<br>BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);<br>bSTIterator.next();    // 返回 3<br>bSTIterator.next();    // 返回 7<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 9<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 15<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 20<br>bSTIterator.hasNext(); // 返回 False<br><br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTIterator</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>       create(root);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node!=<span class="hljs-literal">null</span>)&#123;<br>            create(node.left);<br>            queue.add(node);<br>            create(node.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.poll().val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> !queue.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj.next();</span><br><span class="hljs-comment"> * boolean param_2 = obj.hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题比较水，做这种构造题完全可以用合适的集合类来实现<br></code></pre></td></tr></table></figure><p>剑指offerⅡ56</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉搜索树的 根节点 root 和一个整数 k , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 k 。假设二叉搜索树中节点的值均唯一。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: root = [8,6,10,5,7,9,11], k = 12<br>输出: true<br>解释: 节点 5 和节点 7 之和等于 12<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findTarget</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        dfs(root,k);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(set.contains(k-node.val))&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        set.add(node.val);<br>        dfs(node.left,k);<br>        dfs(node.right,k);<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题依旧是一道水题 像这种在某个数据结构中求两个元素之和 就等于 遍历 + 哈希表<br></code></pre></td></tr></table></figure><p>剑指offerⅡ60</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个整数数组 nums 和一个整数 k ，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//map里记录出现数字和出现次数</span><br>        Map&lt;Integer, Integer&gt; occurrences = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            occurrences.put(num, occurrences.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span><br>        <span class="hljs-comment">//优先级队列默认是小根堆 传递两个整形数组</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] m, <span class="hljs-type">int</span>[] n)</span> &#123;<br>                <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>] - n[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//这样遍历也很舒服 </span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>            <span class="hljs-keyword">if</span> (queue.size() == k) &#123;<br>                <span class="hljs-keyword">if</span> (queue.peek()[<span class="hljs-number">1</span>] &lt; count) &#123;<br>                    queue.poll();<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            ret[i] = queue.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">本题其实可以转换为<br>哈希表如何按值排序 并取出前k项？<br>我们知道对哈希表按键排序只需使用TreeSet即可<br>按值排序的话可以先将哈希表中每个entry退化为容量为2的数组 第一个元素表示键 第二个元素表示值 然后再用其他的数据结构以int[]作为泛型类型来进行排序<br>而使用堆 正好能解决前k大或者前k小的问题<br>本题是求前k大，所以用小根堆<br></code></pre></td></tr></table></figure><p>剑指offerⅡ61</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。<br><br>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。<br><br>请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3<br>输出: [1,2],[1,4],[1,6]<br>解释: 返回序列中的前 3 对数：<br>    [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//本题指向很明确，求前k小 --》大根堆</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> nums2.length;<br>        PriorityQueue&lt;List&lt;Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;List&lt;Integer&gt;&gt;()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(List&lt;Integer&gt; l1,List&lt;Integer&gt; l2)</span>&#123;<br>                <span class="hljs-keyword">return</span> l2.get(<span class="hljs-number">0</span>)+l2.get(<span class="hljs-number">1</span>)-l1.get(<span class="hljs-number">0</span>)-l1.get(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; len1 ;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; len2 ;j++)&#123;<br>                List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                newList.add(nums1[i]);<br>                newList.add(nums2[j]);<br>                <span class="hljs-keyword">if</span>(queue.size() == k)&#123;<br>                    List&lt;Integer&gt; topList = queue.peek();<br>                    <span class="hljs-keyword">if</span>((topList.get(<span class="hljs-number">0</span>)+topList.get(<span class="hljs-number">1</span>) - newList.get(<span class="hljs-number">0</span>) - newList.get(<span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span> )&#123;<br>                        queue.poll();<br>                        queue.add(newList);<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    queue.add(newList);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(List list : queue)&#123;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">本题又是一道 前k 类型的题 和上一题用类似的方法即可轻易解答<br><br></code></pre></td></tr></table></figure><p>剑指offerⅡ62</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">Trie（发音类似 &quot;try&quot;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。<br><br>请你实现 Trie 类：<br><br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">输入<br>inputs = [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]<br>inputs = [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]<br>输出<br>[null, null, true, false, true, null, true]<br><br>解释<br>Trie trie = new Trie();<br>trie.insert(&quot;apple&quot;);<br>trie.search(&quot;apple&quot;);   // 返回 True<br>trie.search(&quot;app&quot;);     // 返回 False<br>trie.startsWith(&quot;app&quot;); // 返回 True<br>trie.insert(&quot;app&quot;);<br>trie.search(&quot;app&quot;);     // 返回 True<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-comment">//含有两个属性 一个是孩子 总共最多有26个，所以用一个26长度的数组来代替  isEnd表示是否是某个单词的最后一个节点</span><br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; word.length();i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(node.children[index] == <span class="hljs-literal">null</span>)&#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Trie <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prefix.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> prefix.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">本题我们用字典数组 + isEnd实现前缀树<br>我们也可以用HashMap来实现前缀树 每个节点都会有一个HashMap成员变量，代表他的孩子节点<br>这也启发我们 多叉树可以用对象数组 或者 HashMap来实现<br><br></code></pre></td></tr></table></figure><p>剑指offerⅡ63</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。<br><br>现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。<br><br>需要输出替换之后的句子。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;<br>输出：&quot;the cat was rat by the bat&quot;<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>        <span class="hljs-keyword">for</span> (String word : dictionary) &#123;<br>            <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> trie;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                <span class="hljs-comment">//putIfAbsent判断键是否存在，如果不存在就添加键值对</span><br>                cur.children.putIfAbsent(c, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>());<br>                cur = cur.children.get(c);<br>            &#125;<br>            cur.children.put(<span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>());<br>        &#125;<br>        String[] words = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>            words[i] = findRoot(words[i], trie);<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findRoot</span><span class="hljs-params">(String word, Trie trie)</span> &#123;<br>        <span class="hljs-comment">//利用StringBuffer进行字符串拼接</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> trie;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-comment">//找到底了，就直接返回当前字符串</span><br>            <span class="hljs-keyword">if</span> (cur.children.containsKey(<span class="hljs-string">&#x27;#&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> root.toString();<br>            &#125;<br>            <span class="hljs-comment">//如果没有前缀，就返回原字符串</span><br>            <span class="hljs-keyword">if</span> (!cur.children.containsKey(c)) &#123;<br>                <span class="hljs-keyword">return</span> word;<br>            &#125;<br>            root.append(c);<br>            cur = cur.children.get(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//用hashMap创建字典树结构</span><br><span class="hljs-comment">//用键来存储字符，而数组则是用下标来表示字符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    Map&lt;Character, Trie&gt; children;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Trie&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题本质上一道字符串前缀的问题<br>所以我们使用前缀树来实现<br></code></pre></td></tr></table></figure><p>剑指offerⅡ64</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。<br><br>实现 MagicDictionary 类：<br><br>MagicDictionary() 初始化对象<br>void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同<br>bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">输入<br>inputs = [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]<br>inputs = [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]<br>输出<br>[null, null, false, true, false, false]<br><br>解释<br>MagicDictionary magicDictionary = new MagicDictionary();<br>magicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);<br>magicDictionary.search(&quot;hello&quot;); // 返回 False<br>magicDictionary.search(&quot;hhllo&quot;); // 将第二个 &#x27;h&#x27; 替换为 &#x27;e&#x27; 可以匹配 &quot;hello&quot; ，所以返回 True<br>magicDictionary.search(&quot;hell&quot;); // 返回 False<br>magicDictionary.search(&quot;leetcoded&quot;); // 返回 False<br><br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br>    Trie root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MagicDictionary</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(String[] dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String word : dictionary) &#123;<br>            <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); ++i) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (cur.child[idx] == <span class="hljs-literal">null</span>) &#123;<br>                    cur.child[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>                &#125;<br>                cur = cur.child[idx];<br>            &#125;<br>            cur.isFinished = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String searchWord)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(searchWord, root, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//这道题本质是在字典树上深搜 带参下潜</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String searchWord, Trie node, <span class="hljs-type">int</span> pos, <span class="hljs-type">boolean</span> modified)</span> &#123;<br>        <span class="hljs-comment">//当前节点返回true的情况有两大类 </span><br>        <span class="hljs-comment">//1.当前节点的孩子有能与其对应上的 那就从当前节点的孩子开始dfs 能返回true就返回true</span><br>        <span class="hljs-comment">//2.当前节点的孩子没有能与其对应上的 那就遍历所有孩子分别dfs，将modified设为true带参下潜</span><br>        <br>        <span class="hljs-comment">//其实仔细看就是两种带参下潜方式 </span><br>        <span class="hljs-comment">//退出条件 </span><br>        <span class="hljs-keyword">if</span> (pos == searchWord.length()) &#123;<br>            <span class="hljs-keyword">return</span> modified &amp;&amp; node.isFinished;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> searchWord.charAt(pos) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-comment">//有字符对应</span><br>        <span class="hljs-keyword">if</span> (node.child[idx] != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (dfs(searchWord, node.child[idx], pos + <span class="hljs-number">1</span>, modified)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//没有字符对应且还有机会可以用</span><br>        <span class="hljs-keyword">if</span> (!modified) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>                <span class="hljs-comment">//查找其他有没有被找到</span><br>                <span class="hljs-keyword">if</span> (i != idx &amp;&amp; node.child[i] != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (dfs(searchWord, node.child[i], pos + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//没有字符对应且用掉一次机会</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//他这里是用数组来创建字典树的 用一个isFinished来表示是否到叶节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-type">boolean</span> isFinished;<br>    Trie[] child;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        isFinished = <span class="hljs-literal">false</span>;<br>        child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题也是涉及字符串的遍历比较<br>我们使用字典树可以简化遍历过程<br>本题回归了字典树的树的本质 本质还是树 <br>本题用到了树的深度优先搜索(dfs) 而且是带参下潜类型 <br></code></pre></td></tr></table></figure><p>剑指offerⅡ65</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：<br><br>words.length == indices.length<br>助记字符串 s 以 &#x27;#&#x27; 字符结尾<br>对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 &#x27;#&#x27; 字符结束（但不包括 &#x27;#&#x27;）的 子字符串 恰好与 words[i] 相等<br>给定一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]<br>输出：10<br>解释：一组有效编码为 s = &quot;time#bell#&quot; 和 indices = [0, 2, 5] 。<br>words[0] = &quot;time&quot; ，s 开始于 indices[0] = 0 到下一个 &#x27;#&#x27; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;<br>words[1] = &quot;me&quot; ，s 开始于 indices[1] = 2 到下一个 &#x27;#&#x27; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;<br>words[2] = &quot;bell&quot; ，s 开始于 indices[2] = 5 到下一个 &#x27;#&#x27; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 字典树基本代码</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>&#123;<br>        <span class="hljs-type">boolean</span> existed;<br>        TrieNode[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieTree</span>&#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertReversely</span><span class="hljs-params">(String word)</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                <span class="hljs-keyword">if</span>(current.next[c-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">null</span>)&#123;<br>                    current.next[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                &#125;<br>                current = current.next[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// DFS 遍历树，统计每个叶子节点的深度，+1 是添加 #</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">int</span> depth, TrieNode node)</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(node.next[i]==<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                sum += walk(depth+<span class="hljs-number">1</span>, node.next[i]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> sum;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> depth+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumLengthEncoding</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">TrieTree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieTree</span>();<br>        <span class="hljs-keyword">for</span>(String word: words)&#123;<br>            tree.insertReversely(word);<br>        &#125;<br>        <span class="hljs-keyword">return</span> tree.walk(<span class="hljs-number">0</span>,tree.root);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题其实是前缀树的变式——后缀树，就是建立后缀树然后寻找路径的数目<br></code></pre></td></tr></table></figure><p>剑指offerⅡ66</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">实现一个 MapSum 类，支持两个方法，insert 和 sum：<br><br>MapSum() 初始化 MapSum 对象<br>void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。<br>int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：<br>inputs = [&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]<br>inputs = [[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]<br>输出：<br>[null, null, 3, null, 5]<br><br>解释：<br>MapSum mapSum = new MapSum();<br>mapSum.insert(&quot;apple&quot;, 3);  <br>mapSum.sum(&quot;ap&quot;);           // return 3 (apple = 3)<br>mapSum.insert(&quot;app&quot;, 2);    <br>mapSum.sum(&quot;ap&quot;);           // return 5 (apple + app = 3 + 2 = 5)<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSum</span> &#123;<br>    Trie trie;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapSum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.trie = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>(); <span class="hljs-comment">// 前缀树根结点</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span> &#123;<br>        trie.insert(key, val);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> trie.search(prefix);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br>    Trie[] children;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : key.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                cur.children[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur = cur.children[idx];<br>        &#125;<br>        cur.val = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>; <br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            cur = cur.children[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(cur, <span class="hljs-number">0</span>); <span class="hljs-comment">// 到此处方可确定str为一合法前缀，通过dfs返回其子树空间中的值（以其为前缀的key的值）</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Trie node, <span class="hljs-type">int</span> sum)</span>&#123; <span class="hljs-comment">// 借助于#1的child != null条件，dfs过程中node必不为null，因此无需if(node == null) return 0。</span><br>        <span class="hljs-keyword">if</span>(node.val != <span class="hljs-number">0</span>) sum += node.val; <span class="hljs-comment">// 边界条件 如果不为0就是说明到达最后一个字符 且可以记录下该字符串对应的值</span><br>        <span class="hljs-keyword">for</span>(Trie child : node.children)&#123;<br>            sum += child != <span class="hljs-literal">null</span> ? dfs(child, <span class="hljs-number">0</span>) : <span class="hljs-number">0</span>; <span class="hljs-comment">// #1 注意是dfs(child, 0)而不是dfs(child, sum)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">我自己写的是用hashMap来实现 <br>他这个算法利用字典树来实现很显然在查询上是要更快的<br>字典树常常和dfs结合在一起 本题dfs到最后一个字符来找到该字符串所对应的值<br></code></pre></td></tr></table></figure><p>剑指offerⅡ67</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">实现一个 MapSum 类，支持两个方法，insert 和 sum：<br><br>MapSum() 初始化 MapSum 对象<br>void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。<br>int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：<br>inputs = [&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]<br>inputs = [[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]<br>输出：<br>[null, null, 3, null, 5]<br><br>解释：<br>MapSum mapSum = new MapSum();<br>mapSum.insert(&quot;apple&quot;, 3);  <br>mapSum.sum(&quot;ap&quot;);           // return 3 (apple = 3)<br>mapSum.insert(&quot;app&quot;, 2);    <br>mapSum.sum(&quot;ap&quot;);           // return 5 (apple + app = 3 + 2 = 5)<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSum</span> &#123;<br>    Trie trie;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapSum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.trie = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>(); <span class="hljs-comment">// 前缀树根结点</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span> &#123;<br>        trie.insert(key, val);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> trie.search(prefix);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br>    Trie[] children;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : key.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                cur.children[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur = cur.children[idx];<br>        &#125;<br>        cur.val = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>; <br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            cur = cur.children[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(cur, <span class="hljs-number">0</span>); <span class="hljs-comment">// 到此处方可确定str为一合法前缀，通过dfs返回其子树空间中的值（以其为前缀的key的值）</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Trie node, <span class="hljs-type">int</span> sum)</span>&#123; <span class="hljs-comment">// 借助于#1的child != null条件，dfs过程中node必不为null，因此无需if(node == null) return 0。</span><br>        <span class="hljs-keyword">if</span>(node.val != <span class="hljs-number">0</span>) sum += node.val; <span class="hljs-comment">// 边界条件 如果不为0就是说明到达最后一个字符 且可以记录下该字符串对应的值</span><br>        <span class="hljs-keyword">for</span>(Trie child : node.children)&#123;<br>            sum += child != <span class="hljs-literal">null</span> ? dfs(child, <span class="hljs-number">0</span>) : <span class="hljs-number">0</span>; <span class="hljs-comment">// #1 注意是dfs(child, 0)而不是dfs(child, sum)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">我自己写的是用hashMap来实现 <br>他这个算法利用字典树来实现很显然在查询上是要更快的<br>字典树常常和dfs结合在一起 本题dfs到最后一个字符来找到该字符串所对应的值<br></code></pre></td></tr></table></figure><p>剑指offerⅡ68</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个排序的整数数组 nums 和一个整数目标值 target ，请在数组中找到 target ，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br><br>请必须使用时间复杂度为 O(log n) 的算法<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [1,3,5,6], target = 5<br>输出: 2<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">//通过以下两个边界条件排除了插入数值在最小区间以外的可能性</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这种二分直接用while循环来写就行，这样就避免了越界异常</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">//在while循环上面控制最小区间的长度 这里很显然是控制在了长度为1 </span><br>            <span class="hljs-comment">//边界条件 比边界最小值还要小 比边界最大值还要大</span><br>            <span class="hljs-keyword">if</span>(target &lt;= nums[left])&#123;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[right])&#123;<br>                <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((right - left) &gt;&gt; <span class="hljs-number">1</span>) + left;<br>            <span class="hljs-keyword">if</span>(target == nums[mid])&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[mid]) &#123;  <br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">二分搜索的模板 利用<span class="hljs-keyword">while</span>循环 循环条件用于区分区间长度<br></code></pre></td></tr></table></figure><p>剑指offerⅡ69</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">符合下列属性的数组 arr 称为 山峰数组（山脉数组） ：<br><br>arr.length &gt;= 3<br>存在 i（0 &lt; i &lt; arr.length - 1）使得：<br>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] <br>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]<br>给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：arr = [0,1,0]<br>输出：1<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,end = n-<span class="hljs-number">1</span>,res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt;= end)&#123;<br>            <span class="hljs-comment">//区间小于等于2的先处理掉</span><br>            <span class="hljs-keyword">if</span>(end-begin &lt;= <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> Math.max(arr[begin],arr[end]);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> begin + (end-begin)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid-<span class="hljs-number">1</span>] &amp;&amp; arr[mid] &gt; arr[mid+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid-<span class="hljs-number">1</span>])&#123;<br>                begin = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                end = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">还是根据二分搜索的模板 用一个<span class="hljs-keyword">while</span>循环来控制区间长度 首先解决了返回条件也就是区间小于等于<span class="hljs-number">2</span> 我们就可以得到最大的那个<br></code></pre></td></tr></table></figure><p>剑指offerⅡ70</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个只包含整数的有序数组 nums ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。<br><br>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [1,1,2,3,3,4,4,8,8]<br>输出: 2<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNonDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            res = res ^ nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">异或秒<br></code></pre></td></tr></table></figure><p>剑指offerⅡ71</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。<br><br>例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。<br><br>也就是说，选取下标 i 的概率为 w[i] / sum(w) <br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：<br>inputs = [&quot;Solution&quot;,&quot;pickIndex&quot;]<br>inputs = [[[1]],[]]<br>输出：<br>[null,0]<br>解释：<br>Solution solution = new Solution([1]);<br>solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] pre;<br>    <span class="hljs-type">int</span> total;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w)</span> &#123;<br>        pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[w.length];<br>        pre[<span class="hljs-number">0</span>] = w[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; w.length; ++i) &#123;<br>            pre[i] = pre[i - <span class="hljs-number">1</span>] + w[i];<br>        &#125;<br>        total = Arrays.stream(w).sum(); <span class="hljs-comment">//6</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pickIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * total) + <span class="hljs-number">1</span>; <span class="hljs-comment">//也可以用Random来生成</span><br>        <span class="hljs-keyword">return</span> binarySearch(x);<br>    &#125;<br><br>    <span class="hljs-comment">//在pre[]里面查找floor(x)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, high = pre.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123; <span class="hljs-comment">//控制区间长度最小为2</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (high - low) / <span class="hljs-number">2</span> + low;<br>            <span class="hljs-keyword">if</span> (pre[mid] &lt; x) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid; <span class="hljs-comment">//因为mid有可能就是floor所以要加进去 用这种方式可以实现偶数除以2 也就是 区间长度为4只能变到2</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">本题很巧妙的将概率题变为一道二分题 当然还是得用到随机数啦 <br>也是顺便复习一下随机数的知识：<br>1.两种生成方式 Math.random() Random random <br>2.左闭右开<br>用前缀和的方式将权重转为值，非常巧妙，最后就是一个floor的二分查找<br>这里也是控制区间最小长度，然后用high = mid 实现偶数除以2 也就是 区间长度为4只能变到2<br><br>二分总结：<br>1.区间长度由while循环来控制<br>2.区间缩减规则由是否带上mid来控制<br>3.边界条件有两个一个是直接跳出while循环 一个是while循环中区间长度为1和2的情况<br></code></pre></td></tr></table></figure><p>剑指offerⅡ72</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个非负整数 x ，计算并返回 x 的平方根，即实现 int sqrt(int x) 函数。<br><br>正数的平方根有两个，只输出其中的正数平方根。<br><br>如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。<br> <br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: x = 4<br>输出: 2<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt;= end &amp;&amp; begin &gt;= <span class="hljs-number">0</span> &amp;&amp; end &gt;= <span class="hljs-number">0</span>)&#123;<br>            mid = begin + (end - begin)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)mid * mid &lt;= x)&#123;<br>                res = mid;<br>                begin = mid + <span class="hljs-number">1</span>; <br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                end = mid-<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">本题是一道水题 还是边界条件的控制问题，这里也顺便复习了一下大整数的处理方法 可用强转为long来比较<br></code></pre></td></tr></table></figure><p>剑指offerⅡ73</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">狒狒喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。<br><br>狒狒可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。  <br><br>狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。<br><br>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。<br> <br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：piles = [3,6,7,11], h = 8<br>输出：4<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> piles.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; len; i++)&#123;<br>            high = Math.max(high, piles[i]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (low+high)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(getTime(piles, middle) &gt; h)&#123;<br>                low = middle+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                high = middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> pile : piles)&#123;<br>            sum += pile/k;<br>            <span class="hljs-keyword">if</span>(pile%k != <span class="hljs-number">0</span>)&#123;<br>                sum += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">我只能说 凡是你觉得只能暴力遍历的题 首先要想到的就是二分<br></code></pre></td></tr></table></figure><p>剑指offerⅡ74</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。<br> <br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-type">MyComparator</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComparator</span>();<br>        Arrays.sort(intervals,m);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> intervals.length; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len; i++)&#123;<br>            <span class="hljs-comment">//先确定左边界</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> intervals[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j &lt; len;j++)&#123;<br>                <span class="hljs-keyword">if</span>(right &lt; intervals[j][<span class="hljs-number">0</span>])&#123;<br>                    i = j-<span class="hljs-number">1</span>; <br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(right &lt;= intervals[j][<span class="hljs-number">1</span>])&#123;<br>                    right = intervals[j][<span class="hljs-number">1</span>];            <br>                &#125;<br>                <span class="hljs-keyword">if</span>(j == len-<span class="hljs-number">1</span>)&#123;<br>                    i = j + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left,right&#125;); <br>        &#125;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size();i++)&#123;<br>            res[i] = list.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] i1, <span class="hljs-type">int</span>[] i2)</span> &#123;<br><span class="hljs-keyword">return</span> i1[<span class="hljs-number">0</span>]-i2[<span class="hljs-number">0</span>];<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题我怎么感觉之前写过 <br>首先我们对给的数组重新排序 按照第一个数进行排序<br>然后感觉有点像单调栈的思路 维护左边界，去拓展右边界 <br>然后就是控制好边界条件就行。<br></code></pre></td></tr></table></figure><p>剑指offerⅡ76</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">给定两个数组，arr1 和 arr2，<br><br>arr2 中的元素各不相同<br>arr2 中的每个元素都出现在 arr1 中<br>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]<br>输出：[2,2,2,1,4,3,3,9,6,7,19]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] relativeSortArray(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr2.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            map.put(arr2[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(arr1).boxed().sorted((i1, i2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(i1) &amp;&amp; map.containsKey(i2)) &#123;<br>                <span class="hljs-keyword">return</span> map.get(i1) - map.get(i2);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.containsKey(i1)) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.containsKey(i2)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> i1 - i2;<br>            &#125;<br>        &#125;).mapToInt(Integer::valueOf).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">思路我都懂 就是这个自定义排序有点难写<br></code></pre></td></tr></table></figure><p>剑指offerⅡ76</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br><br>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]<br>输出：[2,2,2,1,4,3,3,9,6,7,19]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer m, Integer n)</span> &#123;<br>                <span class="hljs-keyword">return</span> m -n ;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(queue.size() == k)&#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; queue.peek()) &#123;<br>                    queue.poll();<br>                    queue.offer(nums[i]);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                queue.offer(nums[i]);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题求出前k大就是之前的优先级队列实现大小根堆的方法 <br>前k大就是小根堆<br>前k小就是大根堆<br></code></pre></td></tr></table></figure><p>剑指offerⅡ77</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。<br><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：head = [4,2,1,3]<br>输出：[1,2,3,4]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            list.add(head.val);<br>            head = head.next;<br>        &#125;<br>        list.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer m,Integer n)</span>&#123;<br>                <span class="hljs-keyword">return</span> m-n;<br>            &#125;<br>        &#125;);<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span>list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> newHead;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt; list.size();i++)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(list.get(i));<br>            pre.next = newNode;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">确实是一道水题 直接将链表的值存入list里面排序就行<br></code></pre></td></tr></table></figure><p>剑指offerⅡ78</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个链表数组，每个链表都已经按升序排列。<br><br>请将所有链表合并到一个升序链表中，返回合并后的链表。<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        List&lt;Integer&gt; myList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(ListNode list: lists)&#123;<br>            <span class="hljs-keyword">while</span>(list!=<span class="hljs-literal">null</span>)&#123;<br>                System.out.println(list.val);<br>                myList.add(list.val);<br>                list = list.next;<br>            &#125;<br>        &#125;<br>        myList.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer m,Integer n)</span>&#123;<br>                <span class="hljs-keyword">return</span> m-n;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">if</span>(myList.size() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(myList.get(<span class="hljs-number">0</span>));<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;myList.size();i++)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(myList.get(i));<br>            pre.next = node;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">还是一道水题 直接将链表的值存入list里面排序就行<br></code></pre></td></tr></table></figure><p>剑指offerⅡ79</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<br><br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        res.add(list);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> res.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span> ;j &lt; num;j++)&#123;<br>                List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                newList.addAll(res.get(j));<br>                newList.add(nums[i]);<br>                res.add(newList);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题用到了数学上的知识 不难 复习了一下拷贝ArrayList的方法：<br>新的list.addAll(旧的list);<br></code></pre></td></tr></table></figure><p>剑指offerⅡ80</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        dfs(<span class="hljs-number">1</span>, n, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp </span><br>        <span class="hljs-keyword">if</span> (temp.size() + (n - cur + <span class="hljs-number">1</span>) &lt; k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 记录合法的答案</span><br>        <span class="hljs-keyword">if</span> (temp.size() == k) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(temp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 考虑选择当前位置</span><br>        temp.add(cur);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>        temp.remove(temp.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 考虑不选择当前位置</span><br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题可以作为枚举的一个模板来看 其实这种枚举就是一个dfs遍历的过程 只要符合长度就遍历结束，也就是剪枝，dfs有两条路径，一个是选择当前位置一个是不选择当前位置 那么就需要进行回溯。然后我们可以进行推广 凡是这种遍历每个节点有两种或者更多选择的题 我们都可以考虑使用dfs来写<br></code></pre></td></tr></table></figure><p>剑指offerⅡ81</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。<br><br>candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。 <br><br>对于给定的输入，保证和为 target 的唯一组合数少于 150 个。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: candidates = [2,3,6,7], target = 7<br>输出: [[7],[2,2,3]]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] candidates;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> target;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">boolean</span> flag;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.candidates = candidates;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        sum = <span class="hljs-number">0</span>;<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; target || n &gt;= candidates.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum == target &amp;&amp;  flag)&#123;<br>            <br>            System.out.println(n);<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        &#125;<br>        <span class="hljs-comment">//选择当前位置</span><br>        flag = <span class="hljs-literal">true</span>;<br>        sum += candidates[n];<br>        list.add(candidates[n]);<br>        dfs(n);<br>        <span class="hljs-comment">//不选择当前位置</span><br>        flag = <span class="hljs-literal">false</span>;<br>        sum -= candidates[n];<br>        list.remove(list.size()-<span class="hljs-number">1</span>);<br>        dfs(n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题还是dfs + 回溯 + 减枝的题 <br></code></pre></td></tr></table></figure><p>剑指offerⅡ82</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个可能有重复数字的整数数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br><br>candidates 中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。 <br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>输出:<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> candidates.length;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// 关键步骤</span><br>        Arrays.sort(candidates);<br><br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(len);<br>        dfs(candidates, len, <span class="hljs-number">0</span>, target, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidates 候选数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> len        冗余变量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> begin      从候选数组的 begin 位置开始搜索</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target     表示剩余，这个值一开始等于 target，基于题目中说明的&quot;所有数字（包括目标数）都是正整数&quot;这个条件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path       从根结点到叶子结点的路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> res</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin; i &lt; len; i++) &#123;<br>            <span class="hljs-comment">// 大剪枝：减去 candidates[i] 小于 0，减去后面的 candidates[i + 1]、candidates[i + 2] 肯定也小于 0，因此用 break</span><br>            <span class="hljs-keyword">if</span> (target - candidates[i] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 小剪枝：同一层相同数值的结点，从第 2 个开始，候选数更少，结果一定发生重复，因此跳过，用 continue</span><br>            <span class="hljs-keyword">if</span> (i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.addLast(candidates[i]);<br>            <span class="hljs-comment">// 调试语句 ①</span><br>            <span class="hljs-comment">// System.out.println(&quot;递归之前 =&gt; &quot; + path + &quot;，剩余 = &quot; + (target - candidates[i]));</span><br><br>            <span class="hljs-comment">// 因为元素不可以重复使用，这里递归传递下去的是 i + 1 而不是 i</span><br>            dfs(candidates, len, i + <span class="hljs-number">1</span>, target - candidates[i], path, res);<br><br>            path.removeLast();<br>            <span class="hljs-comment">// 调试语句 ②</span><br>            <span class="hljs-comment">// System.out.println(&quot;递归之后 =&gt; &quot; + path + &quot;，剩余 = &quot; + (target - candidates[i]));</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] candidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        List&lt;List&lt;Integer&gt;&gt; res = solution.combinationSum2(candidates, target);<br>        System.out.println(<span class="hljs-string">&quot;输出 =&gt; &quot;</span> + res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这个确实太强了 暂时没完全搞懂 挖个坑 后面再填<br></code></pre></td></tr></table></figure><p>剑指offerⅡ83</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。 <br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; rest = Arrays.stream(nums).boxed().collect(Collectors.toList());<br>        dfs(list,rest);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; list,List&lt;Integer&gt; rest)</span>&#123;<br>        <span class="hljs-keyword">if</span>(rest.isEmpty())&#123;<br>            ans.add(list);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> rest.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> rest.get(i);<br>            List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list);<br>            newList.add(num);<br>            rest.remove(i);<br>            dfs(newList,rest);<br>            rest.add(i,num);<br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">和之前几道题一样，是典型的递归问题,这道题我们可以学到以下几点<br>1.首先是Arrays.stream(nums).boxed().collect(Collectors.toList());这个是int[]转ArrayList的方法 <br>2.对于递归我们可以先在脑海里想好递归树，是如何递归下去 其实这种递归也就是dfs 但是需要回溯<br>  本题的递归就是dfs带参下潜的过程 注意：List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(list);这里最好用一个新的list下潜<br>  最后的回溯过程就是左老师说的清理现场的过程，只需要将rest里面的数据复原即可<br></code></pre></td></tr></table></figure><p>剑指offerⅡ84</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个可包含重复数字的整数集合 nums ，按任意顺序 返回它所有不重复的全排列。 <br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>         List&lt;Integer&gt; rest = Arrays.stream(nums).boxed().collect(Collectors.toList());<br>        dfs(path,rest);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; path,List&lt;Integer&gt; rest)</span>&#123;<br>        <span class="hljs-keyword">if</span>(rest.isEmpty())&#123;<br>            ans.add(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> rest.size();<br>        <span class="hljs-type">boolean</span>[] flags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">25</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> rest.get(i);<br>            <span class="hljs-keyword">if</span>(!flags[num+<span class="hljs-number">10</span>])&#123;<br>                List&lt;Integer&gt; newPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path);<br>                newPath.add(num);<br>                rest.remove(i);<br>                dfs(newPath,rest);<br>                flags[num+<span class="hljs-number">10</span>] = <span class="hljs-literal">true</span>;<br>                rest.add(i,num);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">和上一道题一样，是典型的递归问题<br>所不同之处在于本题需要对多叉树每一节点的值进行去重 也就是说如果当前层每个数字我只能选一次，也就是说如果不同枝是相同数字，那么我们需要剪纸，否则会出现重复的情况<br></code></pre></td></tr></table></figure><p>剑指offerⅡ85</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">正整数 n 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 <br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：n = 3<br>输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">restl</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">restr</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        path = path +  <span class="hljs-string">&#x27;(&#x27;</span>;<br>        --restl;<br>        dfs(restl,restr,path,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> restl,<span class="hljs-type">int</span> restr,String path,<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-keyword">if</span>(restr == <span class="hljs-number">0</span> &amp;&amp;  restl == <span class="hljs-number">0</span>)&#123;<br>            ans.add(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//匹配完但没完全匹配完 剪枝头</span><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newString</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;(&#x27;</span>;<br>            dfs(restl-<span class="hljs-number">1</span>,restr,newString,<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(restl &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">newString</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;(&#x27;</span>;<br>                dfs(restl-<span class="hljs-number">1</span>,restr,newString,num+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newString</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;)&#x27;</span>;<br>            dfs(restl,restr-<span class="hljs-number">1</span>,newString,num-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">和上一道题一样，是典型的递归问题<br>所不同之处在于本题需要对多叉树每一节点的值进行去重 也就是说如果当前层每个数字我只能选一次，也就是说如果不同枝是相同数字，那么我们需要剪纸，否则会出现重复的情况<br></code></pre></td></tr></table></figure><p>剑指offerⅡ86</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个字符串 s ，请将 s 分割成一些子串，使每个子串都是 回文串 ，返回 s 所有可能的分割方案。<br><br>回文串 是正着读和反着读都一样的字符串。<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：s = &quot;google&quot;<br>输出：[[&quot;g&quot;,&quot;o&quot;,&quot;o&quot;,&quot;g&quot;,&quot;l&quot;,&quot;e&quot;],[&quot;g&quot;,&quot;oo&quot;,&quot;g&quot;,&quot;l&quot;,&quot;e&quot;],[&quot;goog&quot;,&quot;l&quot;,&quot;e&quot;]]<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; solutions; <span class="hljs-comment">// 所有分割方案</span><br>    List&lt;String&gt; solution; <span class="hljs-comment">// 当前分割方案</span><br>    <span class="hljs-type">boolean</span>[][] dp;<br>    <span class="hljs-type">int</span> n;<br>    String s;<br>    <span class="hljs-keyword">public</span> String[][] partition(String s) &#123;<br>        <span class="hljs-built_in">this</span>.n = s.length();<br>        <span class="hljs-built_in">this</span>.s = s;<br>        <span class="hljs-built_in">this</span>.solutions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-built_in">this</span>.solution = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        getDPMatrix(); <span class="hljs-comment">// 计算dp数组</span><br>        backtrack(<span class="hljs-number">0</span>); <span class="hljs-comment">// 回溯求解</span><br>        String[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[solutions.size()][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.length; i++)&#123; <span class="hljs-comment">// 转换输出</span><br>            List&lt;String&gt; solution = solutions.get(i);<br>            res[i] = solution.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[solution.size()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDPMatrix</span><span class="hljs-params">()</span>&#123;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 边界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123; <span class="hljs-comment">// 边界</span><br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>            dp[i - <span class="hljs-number">1</span>][i] = s.charAt(i - <span class="hljs-number">1</span>) == s.charAt(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123; <span class="hljs-comment">// 自底向上对右上三角区域递推</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">2</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == n) &#123;<br>            solutions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(solution));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i][j])&#123;<br>                solution.add(s.substring(i, j + <span class="hljs-number">1</span>));<br>                backtrack(j + <span class="hljs-number">1</span>);<br>                solution.remove(solution.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">和上一道题一样，是典型的递归问题<br>所不同之处在于本题需要对多叉树每一节点的值进行去重 也就是说如果当前层每个数字我只能选一次，也就是说如果不同枝是相同数字，那么我们需要剪纸，否则会出现重复的情况<br></code></pre></td></tr></table></figure><p>剑指offerⅡ98</p><hr><p><strong>题目描述</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br><br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br><br>问总共有多少条不同的路径？<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：m = 3, n = 7<br>输出：28<br></code></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            f[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题可以说是dp里面的经典题 f[i][j] = f[i - 1][j] + f[i][j - 1];就是转移方程 根据状态转移方程正向求解比反向递归速度快很多<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>/学习/算法/做题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
