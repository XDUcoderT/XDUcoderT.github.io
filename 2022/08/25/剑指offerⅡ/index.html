

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Tao Chen">
  <meta name="keywords" content="">
  
    <meta name="description" content="剑指offerⅡ05 题目描述 1给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。 实例 123输入: words &#x3D; [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;b">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offerⅡ">
<meta property="og:url" content="http://example.com/2022/08/25/%E5%89%91%E6%8C%87offer%E2%85%A1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="剑指offerⅡ05 题目描述 1给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。 实例 123输入: words &#x3D; [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;b">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-25T12:24:57.558Z">
<meta property="article:modified_time" content="2022-11-12T08:05:14.116Z">
<meta property="article:author" content="Tao Chen">
<meta property="article:tag" content="刷题">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>剑指offerⅡ - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>晨の私密花园</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="剑指offerⅡ"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-25 20:24" pubdate>
          2022年8月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          78k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          652 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">剑指offerⅡ</h1>
            
            
              <div class="markdown-body">
                
                <p>剑指offerⅡ05</p>
<p><strong>题目描述</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">给定一个字符串数组 <span class="hljs-built_in">words</span>，请计算当两个字符串 <span class="hljs-built_in">words</span>[i] 和 <span class="hljs-built_in">words</span>[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;abcw&quot;</span>,<span class="hljs-string">&quot;baz&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;fxyz&quot;</span>,<span class="hljs-string">&quot;abcdef&quot;</span>]<br>输出: <span class="hljs-number">16</span> <br>解释: 这两个单词为 <span class="hljs-string">&quot;abcw&quot;</span>, <span class="hljs-string">&quot;fxyz&quot;</span>。它们不包含相同字符，且长度的乘积最大。<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> maxProduct(String[] words) &#123;<br>        //利用位掩码 <br>        // 如果有相同的字母与完返回就不是<span class="hljs-number">0</span><br>        <span class="hljs-type">int</span> wordsLen = words.length;<br>        <span class="hljs-type">int</span>[] mask = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[wordsLen];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; wordsLen; i++)&#123;<br>            <span class="hljs-type">int</span> letterLen = words[i].length();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; letterLen ; j++)&#123;<br>                <span class="hljs-type">int</span> loc = words[i].charAt(j) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span> &lt;&lt; loc) &amp; mask[i]) == <span class="hljs-number">0</span>)&#123;<br>                    mask[i] += (<span class="hljs-number">1</span> &lt;&lt; loc);<br>                &#125;<br>            &#125;    <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; wordsLen ; i++)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(mask[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> maxProd = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; wordsLen ; i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ;j &lt; wordsLen ;j++)&#123;<br>               <span class="hljs-keyword">if</span>((mask[i] &amp; mask[j]) == <span class="hljs-number">0</span>)&#123;<br>                   maxProd = words[i].length() * words[j].length() &gt; maxProd ? words[i].length() * words[j].length() : maxProd;<br>                &#125;<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProd;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题主要就是考察判断两个字符串中是否有相同字母<br>利用与运算快速实现<br></code></pre></td></tr></table></figure>


<hr>
<p>剑指offerⅡ06</p>
<p><strong>题目描述</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。<br><br>函数应该以长度为 <span class="hljs-number">2</span> 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 <span class="hljs-number">0</span> 开始计数 ，所以答案数组应当满足 <span class="hljs-number">0</span> &lt;= answer<span class="hljs-selector-attr">[0]</span> &lt; answer<span class="hljs-selector-attr">[1]</span> &lt; numbers<span class="hljs-selector-class">.length</span> 。<br><br>假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。<br>输入：numbers = <span class="hljs-selector-attr">[1,2,4,6,10]</span>, target = <span class="hljs-number">8</span><br>输出：<span class="hljs-selector-attr">[1,3]</span><br>解释：<span class="hljs-number">2</span> 与 <span class="hljs-number">6</span> 之和等于目标数 <span class="hljs-number">8</span> 。因此 index1 = <span class="hljs-number">1</span>, index2 = <span class="hljs-number">3</span> 。<br><br></code></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：numbers = [1,2,4,6,10], target = 8<br>输出：[1,3]<br>解释：2 与<span class="hljs-number"> 6 </span>之和等于目标数<span class="hljs-number"> 8 </span>。因此 index1 = 1, index2 =<span class="hljs-number"> 3 </span>。<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length; ++i) &#123;<br>            <span class="hljs-keyword">int</span> low = i + <span class="hljs-number">1</span>, high = numbers.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//这里只需要找一个，所以小于等于</span><br>            <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>                <span class="hljs-keyword">int</span> mid = (high - low) / <span class="hljs-number">2</span> + low;<br>                <span class="hljs-keyword">if</span> (numbers[mid] == <span class="hljs-keyword">target</span> - numbers[i]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, mid&#125;;<br>                &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(numbers[mid] &gt; <span class="hljs-keyword">target</span> - numbers[i])</span> </span>&#123;<br>                    high = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    low = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用二分查找，注意边界条件的控制<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ07</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 <span class="hljs-selector-tag">a</span> ，<span class="hljs-selector-tag">b</span> ，c ，使得 <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> + c = <span class="hljs-number">0</span> ？请找出所有和为 <span class="hljs-number">0</span> 且 不重复 的三元组。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,0,1,2,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>]<br>输出：[[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,2],[<span class="hljs-string">-1</span>,0,1]]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// 不能重复使用</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 排序--升序 -- 归并排序</span><br><span class="hljs-comment">        2. 固定一个值 -- for 0 ~ lens-3</span><br><span class="hljs-comment">        3. 剩下2个值在右区间进行双指针 -- 参考前题</span><br><span class="hljs-comment">        4. 考虑重复组合的问题 -- 去重，有两种重复情况</span><br><span class="hljs-comment">            1. 第一个固定的值存在重复</span><br><span class="hljs-comment">            2. 第二第三个值的组合存在重复</span><br><span class="hljs-comment">         */</span><br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 排序</span><br>        Arrays.sort(nums);<br><br>        <span class="hljs-comment">// 遍历固定第一个值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length<span class="hljs-number">-2</span>; i++) &#123;<br>            <span class="hljs-comment">// 解决第一个固定值重复的问题</span><br>            <span class="hljs-comment">// 例如排序后的[-4,-1,-1,0,1,2] -1,-1处存在首数字重复</span><br>            <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> curTarget = -nums[i];<br>            <span class="hljs-built_in">int</span> left = i+<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> right = nums.length<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span> (right&gt;left) &#123;<br>                <span class="hljs-built_in">int</span> tmpSum = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (tmpSum &gt; curTarget)<br>                    right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmpSum &lt; curTarget)<br>                    left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                    list.<span class="hljs-keyword">add</span>(nums[i]);<br>                    list.<span class="hljs-keyword">add</span>(nums[left]);<br>                    list.<span class="hljs-keyword">add</span>(nums[right]);<br>                    res.<span class="hljs-keyword">add</span>(list);<br><br>                    <span class="hljs-comment">// 解决第二第三个固定值重复的问题</span><br>                    <span class="hljs-comment">// 例如排序后的[-2,0,0,2,2] -2固定下，0，0，2，2会重复组合出0,2</span><br>                    <span class="hljs-comment">// 短路运算，第一个条件保证大前提，第二个语句运用前置++运算符更新指针</span><br>                    <span class="hljs-keyword">while</span> (left&lt;right &amp;&amp; nums[left]==nums[++left]);<br>                    <span class="hljs-keyword">while</span> (left&lt;right &amp;&amp; nums[right]==nums[--right]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这道题是三元和 还是利用固定法，另外两个的和我们要保证遍历不重不漏，所以利用前后双指针遍历<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ08</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">给定一个含有 n 个正整数的数组和一个正整数 <span class="hljs-keyword">target</span> 。<br><br>找出该数组中满足其和 ≥ <span class="hljs-keyword">target</span> 的长度最小的 连续子数组 [numsl, numsl+<span class="hljs-number">1</span>, ..., numsr<span class="hljs-number">-1</span>, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 <span class="hljs-number">0</span> 。<br><br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> minSubArrayLen(<span class="hljs-built_in">int</span> s, <span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-keyword">Integer</span>.MAX_VALUE;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>, <span class="hljs-keyword">end</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">end</span> &lt; n) &#123;<br>            // 每次右指针先往右移动一位<br>            // 然后让左指针向右移动直到不符合题意为止<br>            <span class="hljs-built_in">sum</span> += nums[<span class="hljs-keyword">end</span>];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">sum</span> &gt;= s) &#123;<br>                ans = Math.<span class="hljs-built_in">min</span>(ans, <span class="hljs-keyword">end</span> - start + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">sum</span> -= nums[start];<br>                start++;<br>            &#125;<br>            <span class="hljs-keyword">end</span>++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == <span class="hljs-keyword">Integer</span>.MAX_VALUE ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用滑动窗口的思路，先向右移动右指针直到满足条件，然后向右移动左指针，直到满足条件，然后继续移动右指针，依此循环<br>“右定左动”<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ09</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[10,5,2,6]</span>, k = 100<br>输出: 8<br>解释: 8 个乘积小于 100 的子数组分别为: <span class="hljs-comment">[10]</span>, <span class="hljs-comment">[5]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[6]</span>, <span class="hljs-comment">[10,5]</span>, <span class="hljs-comment">[5,2]</span>, <span class="hljs-comment">[2,6]</span>, <span class="hljs-comment">[5,2,6]</span>。<br>需要注意的是 <span class="hljs-comment">[10,5,2]</span> 并不是乘积小于100的子数组。<br><br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>    public <span class="hljs-type">int</span> numSubarrayProductLessThanK(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> n = nums.length, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">prod</span> = <span class="hljs-number">1</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-built_in">prod</span> *= nums[j];<br>            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; <span class="hljs-built_in">prod</span> &gt;= k) &#123;<br>                <span class="hljs-built_in">prod</span> /= nums[i];<br>                i++;<br>            &#125;<br>            ret += j - i + <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用滑动窗口的思路，先向右移动右指针直到满足条件，然后向右移动左指针，直到满足条件，然后继续移动右指针，依此循环<br>“右定左动”<br></code></pre></td></tr></table></figure>





<p>剑指offerⅡ10</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入:nums = <span class="hljs-comment">[1,1,1]</span>, k = 2<br>输出: 2<br>解释: 此题 <span class="hljs-comment">[1,1]</span> 与 <span class="hljs-comment">[1,1]</span> 为两种不同的情况<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> subarraySum(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer,Integer&gt; mp = <span class="hljs-keyword">new</span> HashMap &lt; &gt; ();<br>        mp.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//pre记录前缀和的值</span><br>            pre += nums[i];<br>            <span class="hljs-comment">//每次查看前面有没有满足条件的pre[j]</span><br>            <span class="hljs-keyword">if</span> (mp.containsKey(pre - k)) &#123;<br>                <span class="hljs-keyword">count</span> += mp.get(pre - k);<br>            &#125;<br>            mp.put(pre, mp.getOrDefault(pre, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用了前缀和 + 哈希表的经典搭配 就是以和为键，以次数为值，构造哈希表<br><br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ11</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个二进制数组 nums , 找到含有相同数量的<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 1 </span>的最长连续子数组，并返回该子数组的长度。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [0,1]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> findMaxLength(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        HashMap&lt;<span class="hljs-type">Integer</span>,<span class="hljs-type">Integer</span>&gt; hp = <span class="hljs-built_in">new</span> HashMap&lt;<span class="hljs-type">Integer</span>,<span class="hljs-type">Integer</span>&gt;();<br>        hp.put(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i&lt; nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> num = nums[i];<br>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br>                res++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> res<span class="hljs-comment">--;</span><br>            <span class="hljs-keyword">if</span>(hp.containsKey(res))&#123;<br>                <span class="hljs-type">int</span> newLen = i - hp.<span class="hljs-keyword">get</span>(res);<br>                maxLen = Math.max(maxLen,newLen);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                hp.put(res,i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这道题利用了前缀和 + 哈希表的经典搭配 以值为键，以下标为值<br><br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ12</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给你一个整数数组 nums ，请计算数组的 中心下标 。<br><br>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。<br><br>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。<br><br>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 <span class="hljs-string">-1</span> 。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,7,3,6,5,6]<br>输出：3<br>解释：<br>中心下标是<span class="hljs-number"> 3 </span>。<br>左侧数之和 sum = nums[0] + nums[1] + nums[2] =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 11 </span>，<br>右侧数之和 sum = nums[4] + nums[5] =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 11 </span>，二者相等。<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> pivotIndex(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> length = nums.length;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span> ;i&lt; length ;i++)&#123;<br>            <span class="hljs-keyword">sum</span> += nums[i];<br>        &#125;<br>        <span class="hljs-built_in">int</span> leftSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span> == nums[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span> ;i&lt; length<span class="hljs-number">-1</span> ;i++)&#123;<br>            leftSum += nums[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span> * leftSum + nums[i] == <span class="hljs-keyword">sum</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span> == nums[length<span class="hljs-number">-1</span>]) <span class="hljs-keyword">return</span> length<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题比较简单，直接前缀和遍历<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ14</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">给定两个字符串 <span class="hljs-built_in">s1</span> 和 <span class="hljs-built_in">s2</span>，写一个函数来判断 <span class="hljs-built_in">s2</span> 是否包含 <span class="hljs-built_in">s1</span> 的某个变位词。<br><br>换句话说，第一个字符串的排列之一是第二个字符串的 子串 。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入: <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;ab&quot;</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;eidbaooo&quot;</span><br>输出: True<br>解释: <span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">&quot;ba&quot;</span>).<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(<span class="hljs-type">String</span> s1, <span class="hljs-type">String</span> s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">length</span>(), m = s2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (n &gt; m) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 比较两个字符串映射数组</span><br>        <span class="hljs-comment">// 利用Arrays.equals比较</span><br>        <span class="hljs-type">int</span>[] cnt1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] cnt2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">// 先比较前n个是否相等</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ++cnt1[s1.<span class="hljs-built_in">charAt</span>(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            ++cnt2[s2.<span class="hljs-built_in">charAt</span>(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Arrays.<span class="hljs-built_in">equals</span>(cnt1, cnt2)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从n+1开始进1出1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &lt; m; ++i) &#123;<br>            ++cnt2[s2.<span class="hljs-built_in">charAt</span>(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --cnt2[s2.<span class="hljs-built_in">charAt</span>(i - n) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (Arrays.<span class="hljs-built_in">equals</span>(cnt1, cnt2)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">本题利用维护滑动窗口，保证窗口长度固定为<span class="hljs-built_in">s1</span>的长度<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ15</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个字符串 s 和 <span class="hljs-selector-tag">p</span>，找到 s 中所有 <span class="hljs-selector-tag">p</span> 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br><br>变位词 指字母相同，但排列不同的字符串。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的变位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的变位词。<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; findAnagrams(String s, String p) &#123;<br>        List&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> length1 = s.length();<br>        <span class="hljs-type">int</span> length2 = p.length();<br>        <span class="hljs-keyword">if</span>(length1 &lt; length2) <span class="hljs-keyword">return</span> list;<br>        <span class="hljs-type">int</span>[] mask1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] mask2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; length2 ;i++)&#123;<br>            mask1[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++ ;<br>            mask2[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++ ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(mask1,mask2))&#123;<br>            list.<span class="hljs-keyword">add</span>(<span class="hljs-number">0</span>);   <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = length2;i &lt; length1 ;i++)&#123;<br>            mask1[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++ ;<br>            mask1[s.charAt(i - length2) - <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">--;</span><br>            <span class="hljs-keyword">if</span>(Arrays.equals(mask1,mask2))&#123;<br>                list.<span class="hljs-keyword">add</span>(i-length2+<span class="hljs-number">1</span>);   <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">本题和上题一致，利用维护滑动窗口，保证窗口长度固定为<span class="hljs-selector-tag">p</span>的长度，然后进一出一来遍历<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ16</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。<br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子字符串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLongestSubstring(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-comment">// 哈希集合，记录每个字符是否出现过</span><br>        Set&lt;Character&gt; occ = <span class="hljs-keyword">new</span> HashSet&lt;Character&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> n = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br>        <span class="hljs-built_in">int</span> rk = -<span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;                                                                           <br>                <span class="hljs-comment">// 左指针向右移动一格，移除一个字符</span><br>                occ.remove(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span> - 1)</span>);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (rk + <span class="hljs-number">1</span> &lt; n<span class="hljs-operator"> &amp;&amp; </span>!occ.contains(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">rk</span> + 1)</span>)) &#123;<br>                <span class="hljs-comment">// 不断地移动右指针</span><br>                occ.add(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">rk</span> + 1)</span>);<br>                ++rk;<br>            &#125;<br>            <span class="hljs-comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span><br>            ans = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(ans, rk - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题运用滑动窗口，左定右动<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ17</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定两个字符串 s 和 <span class="hljs-built_in">t</span> 。返回 s 中包含 <span class="hljs-built_in">t</span> 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 <span class="hljs-string">&quot;&quot;</span> 。<br><br>如果 s 中存在多个符合条件的子字符串，返回任意一个。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span> <br>解释：最短子字符串 <span class="hljs-string">&quot;BANC&quot;</span> 包含了字符串 t 的所有字符 &#x27;A&#x27;、&#x27;B&#x27;、&#x27;C&#x27;<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    Map&lt;Character, Integer&gt; ori = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;<span class="hljs-literal">()</span>;<br>    Map&lt;Character, Integer&gt; cnt = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;<span class="hljs-literal">()</span>;<br><br>    public String min<span class="hljs-constructor">Window(String <span class="hljs-params">s</span>, String <span class="hljs-params">t</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> tLen = t.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; tLen; i++) &#123;<br>            <span class="hljs-built_in">char</span> c = t.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>;<br>            ori.put(c, ori.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">c</span>, 0)</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> len = Integer.MAX_VALUE, ansL = -<span class="hljs-number">1</span>, ansR = -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> sLen = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; sLen) &#123;<br>            ++r;<br>            <span class="hljs-keyword">if</span> (r &lt; sLen<span class="hljs-operator"> &amp;&amp; </span>ori.contains<span class="hljs-constructor">Key(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">r</span>)</span>)) &#123;<br>                cnt.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">r</span>)</span>, cnt.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">r</span>)</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (check<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>l &lt;= r) &#123;<br>                <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; len) &#123;<br>                    len = r - l + <span class="hljs-number">1</span>;<br>                    ansL = l;<br>                    ansR = l + len;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ori.contains<span class="hljs-constructor">Key(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">l</span>)</span>)) &#123;<br>                    cnt.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">l</span>)</span>, cnt.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">l</span>)</span>, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                &#125;<br>                ++l;<br>            &#125;<br>        &#125;<br>        return ansL<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.substring(ansL, ansR);<br>    &#125;<br><br>    public boolean check<span class="hljs-literal">()</span> &#123;<br>        Iterator iter = ori.entry<span class="hljs-constructor">Set()</span>.iterator<span class="hljs-literal">()</span>; <br>        <span class="hljs-keyword">while</span> (iter.has<span class="hljs-constructor">Next()</span>) &#123; <br>            Map.Entry entry = (Map.Entry) iter.next<span class="hljs-literal">()</span>; <br>            Character key = (Character) entry.get<span class="hljs-constructor">Key()</span>; <br>            Integer <span class="hljs-keyword">val</span> = (Integer) entry.get<span class="hljs-constructor">Value()</span>; <br>            <span class="hljs-keyword">if</span> (cnt.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">key</span>, 0)</span> &lt; <span class="hljs-keyword">val</span>) &#123;<br>                return <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <br>        return <span class="hljs-literal">true</span>; <br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">本题还是经典的滑动窗口，右定左动（一般取最小值是右定左动，最大值是左定右动）<br>本题的右定左动中<span class="hljs-string">&quot;左动&quot;</span>的条件判断条件上比较复杂，需要比较两个<span class="hljs-built_in">map</span>的值<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ18</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个字符串 s ，验证 s 是否是 回文串 ，只考虑字母和数字字符，可以忽略字母的大小写。<br><br>本题中，将空字符串定义为有效的 回文串 。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;amanaplanacanalpanama&quot;</span> 是回文串<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public boolean is<span class="hljs-constructor">Palindrome(String <span class="hljs-params">s</span>)</span> &#123;<br>        s = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;<br>        <span class="hljs-built_in">int</span> length = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">begin</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">end</span> = length-<span class="hljs-number">1</span>;<br>    <br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!is<span class="hljs-constructor">Ok(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">begin</span>)</span>)<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>                <span class="hljs-keyword">begin</span>++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!is<span class="hljs-constructor">Ok(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">end</span>)</span>)<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-keyword">begin</span> &lt;<span class="hljs-keyword">end</span>)&#123;<br>                <span class="hljs-keyword">end</span>--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">begin</span>)</span>!=s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">end</span>)</span>)&#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-keyword">begin</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">end</span>);<br>                return <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">begin</span>++;<br>            <span class="hljs-keyword">end</span>--;<br>        &#125;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    public boolean is<span class="hljs-constructor">Ok(<span class="hljs-params">char</span> <span class="hljs-params">c</span>)</span>&#123;<br>        return ((c &gt;= <span class="hljs-character">&#x27;0&#x27;</span><span class="hljs-operator"> &amp;&amp; </span>c &lt;= <span class="hljs-character">&#x27;9&#x27;</span>)<span class="hljs-operator"> || </span>(c &gt;= <span class="hljs-character">&#x27;a&#x27;</span><span class="hljs-operator"> &amp;&amp; </span>c &lt;= <span class="hljs-character">&#x27;z&#x27;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br>本题比较水，对于大小写不敏感的题我们直接用<span class="hljs-built_in">str</span>.toLowerCase将其全部转为小写<br>注意一下边界就行<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ19</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个非空字符串 s，请判断如果 最多 从字符串中删除一个字符能否得到一个回文字符串。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aba&quot;</span><br>输出: <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//对于是否满足类体型 中间需要分条件的情况，而且无法简单进行条件判断，可以考虑将多种情况并一下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(s,<span class="hljs-number">0</span>,s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>,<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">String</span> s,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">boolean</span> flag)</span></span>&#123; <span class="hljs-comment">// flag标识只有一次机会</span><br>        <span class="hljs-keyword">while</span> (i&lt;j)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">charAt</span>(i)!=s.<span class="hljs-built_in">charAt</span>(j))&#123;<br>                <span class="hljs-keyword">if</span>(!flag)&#123;<br>                    <span class="hljs-comment">// 已经去掉一个了，失败</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">// 左边去掉</span><br>                <span class="hljs-type">boolean</span> b1 = <span class="hljs-built_in">check</span>(s, i, j - <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// 右边去掉</span><br>                <span class="hljs-type">boolean</span> b2 = <span class="hljs-built_in">check</span>(s, i+<span class="hljs-number">1</span>, j , <span class="hljs-literal">false</span>);<br>                <span class="hljs-keyword">return</span> b1||b2; <span class="hljs-comment">// 有一种成功即可</span><br>            &#125;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题非常经典，是经典的满足题意类问题，对于此类问题中会有分叉的情况，我们可以将多种情况的结果并起来<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ20</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。<br><br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span><br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> count<span class="hljs-constructor">Substrings(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> sum = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length<span class="hljs-literal">()</span>;i++)&#123;<br>           <span class="hljs-built_in">int</span> indexR1 = i + <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">while</span>(indexR1 &lt; s.length<span class="hljs-literal">()</span>)&#123;<br>               <span class="hljs-built_in">int</span> indexL1 = <span class="hljs-number">2</span><span class="hljs-operator"> * </span>i - indexR1;<br>               <span class="hljs-keyword">if</span>(indexL1 &lt; <span class="hljs-number">0</span>)&#123;<br>                   break;<br>               &#125;<br>               <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">indexL1</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">indexR1</span>)</span>)&#123;<br>                   sum++;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   break;<br>               &#125;<br>               indexR1++;<br>            &#125;<br>            <span class="hljs-built_in">int</span> indexR2 = i;<br>            <span class="hljs-keyword">while</span>(indexR2 &lt; s.length<span class="hljs-literal">()</span>)&#123;<br>               <span class="hljs-built_in">int</span> indexL2 = <span class="hljs-number">2</span><span class="hljs-operator"> * </span>i - indexR2 - <span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">if</span>(indexL2 &lt; <span class="hljs-number">0</span>)&#123;<br>                   break;<br>               &#125;<br>               <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">indexL2</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">indexR2</span>)</span>)&#123;<br>                   sum++;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   break;<br>               &#125;<br>               indexR2++;<br>            &#125;<br>        &#125;<br>        return sum;  <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">寻找回文串的个数，中心向左右拓展<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ21</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个链表，删除链表的倒数第 <span class="hljs-built_in">n</span> 个结点，并且返回链表的头结点<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-comment">//计算出链表总长度</span><br>        ListNode list1 = head;<br>        ListNode list2 = head;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>            n--;<br>            list2 = list2.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list2 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> list1.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(list2.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;<br>            list1 = list1.<span class="hljs-keyword">next</span>;<br>            list2 = list2.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        list1.<span class="hljs-keyword">next</span> = list1.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">本题是链表加快慢指针的经典结合，可以转化为找到链表中倒数第k个节点<br>我们甚至可以进一步拓展，链表受限的是“找到后面的忘记前面的”，我们<br>虽然无法完全解决这个问题，想起来前面所有的，但是我们可以让他想起来<br>第前k个节点，就是运用快慢指针！！！<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ22</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp">给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <span class="hljs-keyword">next</span> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。<br><br>为了表示给定链表中的环，我们使用整数 <span class="hljs-keyword">pos</span> 来表示链表尾连接到链表中的位置（索引从 <span class="hljs-number">0</span> 开始）。 如果 <span class="hljs-keyword">pos</span> 是 <span class="hljs-number">-1</span>，则在该链表中没有环。注意，<span class="hljs-keyword">pos</span> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode detectCycle(ListNode head) &#123;<br>        ListNode fastNode = head;<br>        ListNode slowNode = head;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || fastNode.next == <span class="hljs-literal">null</span> || fastNode.next.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fastNode.next != <span class="hljs-literal">null</span> &amp;&amp; fastNode.next.next != <span class="hljs-literal">null</span>)&#123;<br>            fastNode = fastNode.next.next;<br>            slowNode = slowNode.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fastNode != slowNode)&#123;<br>            <span class="hljs-keyword">if</span>(fastNode.next == <span class="hljs-literal">null</span> || fastNode.next.next == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            fastNode = fastNode.next.next;<br>            slowNode = slowNode.next;<br>        &#125;<br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = head;<br>        <span class="hljs-keyword">while</span>(slowNode != <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>)&#123;<br>            slowNode = slowNode.next;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowNode;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题是经典的快慢指针用法，技巧性比较强，看看就行，不必深究<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ25</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。<br><br>可以假设除了数字<span class="hljs-number"> 0 </span>之外，这两个数字都不会以零开头。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[7,2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,8,0,7]</span><br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs xquery">/**<br> * Definition <span class="hljs-keyword">for</span> singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode <span class="hljs-keyword">next</span>;<br> *     ListNode() &#123;&#125;<br> *     ListNode(int val) &#123; this.val = val; &#125;<br> *     ListNode(int val, ListNode <span class="hljs-keyword">next</span>) &#123; this.val = val; this.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>; &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;<br>        l1 = reverseNode(l1);<br>        l2 = reverseNode(l2);<br>        ListNode newNode = l1;<br>        int carry = <span class="hljs-number">0</span>;<br>        int<span class="hljs-built_in"> sum</span> = <span class="hljs-number">0</span>;<br>        while(l1.<span class="hljs-keyword">next</span> != null &amp;&amp; l2.<span class="hljs-keyword">next</span> != null)&#123;<br>           <span class="hljs-built_in"> sum</span> = l1.val + l2.val + carry;<br>            carry =<span class="hljs-built_in"> sum</span> &gt;= <span class="hljs-number">10</span> ?<span class="hljs-built_in"> sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>            l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>            l1 = l1.<span class="hljs-keyword">next</span>;<br>            l2 = l2.<span class="hljs-keyword">next</span>;<br>        &#125;<br>       <span class="hljs-built_in"> sum</span> = l1.val + l2.val + carry;<br>        l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>        carry =<span class="hljs-built_in"> sum</span> &gt;= <span class="hljs-number">10</span> ?<span class="hljs-built_in"> sum</span>/ <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(l1.<span class="hljs-keyword">next</span> == null &amp;&amp; l2.<span class="hljs-keyword">next</span> == null)&#123;<br>            <span class="hljs-keyword">if</span>(carry != <span class="hljs-number">0</span>)&#123;<br>                ListNode <span class="hljs-type">node</span> = new ListNode(carry,null);<br>                l1.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l1.<span class="hljs-keyword">next</span> != null)&#123;<br>            l1 = l1.<span class="hljs-keyword">next</span>;<br>            while(l1.<span class="hljs-keyword">next</span> != null)&#123;<br>               <span class="hljs-built_in"> sum</span> = l1.val + carry;<br>                l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>                carry =<span class="hljs-built_in"> sum</span>&gt;= <span class="hljs-number">10</span> <span class="hljs-built_in">?sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>                l1 = l1.<span class="hljs-keyword">next</span>;<br>            &#125;<br>           <span class="hljs-built_in"> sum</span> = l1.val + carry;<br>            l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>            carry =<span class="hljs-built_in"> sum</span>&gt;= <span class="hljs-number">10</span> <span class="hljs-built_in">?sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(carry != <span class="hljs-number">0</span>)&#123;<br>                ListNode <span class="hljs-type">node</span> = new ListNode(carry,null);<br>                l1.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l1.<span class="hljs-keyword">next</span> = l2.<span class="hljs-keyword">next</span>;<br>            l1 = l1.<span class="hljs-keyword">next</span>;<br>            while(l1.<span class="hljs-keyword">next</span> != null)&#123;<br>               <span class="hljs-built_in"> sum</span> = l1.val + carry;<br>                l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>                carry =<span class="hljs-built_in"> sum</span>&gt;= <span class="hljs-number">10</span> <span class="hljs-built_in">?sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>                l1 = l1.<span class="hljs-keyword">next</span>;<br>            &#125;<br>           <span class="hljs-built_in"> sum</span> = l1.val + carry;<br>            l1.val =<span class="hljs-built_in"> sum</span><span class="hljs-meta">%10</span>;<br>            carry =<span class="hljs-built_in"> sum</span>&gt;= <span class="hljs-number">10</span> <span class="hljs-built_in">?sum</span> / <span class="hljs-number">10</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(carry != <span class="hljs-number">0</span>)&#123;<br>                ListNode <span class="hljs-type">node</span> = new ListNode(carry,null);<br>                l1.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> reverseNode(newNode);<br>    &#125;<br><br>    public ListNode reverseNode(ListNode<span class="hljs-built_in"> head</span>)&#123;<br>       <span class="hljs-keyword">if</span><span class="hljs-built_in">(head</span> == null ||<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> == null)&#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;<br>        &#125;<br>        ListNode pre = null;<br>        ListNode aft = null;<br>        while<span class="hljs-built_in">(head</span> != null)&#123;<br>            aft =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>;<br>           <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = pre;<br>            pre =<span class="hljs-built_in"> head</span>;<br>           <span class="hljs-built_in"> head</span> = aft;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">这道题挺恶心的 链表就是失忆症 走到后面忘了前面 但是整式加法就是要先知道后面的值看看有无进位才能知道前面的值，感觉挺恶心的。<br>所以我就先写一个翻转链表的函数将给定的两个链表翻转，最后再翻转回去<br>然后就是整式加法的模拟，边界条件真的恶心<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ26</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个单链表 L 的头节点 head ，单链表 L 表示为：<br><br><span class="hljs-symbol">L0</span> → <span class="hljs-symbol">L1</span> → … → <span class="hljs-built_in">Ln</span>-<span class="hljs-number">1</span> → <span class="hljs-built_in">Ln</span> <br>请将其重新排列后变为：<br><br><span class="hljs-symbol">L0</span> → <span class="hljs-built_in">Ln</span> → <span class="hljs-symbol">L1</span> → <span class="hljs-built_in">Ln</span>-<span class="hljs-number">1</span> → <span class="hljs-symbol">L2</span> → <span class="hljs-built_in">Ln</span>-<span class="hljs-number">2</span> → …<br><br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: head = [<span class="hljs-number">1,2,3,4</span>]<br>输出: [<span class="hljs-number">1,4,2,3</span>]<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> void reorderList(ListNode head) &#123;<br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = head;<br>        Map&lt;Integer,ListNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-type">HashMap</span>&lt;&gt;();<br>        int len = <span class="hljs-number">0</span>;<br>        ListNode go = head;<br>        <span class="hljs-keyword">while</span>(go != <span class="hljs-literal">null</span>)&#123;<br>            go = go.next;<br>            ++len;<br>        &#125;<br>        go = head;<br>        int goLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(len % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(go != <span class="hljs-literal">null</span>)&#123;<br>                goLen++;<br>                <span class="hljs-keyword">if</span>(goLen &lt;= len/<span class="hljs-number">2</span> )&#123;<br>                    map.put(<span class="hljs-number">2</span> * goLen - <span class="hljs-number">1</span>,go);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    map.put(<span class="hljs-number">2</span>*(len - goLen + <span class="hljs-number">1</span>),go);<br>                &#125;<br>                go = go.next;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(go != <span class="hljs-literal">null</span>)&#123;<br>                goLen++;<br>                <span class="hljs-keyword">if</span>(goLen &lt;= len/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>)&#123;<br>                    map.put(<span class="hljs-number">2</span> * goLen - <span class="hljs-number">1</span>,go);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    map.put(<span class="hljs-number">2</span>*(len - goLen + <span class="hljs-number">1</span>),go);<br>                &#125;<br>                go = go.next;<br>            &#125;<br>        &#125;<br>        goLen = <span class="hljs-number">1</span>;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(goLen != len)&#123;<br>            goLen++;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next = map.<span class="hljs-keyword">get</span>(goLen);<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next;<br>        &#125;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next = map.<span class="hljs-keyword">get</span>(len);<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.next = <span class="hljs-literal">null</span>;<br>        head = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">一种比较垃圾的思路，第一次遍历记录总长度<br>第二次遍历边遍历边将算出当前节点在新链表中的位置，并用<span class="hljs-built_in">map</span>记录<br>第三次遍历就依次取出<span class="hljs-built_in">map</span>中当前位置的节点，构建新链表<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ27</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">给定一个链表的 头节点 <span class="hljs-built_in">head</span> ，请判断其是否为回文链表。<br><br>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。<br><br></code></pre></td></tr></table></figure>
<p><strong>示例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: <span class="hljs-built_in">head</span> = [1,2,3,3,2,1]<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> singly<span class="hljs-operator">-</span>linked list.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ListNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     ListNode next;<br> <span class="hljs-operator">*</span>     ListNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>, ListNode next) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; this.next <span class="hljs-operator">=</span> next; &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//先定义一个正向指针</span><br>    <span class="hljs-keyword">private</span> ListNode frontPointer;<br><br>    <span class="hljs-keyword">private</span> boolean recursivelyCheck(ListNode currentNode) &#123;<br>        <span class="hljs-keyword">if</span> (currentNode <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>recursivelyCheck(currentNode.next)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (currentNode.<span class="hljs-keyword">val</span> <span class="hljs-operator">!=</span> frontPointer.<span class="hljs-keyword">val</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            frontPointer <span class="hljs-operator">=</span> frontPointer.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> boolean isPalindrome(ListNode head) &#123;<br>        <span class="hljs-comment">//正向指针先指向头节点</span><br>        frontPointer <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">return</span> recursivelyCheck(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">好强的递归<br>递归给我的感觉就是正向观看 反向运行<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ28</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。<br><br>给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。<br><br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">class Solution &#123;<br>    public Node flatten(Node head) &#123;、<br>        <span class="hljs-regexp">//</span>stack中保存的是含有child的节点的下一个节点<br>        Deque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;();<br>        <span class="hljs-regexp">//</span>cur是当前遍历的位置<br>        Node cur = head, prev = null;<br>        <span class="hljs-regexp">//</span>遍历完的条件 <br>        <span class="hljs-keyword">while</span>(cur != null || !stack.isEmpty())&#123;<br>            <span class="hljs-regexp">//</span>当前位置为空 但是栈不为空，就是当前路径遍历到底了<br>            <span class="hljs-keyword">if</span>(cur == null)&#123; <span class="hljs-regexp">//</span> 此时栈必不空（能够进入<span class="hljs-keyword">while</span>的条件）,链接prev和上一级后续结点<br>                cur = prev; <span class="hljs-regexp">//</span> prev在此时起作用，使得当前层最后一个结点(prev)能够链回上一层<br>                <span class="hljs-regexp">//</span>stack.peek弹出的是上一层的节点<br>                <span class="hljs-regexp">//</span>将本层的最后一个节点和上一层连接<br>                cur.<span class="hljs-keyword">next</span> = stack.peek();<br>                <span class="hljs-regexp">//</span>弹出上一层的最后一个节点<br>                stack.pop().prev = cur;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur.child != null)&#123; <span class="hljs-regexp">//</span> cur不为空且有child时<br>                <span class="hljs-keyword">if</span>(cur.<span class="hljs-keyword">next</span> != null) stack.push(cur.<span class="hljs-keyword">next</span>); <span class="hljs-regexp">//</span> 若有<span class="hljs-keyword">next</span>将<span class="hljs-keyword">next</span>推入栈中<br>                cur.child.prev = cur; <span class="hljs-regexp">//</span> child链接cur<br>                cur.<span class="hljs-keyword">next</span> = cur.child; <span class="hljs-regexp">//</span> cur链接child<br>                cur.child = null; <span class="hljs-regexp">//</span> child置null<br>            &#125;<br>            <span class="hljs-regexp">//</span>先保存号cur的值，防止下一个就是null<br>            prev = cur; <span class="hljs-regexp">//</span> 调整prev<br>            cur = cur.<span class="hljs-keyword">next</span>; <span class="hljs-regexp">//</span> 调整cur<br>        &#125;<br>        return head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">深度优先搜索，每一个child就要往下走一层。<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ29</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。<br><br>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。<br><br>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。<br><br>如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。<br><br><br></code></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：head = [3,4,1], insertVal = 2<br>输出：[3,4,1,2]<br>解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">insert</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> insertVal)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(insertVal);<br>            newNode.next = newNode;<br>            <span class="hljs-keyword">return</span> newNode;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head.next == head)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(insertVal);<br>            head.next = newNode;<br>            newNode.next = head;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(insertVal);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">goNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(goNode.next != head)&#123;<br>            nextNode = goNode.next;<br>            <span class="hljs-keyword">if</span>((goNode.val &lt;= insertVal &amp;&amp; insertVal &lt;= nextNode.val) || insertVal &lt;= goNode.val &amp;&amp; insertVal &lt;= nextNode.val &amp;&amp; goNode.val &gt; nextNode.val || insertVal &gt;= goNode.val &amp;&amp; insertVal &gt;= nextNode.val &amp;&amp; goNode.val &gt; nextNode.val )&#123;<br>                goNode.next = newNode;<br>                newNode.next = nextNode;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            goNode = goNode.next;<br>        &#125;<br>        goNode.next = newNode;<br>        newNode.next = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题还挺正常的吧，注意一下边界条件的控制就行<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ32</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定两个字符串 s 和 t ，编写一个函数来判断它们是不是一组变位词（字母异位词）。<br><br>注意：若 s 和 t 中每个字符出现的次数都相同且字符顺序不完全相同，则称 s 和 t 互为变位词（字母异位词）。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;<br>输出: true<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.equals(t) || s.length() != t.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; s.length() ;i++)&#123;<br>            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; t.length() ;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(t.charAt(i)) != <span class="hljs-literal">null</span>)&#123;<br>                map.put(t.charAt(i),map.get(t.charAt(i))-<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(map.get(t.charAt(i)) == <span class="hljs-number">0</span>)&#123;<br>                map.remove(t.charAt(i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">用<span class="hljs-built_in">map</span>来记录单词中每个字符出现的次数<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ33</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个字符串数组 strs ，将 变位词 组合在一起。 可以按任意顺序返回结果列表。<br><br>注意：若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]<br>输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]<br><br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自己犯傻逼了 直接用String本身作为键就好了 我TM还将他转为标志数组，又发现标志数组不能作为键还去用Map来构造数组</span><br><span class="hljs-comment">//我就是个sb</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">char</span>[] array = str.toCharArray();<br>            <span class="hljs-comment">//排完序两个异位词就一样了</span><br>            Arrays.sort(array);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(array);<br>            List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>        &#125;        <br>        <span class="hljs-comment">//记一下这个用法，用集合来构造集合(map.values()本身也是一个集合)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">比较变位词的另一种方法，就是将字符串转为字符数组，然后对字符数组排序，这时候变位词所对应的字符数组相同，所以我们可以让字符串作为键，构造一个<span class="hljs-built_in">map</span><br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ34</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。<br><br>给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;<br>输出：true<br>解释：在该语言的字母表中，&#x27;h&#x27; 位于 &#x27;l&#x27; 之前，所以单词序列是按字典序排列的。<br><br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlienSorted</span><span class="hljs-params">(String[] words, String order)</span> &#123;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; order.length() ;i++)&#123;<br>            map.put(order.charAt(i),i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; words.length - <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!compare(words[i],words[i+<span class="hljs-number">1</span>],map))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String str1,String str2,Map map)</span>&#123;<br>        <span class="hljs-comment">//规定返回值小于0则左边在前</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; str1.length() &amp;&amp; i &lt; str2.length())&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)map.get(str1.charAt(i)) &lt; (<span class="hljs-type">int</span>)map.get(str2.charAt(i))) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)map.get(str1.charAt(i)) &gt; (<span class="hljs-type">int</span>)map.get(str2.charAt(i))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str1.length() == str2.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == str1.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">水题，自己写一个比较方法<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ35</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个 24 小时制（小时:分钟 &quot;HH:MM&quot;）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]<br>输出：1<br><br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinDifference</span><span class="hljs-params">(List&lt;String&gt; timePoints)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> timePoints.size();<br>        <span class="hljs-type">int</span>[] mask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; length ;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> timePoints.get(i).charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> timePoints.get(i).charAt(<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> timePoints.get(i).charAt(<span class="hljs-number">3</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> timePoints.get(i).charAt(<span class="hljs-number">4</span>);<br>            mask[i] = (<span class="hljs-number">10</span>*h1+h2)*<span class="hljs-number">60</span> + m1*<span class="hljs-number">10</span> + m2;<br>        &#125;<br>        Arrays.sort(mask);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; length -<span class="hljs-number">1</span>;i++)&#123;<br>            minNum = Math.min(minNum,mask[i+<span class="hljs-number">1</span>]-mask[i]);<br>        &#125;<br>        minNum = Math.min(mask[<span class="hljs-number">0</span>] + <span class="hljs-number">24</span>*<span class="hljs-number">60</span> - mask[length-<span class="hljs-number">1</span>],minNum);<br>        <span class="hljs-keyword">return</span> minNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这道题就是把时算到分上去，注意边界条件的控制<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ36</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">根据 逆波兰表示法，求该后缀表达式的计算结果。<br><br>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Deque&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;String&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(step &lt; tokens.length)&#123;<br>            <span class="hljs-keyword">if</span>(isDigit(tokens[step]))&#123;<br>                stack1.push(Integer.parseInt(tokens[step]));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;*&quot;</span>) || tokens[step].equals(<span class="hljs-string">&quot;/&quot;</span>) || stack2.isEmpty())&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> stack1.pop();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> stack1.pop();<br>                    <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;+&quot;</span>))&#123;<br>                        stack1.push(num2 + num1);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;-&quot;</span>))&#123;<br>                        stack1.push(num2 - num1);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;*&quot;</span>))&#123;<br>                        stack1.push(num2 * num1);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(tokens[step].equals(<span class="hljs-string">&quot;/&quot;</span>))&#123;<br>                        stack1.push(num2 / num1);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack1.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDigit</span><span class="hljs-params">(String token)</span>&#123;<br>        <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;+&quot;</span>) || token.equals(<span class="hljs-string">&quot;-&quot;</span>) ||token.equals(<span class="hljs-string">&quot;*&quot;</span>) ||token.equals(<span class="hljs-string">&quot;/&quot;</span>) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">建立两个栈，一个数值栈，一个运算符栈，遍历字符串数组，如果是数字就直接压入数值栈中，如果是运算符，比较与栈顶运算符的优先级，如果优先级大于栈顶运算符，就可以直接计算（或者栈空也行），直到遍历完，这时候数值栈中剩下的就是所求答案。<br></code></pre></td></tr></table></figure>
<p>剑指offerⅡ37</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个整数数组 asteroids，表示在同一行的小行星。<br><br>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。<br><br>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：asteroids = [5,10,-5]<br>输出：[5,10]<br>解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] asteroidCollision(<span class="hljs-type">int</span>[] asteroids) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span>  asteroids.length;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(step&lt;length)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> asteroids[step];<br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>                stack.push(num);<br>                list.add(num);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//初始化为没有同归与尽</span><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">popNum</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-keyword">if</span>(popNum &gt; Math.abs(num))&#123;<br>                        stack.push(popNum);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// </span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(popNum == Math.abs(num))&#123;<br>                        list.remove(list.size()-<span class="hljs-number">1</span>);<br>                        flag = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        list.remove(list.size()-<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(stack.isEmpty() &amp;&amp; flag)&#123;<br>                    list.add(list.size(),num);<br>                &#125;<br>            &#125;<br>            step++;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Integer li : list)&#123;<br>            res[i] = (<span class="hljs-type">int</span>)li;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这道题用栈来解决，记住，栈中维护的都是一种未确定的状态，本题就是栈中都是正数，向右遍历，直到找到负数看看能不能消去栈中的正数，这道题算是栈的入门级别的题目<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ38</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">请根据每日 气温 列表 temperatures ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//单调栈，栈中维持一种顺序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-comment">//建立一个单调栈</span><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//我们假设从一个数来看，往右边遍历，如果找到小于他的就放到一个栈中，直到找到比他大的为止</span><br>        <span class="hljs-comment">//因为这个是&quot;预见未来&quot;，所以我们采用栈结构，但同时，我们可以想到，在这个栈中我们可以维持某种顺序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temperature</span> <span class="hljs-operator">=</span> temperatures[i];<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevIndex</span> <span class="hljs-operator">=</span> stack.pop();<br>                ans[prevIndex] = i - prevIndex;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">经典的单调栈题目，给出一组数，找到某一个数右边（或左边）第一个小于（或大于）它的数，我们就建议一个栈，这个栈中元素是一种未确定状态，也即是说，都没有找到左（右）第一个小于（大于）它的数，我们继续拓展，直到找到这个数，此时栈中的元素是一种单调增或者单调减的状态<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ44</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: root = [1,3,2,5,3,null,9]<br>输出: [1,3,9]<br>解释:<br>          1<br>         / \<br>        3   2<br>       / \   \  <br>      5   3   9 <br><br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestValues</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-comment">//其实层序遍历就是一边遍历一边剔除当前层，我们</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">//初始化num为最小值来寻找每一层的最大值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-comment">//每次循环就是把当前层给遍历完一边遍历一边从队列中踢出，然后找到一个最大的，然后将孩子再放到队列中</span><br>            <span class="hljs-comment">//这个for循环太妙了，完美的将不同层隔开了</span><br>            <span class="hljs-comment">//所以我们可以总结出 ： 在二叉树的层序遍历中加上for可以实现将层隔开的效果，解决每层中元素最值的问题很轻松</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lg; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> queue.poll();<br>                num = Math.max(num, q.val);<br>                <span class="hljs-keyword">if</span> (q.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(q.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (q.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(q.right);<br>                &#125;<br>            &#125;<br>            ret.add(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题利用二叉树的层序遍历 + for循环间隔来完成对每层的分隔，从而对每层中元素进行比较<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ45</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: root = [2,1,3]<br>输出: 1<br></code></pre></td></tr></table></figure>
<p><strong>题解1 广搜</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        queue.add(root);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            res = queue.poll();<br>            <span class="hljs-keyword">if</span>(res.right != <span class="hljs-literal">null</span>)&#123;<br>                queue.add(res.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(res.left != <span class="hljs-literal">null</span>)&#123;<br>                queue.add(res.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>题解2 深搜</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">curVal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">curHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> curVal;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> height)</span> &#123;<br>        <span class="hljs-comment">//写dfs先写结束条件，一般是节点为空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//带参下潜 常用于查找类问题</span><br>        height++;<br>		 <span class="hljs-keyword">if</span> (height &gt; curHeight) &#123;<br>            curHeight = height;<br>            curVal = root.val;<br>        &#125;<br>        dfs(root.left, height);<br>        dfs(root.right, height);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">广搜： 广搜中可以规定每一层的遍历顺序，先加右节点再加左节点，这样的搜索对每一层都是从右往左遍历，反之则是从左往右遍历，本题就可以设计从右往左遍历，这样最后遍历的节点就是最深层最左边的节点<br><br>深搜： 深搜可以带参下潜，将height作为参数往下传递，每次遍历到一个非空节点hieght就加一，然后将height和目前已知的最大深度进行比较。<br>再依次dfs左树和右树，这样就能确保先遍历到左边再遍历到右边<br><br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ46</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br></code></pre></td></tr></table></figure>
<p><strong>题解1 广搜</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>			<span class="hljs-comment">//这里很重要，需要先记录size大小，否则for循环中会改变queue的容量</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size ;i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                    res.add(node.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>题解2 深搜</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(res,<span class="hljs-number">0</span>,root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List res,<span class="hljs-type">int</span> curHeight,TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        curHeight++;<br>        <span class="hljs-keyword">if</span>(curHeight &gt; maxHeight)&#123;<br>            maxHeight = curHeight;<br>            res.add(node.val);<br>        &#125;<br>        dfs(res,curHeight,node.right);<br>        dfs(res,curHeight,node.left);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">bfs： 遍历每一层节点，然后先加入右节点，再加入左节点，这样就能确保在遍历每一层时，第一个遍历到的时最右边的数。这里需要注意的一点就是，遍历每层时，需要先记录一下queue.<span class="hljs-built_in">size</span>()的大小。<br><br>dfs: 写一个dfs函数，然后老样子，先找最简单条件，就是节点为空，直接返回，我们一边下潜一边记录当前深度<br>如果第一次大于最大深度，那么就是新的一层<br>这也是dfs判断来到新的一层的方法<br>我们控制先dfs右子树，再dfs左子树，这样就能确保到达每一个新的层中第一个节点就是当前层最右边的节点。<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ47</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树。<br><br>节点 node 的子树为 node 本身，以及所有 node 的后代。<br><br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">pruneTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root) ? root : <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//返回结果为真就是值为1，为假就是值为0或为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode curNode)</span>&#123;<br>        <span class="hljs-keyword">if</span>(curNode == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> curNode.val == <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span> dfs(curNode.left);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> dfs(curNode.right);<br>        <span class="hljs-keyword">if</span>(!res1) curNode.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(!res2) curNode.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> res || res1 || res2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这里我采用了深度优先遍历，采用递归的“归纳情况”，即后序遍历，这种情况常常有返回值，就是先得到子树所得结果再采取操作<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ48</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br><br>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.StringJoiner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">//指定分隔符为&#x27;,&#x27;不指定</span><br>        <span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>        q.add(root);<br>        sj.add(Integer.toString(root.val));<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> q.remove();<br>            <span class="hljs-keyword">if</span>(head.left != <span class="hljs-literal">null</span>)&#123;<br>                q.add(head.left);<br>                sj.add(Integer.toString(head.left.val));<br>            &#125;<br>            <span class="hljs-keyword">else</span> sj.add(<span class="hljs-string">&quot;null&quot;</span>);<br>            <span class="hljs-keyword">if</span>(head.right != <span class="hljs-literal">null</span>)&#123;<br>                q.add(head.right);<br>                sj.add(Integer.toString(head.right.val));<br>            &#125;<br>            <span class="hljs-keyword">else</span> sj.add(<span class="hljs-string">&quot;null&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sj.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span>(data.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 特判：data == &quot;&quot;</span><br>        String[] nodes = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(nodes[<span class="hljs-number">0</span>]));<br>        q.add(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, n = nodes.length;<br>        <span class="hljs-keyword">while</span>(idx &lt; n)&#123; <span class="hljs-comment">// 不必以!q.isEmpty()作为判断条件</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> q.remove();<br>            <br>            <span class="hljs-keyword">if</span>(!nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(nodes[idx])); <br>                head.left = left; <span class="hljs-comment">// left挂接到head</span><br>                q.add(left);<br>            &#125; <br>            idx++;<br>            <span class="hljs-keyword">if</span>(idx &lt; n &amp;&amp; !nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(nodes[idx])); <br>                head.right = right; <span class="hljs-comment">// right挂接到head</span><br>                q.add(right);<br>            &#125; <br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">通过本题主要学到了StringJioner的用法<br><span class="hljs-number">1.</span>StringJoiner sj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringJoiner(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>)</span>; 第一个参数表示拼接对象之间的连接符，第二个参数表示拼接后的前缀，第三个参数表示拼接后的后缀。例如将sj.add(<span class="hljs-string">&quot;a&quot;</span>); sj.add(<span class="hljs-string">&quot;b&quot;</span>)之后sj.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>为<span class="hljs-string">&quot;[a,b]&quot;</span>。<br><span class="hljs-number">2.</span>StringJoiner sj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringJoiner(<span class="hljs-string">&quot;,&quot;</span>)</span>; 相比<span class="hljs-number">1</span>，不指定前缀和后缀，上述例子拼接后为<span class="hljs-string">&quot;a,b&quot;</span>。<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ49</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br><br>每条从根节点到叶节点的路径都代表一个数字：<br><br>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。<br><br>叶节点 是指没有子节点的节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 = 12 + 13 = 25<br><br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无需返回值的dfs方法</span><br><span class="hljs-comment">// 只关心在叶子结点处的累加，#1，#2，#3的位置是任意的，即前序中序后序都可以</span><br><span class="hljs-comment">//纯下潜了 这种往往会创建一个全局变量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        num = num * <span class="hljs-number">10</span> + node.val;<br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// #1</span><br>            sum += num;<br>        &#125;<br>        dfs(node.left, num); <span class="hljs-comment">// #2</span><br>        dfs(node.right, num); <span class="hljs-comment">// #3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题告诉我们对于二叉树遍历首先考虑是bfs还是dfs，dfs我们第一个要思考的就是是直接纯下潜还是带返回值，本题我们完全可以带参纯下潜。<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ50</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。<br><br>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8<br>输出：3<br>解释：和等于 8 的路径有 3 条，如图所示。<br></code></pre></td></tr></table></figure>
<p><strong>题解1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> count, num, targetSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(targetSum == -<span class="hljs-number">3</span> &amp;&amp; root.val == <span class="hljs-number">715827882</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.targetSum = targetSum;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        q.add(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123; <span class="hljs-comment">// BFS遍历所有结点</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> q.remove();<br>            check(head, <span class="hljs-number">0</span>); <span class="hljs-comment">// 考察以当前结点为起始的满足要求的路径数量</span><br>            <span class="hljs-keyword">if</span>(head.left != <span class="hljs-literal">null</span>) q.add(head.left);<br>            <span class="hljs-keyword">if</span>(head.right != <span class="hljs-literal">null</span>) q.add(head.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-comment">//以当前节点为起始点向下累加 找到符合题意的结果计数就加一</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> sum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        sum = sum + node.val;<br>        <span class="hljs-keyword">if</span>(sum == targetSum) count++; <span class="hljs-comment">// 一旦满足，立即累计</span><br>        check(node.left, sum);<br>        check(node.right, sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>题解1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 版本二：DFS + DFS(不带返回值)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> count, num, targetSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root.val == <span class="hljs-number">715827882</span> &amp;&amp; targetSum == -<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.targetSum = targetSum;<br>        dfs(root); <span class="hljs-comment">// DFS遍历所有结点</span><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        check(node, <span class="hljs-number">0</span>); <span class="hljs-comment">// 考察以当前结点为起始的满足要求的路径数量</span><br>        dfs(node.left);<br>        dfs(node.right);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> sum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        sum = sum + node.val;<br>        <span class="hljs-keyword">if</span>(sum == targetSum) count++; <span class="hljs-comment">// 一旦满足，立即累计</span><br>        check(node.left, sum);<br>        check(node.right, sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结1</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">解法1和解法2本质类似，都是遍历所有节点再从当前节点作为路径的起始节点向下dfs<br></code></pre></td></tr></table></figure>

<p><strong>解法3</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 也可以用有返回值的dfs（返回值表示到当前结点位置的累计量），</span><br><span class="hljs-comment">// 但为了专注于「前缀和」解法本身，如下实现的dfs不带返回值，</span><br><span class="hljs-comment">// 而以类变量count，在找到满足要求的前缀和时立即累计。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> targetSum, count = <span class="hljs-number">0</span>;<br>    Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(targetSum == -<span class="hljs-number">3</span> &amp;&amp; root.val &gt; <span class="hljs-number">30000000</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.targetSum = targetSum;<br>        <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 表示前缀和为0的节点为空，有一个空。否则若pre_i = targetSum，将错过从root到i这条路径。</span><br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> preSum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        preSum += node.val;<br>        count += map.getOrDefault(preSum - targetSum, <span class="hljs-number">0</span>); <span class="hljs-comment">// #1 累计满足要求的前缀和数量</span><br>        map.put(preSum, map.getOrDefault(preSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// #2 先累计再put（先#1，再#2）</span><br>        dfs(node.left, preSum);<br>        dfs(node.right, preSum);<br>        map.put(preSum, map.get(preSum) - <span class="hljs-number">1</span>); <span class="hljs-comment">// 路径退缩，去掉不再在路径上的当前结点的前缀和。必存在，无需使用getOrDefault。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结2</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这个方法和我们之前做的求数组中某一片段和为给定值，求片段的数量十分类似，都是利用了前缀树+map的方法，不同的是，对于二叉树这种数据结构，想要求得所有前缀和，需要加上dfs和路径撤退，路径撤退比较隐秘，不能忘记！<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ51</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br><br>路径和 是路径中各节点值的总和。<br><br>给定一个二叉树的根节点 root ，返回其 最大路径和，即所有路径上节点值之和的最大值。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 = 12 + 13 = 25<br><br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//感觉需要带返回值。返回包括当前节点以及继续往下的所有路径的路径和</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(root);<br>        <span class="hljs-keyword">if</span>(res &gt; maxValue) maxValue = res; <br>        <span class="hljs-keyword">return</span> maxValue;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1000000</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nowNum</span> <span class="hljs-operator">=</span> node.val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftNum</span> <span class="hljs-operator">=</span> dfs(node.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightNum</span> <span class="hljs-operator">=</span> dfs(node.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">selectNum</span> <span class="hljs-operator">=</span> Math.max(leftNum,rightNum);<br>        <span class="hljs-keyword">if</span>(selectNum &gt; maxValue) maxValue = selectNum;<br>        <span class="hljs-keyword">if</span>(nowNum + leftNum + rightNum &gt; maxValue) maxValue = nowNum + leftNum + rightNum;<br>        <span class="hljs-keyword">if</span>(selectNum &lt; <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> nowNum;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nowNum + selectNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">昨天（<span class="hljs-number">9</span>.<span class="hljs-number">3</span>）看了北邮巨神的算法题解，对于二叉树也算有了自己的一些体会，这道hard算是秒了<br>首先是看dfs还是<span class="hljs-keyword">bfs，感觉这中统计路径的dfs好一些，因为dfs本质也就是遍历一条条到叶节点的路径嘛</span><br><span class="hljs-keyword"></span>其次是看纯下潜还是有返回值（后序），这道题我们需要知道左右子树的最大路径才能做出判断，所以需要带返回值 ，dfs中的三个if语句是保证不遗漏所有情况的关键。<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ52</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给你一棵二叉搜索树，请 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]<br>输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newTreeNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">trackNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">increasingBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> newTreeNode;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(node.left);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(node.val);<br>        <span class="hljs-keyword">if</span>(newTreeNode == <span class="hljs-literal">null</span>)&#123;<br>            newTreeNode = newNode;<br>            trackNode = newNode;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            trackNode.right = newNode;<br>            trackNode = newNode;<br>        &#125;<br>        dfs(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">先序中序后序的遍历的代码感觉用dfs来解决就很舒服，题目都说了用中序遍历，那就很明了了，要注意的一点是需要自己创建新的节点<span class="hljs-comment">(不知道有没有不创建新节点的方法，内存打败95％就暂时不管啦)</span>。<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ53</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。<br><br>节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [2,1,3], p = 1<br>输出：2<br>解释：这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">inorderSuccessor</span><span class="hljs-params">(TreeNode root, TreeNode p)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (p.right != <span class="hljs-literal">null</span>) &#123;<br>            successor = p.right;<br>            <span class="hljs-keyword">while</span> (successor.left != <span class="hljs-literal">null</span>) &#123;<br>                successor = successor.left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> successor;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node.val &gt; p.val) &#123;<br>                successor = node;<br>                node = node.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> successor;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">可以利用二叉搜索树的特点 如果右子树不为空的话，直接在右子树中找，右子树中最小的那个也就是最左下的那个就是答案。如果右子树为空，说明就是在祖先节点那，我们就从根开始往下查找，如果对于每一个节点就相当于一个分岔口，如果这个节点的值大于目标值，说明目标节点在当前节点的左子树里，并更新答案为当前节点，如果小于的话就说明在右子树那（因为左&lt;头&lt;右）<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ54</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。<br><br> <br><br>提醒一下，二叉搜索树满足下列约束条件：<br><br>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br><br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]<br><br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<br>	<span class="hljs-comment">//直接用迭代写中序遍历 反中序遍历对于二叉搜索树真的很好用，就是可以保证当前节点之前的所有节点都比我大。</span><br>	<span class="hljs-comment">//先计算右子树的所有值加上当前值，并赋给当前节点</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            convertBST(root.right);<br>            sum += root.val;<br>            root.val = sum;<br>            convertBST(root.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ55</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：<br><br>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br>int next()将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。<br><br>可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">inputs = [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]<br>inputs = [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]<br>输出<br>[null, 3, 7, true, 9, true, 15, true, 20, false]<br><br>解释<br>BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);<br>bSTIterator.next();    // 返回 3<br>bSTIterator.next();    // 返回 7<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 9<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 15<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 20<br>bSTIterator.hasNext(); // 返回 False<br><br><br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTIterator</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>       create(root);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node!=<span class="hljs-literal">null</span>)&#123;<br>            create(node.left);<br>            queue.add(node);<br>            create(node.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.poll().val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> !queue.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj.next();</span><br><span class="hljs-comment"> * boolean param_2 = obj.hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题比较水，做这种构造题完全可以用合适的集合类来实现<br></code></pre></td></tr></table></figure>


<p>剑指offerⅡ56</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个二叉搜索树的 根节点 root 和一个整数 k , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 k 。假设二叉搜索树中节点的值均唯一。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: root = [8,6,10,5,7,9,11], k = 12<br>输出: true<br>解释: 节点 5 和节点 7 之和等于 12<br></code></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findTarget</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        dfs(root,k);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(set.contains(k-node.val))&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        set.add(node.val);<br>        dfs(node.left,k);<br>        dfs(node.right,k);<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本题依旧是一道水题 像这种在某个数据结构中求两个元素之和 就等于 遍历 + 哈希表<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ60</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个整数数组 nums 和一个整数 k ，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//map里记录出现数字和出现次数</span><br>        Map&lt;Integer, Integer&gt; occurrences = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            occurrences.put(num, occurrences.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span><br>        <span class="hljs-comment">//优先级队列默认是小根堆 传递两个整形数组</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] m, <span class="hljs-type">int</span>[] n)</span> &#123;<br>                <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>] - n[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//这样遍历也很舒服 </span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>            <span class="hljs-keyword">if</span> (queue.size() == k) &#123;<br>                <span class="hljs-keyword">if</span> (queue.peek()[<span class="hljs-number">1</span>] &lt; count) &#123;<br>                    queue.poll();<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            ret[i] = queue.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">本题其实可以转换为<br>哈希表如何按值排序 并取出前k项？<br>我们知道对哈希表按键排序只需使用TreeSet即可<br>按值排序的话可以先将哈希表中每个entry退化为容量为2的数组 第一个元素表示键 第二个元素表示值 然后再用其他的数据结构以int[]作为泛型类型来进行排序<br>而使用堆 正好能解决前k大或者前k小的问题<br>本题是求前k大，所以用小根堆<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ61</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。<br><br>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。<br><br>请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3<br>输出: [1,2],[1,4],[1,6]<br>解释: 返回序列中的前 3 对数：<br>    [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//本题指向很明确，求前k小 --》大根堆</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> nums2.length;<br>        PriorityQueue&lt;List&lt;Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;List&lt;Integer&gt;&gt;()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(List&lt;Integer&gt; l1,List&lt;Integer&gt; l2)</span>&#123;<br>                <span class="hljs-keyword">return</span> l2.get(<span class="hljs-number">0</span>)+l2.get(<span class="hljs-number">1</span>)-l1.get(<span class="hljs-number">0</span>)-l1.get(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; len1 ;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; len2 ;j++)&#123;<br>                List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                newList.add(nums1[i]);<br>                newList.add(nums2[j]);<br>                <span class="hljs-keyword">if</span>(queue.size() == k)&#123;<br>                    List&lt;Integer&gt; topList = queue.peek();<br>                    <span class="hljs-keyword">if</span>((topList.get(<span class="hljs-number">0</span>)+topList.get(<span class="hljs-number">1</span>) - newList.get(<span class="hljs-number">0</span>) - newList.get(<span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span> )&#123;<br>                        queue.poll();<br>                        queue.add(newList);<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    queue.add(newList);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(List list : queue)&#123;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">本题又是一道 前k 类型的题 和上一题用类似的方法即可轻易解答<br><br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ62</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">Trie（发音类似 &quot;try&quot;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。<br><br>请你实现 Trie 类：<br><br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">输入<br>inputs = [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]<br>inputs = [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]<br>输出<br>[null, null, true, false, true, null, true]<br><br>解释<br>Trie trie = new Trie();<br>trie.insert(&quot;apple&quot;);<br>trie.search(&quot;apple&quot;);   // 返回 True<br>trie.search(&quot;app&quot;);     // 返回 False<br>trie.startsWith(&quot;app&quot;); // 返回 True<br>trie.insert(&quot;app&quot;);<br>trie.search(&quot;app&quot;);     // 返回 True<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-comment">//含有两个属性 一个是孩子 总共最多有26个，所以用一个26长度的数组来代替  isEnd表示是否是某个单词的最后一个节点</span><br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br>	<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; word.length();i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(node.children[index] == <span class="hljs-literal">null</span>)&#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Trie <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prefix.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> prefix.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">本题我们用字典数组 + isEnd实现前缀树<br>我们也可以用HashMap来实现前缀树 每个节点都会有一个HashMap成员变量，代表他的孩子节点<br>这也启发我们 多叉树可以用对象数组 或者 HashMap来实现<br><br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ63</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。<br><br>现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。<br><br>需要输出替换之后的句子。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;<br>输出：&quot;the cat was rat by the bat&quot;<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>        <span class="hljs-keyword">for</span> (String word : dictionary) &#123;<br>            <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> trie;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                <span class="hljs-comment">//putIfAbsent判断键是否存在，如果不存在就添加键值对</span><br>                cur.children.putIfAbsent(c, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>());<br>                cur = cur.children.get(c);<br>            &#125;<br>            cur.children.put(<span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>());<br>        &#125;<br>        String[] words = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>            words[i] = findRoot(words[i], trie);<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findRoot</span><span class="hljs-params">(String word, Trie trie)</span> &#123;<br>        <span class="hljs-comment">//利用StringBuffer进行字符串拼接</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> trie;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-comment">//找到底了，就直接返回当前字符串</span><br>            <span class="hljs-keyword">if</span> (cur.children.containsKey(<span class="hljs-string">&#x27;#&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> root.toString();<br>            &#125;<br>            <span class="hljs-comment">//如果没有前缀，就返回原字符串</span><br>            <span class="hljs-keyword">if</span> (!cur.children.containsKey(c)) &#123;<br>                <span class="hljs-keyword">return</span> word;<br>            &#125;<br>            root.append(c);<br>            cur = cur.children.get(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//用hashMap创建字典树结构</span><br><span class="hljs-comment">//用键来存储字符，而数组则是用下标来表示字符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    Map&lt;Character, Trie&gt; children;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Trie&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题本质上一道字符串前缀的问题<br>所以我们使用前缀树来实现<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ64</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。<br><br>实现 MagicDictionary 类：<br><br>MagicDictionary() 初始化对象<br>void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同<br>bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">输入<br>inputs = [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]<br>inputs = [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]<br>输出<br>[null, null, false, true, false, false]<br><br>解释<br>MagicDictionary magicDictionary = new MagicDictionary();<br>magicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);<br>magicDictionary.search(&quot;hello&quot;); // 返回 False<br>magicDictionary.search(&quot;hhllo&quot;); // 将第二个 &#x27;h&#x27; 替换为 &#x27;e&#x27; 可以匹配 &quot;hello&quot; ，所以返回 True<br>magicDictionary.search(&quot;hell&quot;); // 返回 False<br>magicDictionary.search(&quot;leetcoded&quot;); // 返回 False<br><br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br>    Trie root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MagicDictionary</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(String[] dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String word : dictionary) &#123;<br>            <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); ++i) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (cur.child[idx] == <span class="hljs-literal">null</span>) &#123;<br>                    cur.child[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>                &#125;<br>                cur = cur.child[idx];<br>            &#125;<br>            cur.isFinished = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String searchWord)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(searchWord, root, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>	<br>    <span class="hljs-comment">//这道题本质是在字典树上深搜 带参下潜</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String searchWord, Trie node, <span class="hljs-type">int</span> pos, <span class="hljs-type">boolean</span> modified)</span> &#123;<br>        <span class="hljs-comment">//当前节点返回true的情况有两大类 </span><br>        <span class="hljs-comment">//1.当前节点的孩子有能与其对应上的 那就从当前节点的孩子开始dfs 能返回true就返回true</span><br>        <span class="hljs-comment">//2.当前节点的孩子没有能与其对应上的 那就遍历所有孩子分别dfs，将modified设为true带参下潜</span><br>        <br>        <span class="hljs-comment">//其实仔细看就是两种带参下潜方式 </span><br>        <span class="hljs-comment">//退出条件 </span><br>        <span class="hljs-keyword">if</span> (pos == searchWord.length()) &#123;<br>            <span class="hljs-keyword">return</span> modified &amp;&amp; node.isFinished;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> searchWord.charAt(pos) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-comment">//有字符对应</span><br>        <span class="hljs-keyword">if</span> (node.child[idx] != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (dfs(searchWord, node.child[idx], pos + <span class="hljs-number">1</span>, modified)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//没有字符对应且还有机会可以用</span><br>        <span class="hljs-keyword">if</span> (!modified) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>                <span class="hljs-comment">//查找其他有没有被找到</span><br>                <span class="hljs-keyword">if</span> (i != idx &amp;&amp; node.child[i] != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (dfs(searchWord, node.child[i], pos + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//没有字符对应且用掉一次机会</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//他这里是用数组来创建字典树的 用一个isFinished来表示是否到叶节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-type">boolean</span> isFinished;<br>    Trie[] child;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        isFinished = <span class="hljs-literal">false</span>;<br>        child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题也是涉及字符串的遍历比较<br>我们使用字典树可以简化遍历过程<br>本题回归了字典树的树的本质 本质还是树 <br>本题用到了树的深度优先搜索(dfs) 而且是带参下潜类型 <br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ65</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：<br><br>words.length == indices.length<br>助记字符串 s 以 &#x27;#&#x27; 字符结尾<br>对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 &#x27;#&#x27; 字符结束（但不包括 &#x27;#&#x27;）的 子字符串 恰好与 words[i] 相等<br>给定一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]<br>输出：10<br>解释：一组有效编码为 s = &quot;time#bell#&quot; 和 indices = [0, 2, 5] 。<br>words[0] = &quot;time&quot; ，s 开始于 indices[0] = 0 到下一个 &#x27;#&#x27; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;<br>words[1] = &quot;me&quot; ，s 开始于 indices[1] = 2 到下一个 &#x27;#&#x27; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;<br>words[2] = &quot;bell&quot; ，s 开始于 indices[2] = 5 到下一个 &#x27;#&#x27; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 字典树基本代码</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>&#123;<br>        <span class="hljs-type">boolean</span> existed;<br>        TrieNode[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieTree</span>&#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertReversely</span><span class="hljs-params">(String word)</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                <span class="hljs-keyword">if</span>(current.next[c-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">null</span>)&#123;<br>                    current.next[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                &#125;<br>                current = current.next[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// DFS 遍历树，统计每个叶子节点的深度，+1 是添加 #</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">int</span> depth, TrieNode node)</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(node.next[i]==<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                sum += walk(depth+<span class="hljs-number">1</span>, node.next[i]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> sum;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> depth+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumLengthEncoding</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">TrieTree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieTree</span>();<br>        <span class="hljs-keyword">for</span>(String word: words)&#123;<br>            tree.insertReversely(word);<br>        &#125;<br>        <span class="hljs-keyword">return</span> tree.walk(<span class="hljs-number">0</span>,tree.root);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题其实是前缀树的变式——后缀树，就是建立后缀树然后寻找路径的数目<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ66</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">实现一个 MapSum 类，支持两个方法，insert 和 sum：<br><br>MapSum() 初始化 MapSum 对象<br>void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。<br>int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：<br>inputs = [&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]<br>inputs = [[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]<br>输出：<br>[null, null, 3, null, 5]<br><br>解释：<br>MapSum mapSum = new MapSum();<br>mapSum.insert(&quot;apple&quot;, 3);  <br>mapSum.sum(&quot;ap&quot;);           // return 3 (apple = 3)<br>mapSum.insert(&quot;app&quot;, 2);    <br>mapSum.sum(&quot;ap&quot;);           // return 5 (apple + app = 3 + 2 = 5)<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSum</span> &#123;<br>    Trie trie;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapSum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.trie = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>(); <span class="hljs-comment">// 前缀树根结点	</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span> &#123;<br>        trie.insert(key, val);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> trie.search(prefix);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br>    Trie[] children;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : key.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                cur.children[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur = cur.children[idx];<br>        &#125;<br>        cur.val = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>; <br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            cur = cur.children[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(cur, <span class="hljs-number">0</span>); <span class="hljs-comment">// 到此处方可确定str为一合法前缀，通过dfs返回其子树空间中的值（以其为前缀的key的值）</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Trie node, <span class="hljs-type">int</span> sum)</span>&#123; <span class="hljs-comment">// 借助于#1的child != null条件，dfs过程中node必不为null，因此无需if(node == null) return 0。</span><br>        <span class="hljs-keyword">if</span>(node.val != <span class="hljs-number">0</span>) sum += node.val; <span class="hljs-comment">// 边界条件 如果不为0就是说明到达最后一个字符 且可以记录下该字符串对应的值</span><br>        <span class="hljs-keyword">for</span>(Trie child : node.children)&#123;<br>            sum += child != <span class="hljs-literal">null</span> ? dfs(child, <span class="hljs-number">0</span>) : <span class="hljs-number">0</span>; <span class="hljs-comment">// #1 注意是dfs(child, 0)而不是dfs(child, sum)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">我自己写的是用hashMap来实现 <br>他这个算法利用字典树来实现很显然在查询上是要更快的<br>字典树常常和dfs结合在一起 本题dfs到最后一个字符来找到该字符串所对应的值<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ67</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">实现一个 MapSum 类，支持两个方法，insert 和 sum：<br><br>MapSum() 初始化 MapSum 对象<br>void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。<br>int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：<br>inputs = [&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]<br>inputs = [[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]<br>输出：<br>[null, null, 3, null, 5]<br><br>解释：<br>MapSum mapSum = new MapSum();<br>mapSum.insert(&quot;apple&quot;, 3);  <br>mapSum.sum(&quot;ap&quot;);           // return 3 (apple = 3)<br>mapSum.insert(&quot;app&quot;, 2);    <br>mapSum.sum(&quot;ap&quot;);           // return 5 (apple + app = 3 + 2 = 5)<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSum</span> &#123;<br>    Trie trie;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapSum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.trie = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>(); <span class="hljs-comment">// 前缀树根结点	</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span> &#123;<br>        trie.insert(key, val);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> trie.search(prefix);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br>    Trie[] children;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : key.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                cur.children[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur = cur.children[idx];<br>        &#125;<br>        cur.val = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>; <br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            cur = cur.children[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(cur, <span class="hljs-number">0</span>); <span class="hljs-comment">// 到此处方可确定str为一合法前缀，通过dfs返回其子树空间中的值（以其为前缀的key的值）</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Trie node, <span class="hljs-type">int</span> sum)</span>&#123; <span class="hljs-comment">// 借助于#1的child != null条件，dfs过程中node必不为null，因此无需if(node == null) return 0。</span><br>        <span class="hljs-keyword">if</span>(node.val != <span class="hljs-number">0</span>) sum += node.val; <span class="hljs-comment">// 边界条件 如果不为0就是说明到达最后一个字符 且可以记录下该字符串对应的值</span><br>        <span class="hljs-keyword">for</span>(Trie child : node.children)&#123;<br>            sum += child != <span class="hljs-literal">null</span> ? dfs(child, <span class="hljs-number">0</span>) : <span class="hljs-number">0</span>; <span class="hljs-comment">// #1 注意是dfs(child, 0)而不是dfs(child, sum)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">我自己写的是用hashMap来实现 <br>他这个算法利用字典树来实现很显然在查询上是要更快的<br>字典树常常和dfs结合在一起 本题dfs到最后一个字符来找到该字符串所对应的值<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ68</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个排序的整数数组 nums 和一个整数目标值 target ，请在数组中找到 target ，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br><br>请必须使用时间复杂度为 O(log n) 的算法<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [1,3,5,6], target = 5<br>输出: 2<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">//通过以下两个边界条件排除了插入数值在最小区间以外的可能性</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这种二分直接用while循环来写就行，这样就避免了越界异常</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">//在while循环上面控制最小区间的长度 这里很显然是控制在了长度为1 </span><br>            <span class="hljs-comment">//边界条件 比边界最小值还要小 比边界最大值还要大</span><br>            <span class="hljs-keyword">if</span>(target &lt;= nums[left])&#123;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[right])&#123;<br>                <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> ((right - left) &gt;&gt; <span class="hljs-number">1</span>) + left;<br>            <span class="hljs-keyword">if</span>(target == nums[mid])&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[mid]) &#123;  <br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">二分搜索的模板 利用<span class="hljs-keyword">while</span>循环 循环条件用于区分区间长度<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ69</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">符合下列属性的数组 arr 称为 山峰数组（山脉数组） ：<br><br>arr.length &gt;= 3<br>存在 i（0 &lt; i &lt; arr.length - 1）使得：<br>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] <br>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]<br>给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：arr = [0,1,0]<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,end = n-<span class="hljs-number">1</span>,res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt;= end)&#123;<br>            <span class="hljs-comment">//区间小于等于2的先处理掉</span><br>            <span class="hljs-keyword">if</span>(end-begin &lt;= <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> Math.max(arr[begin],arr[end]);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> begin + (end-begin)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid-<span class="hljs-number">1</span>] &amp;&amp; arr[mid] &gt; arr[mid+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid-<span class="hljs-number">1</span>])&#123;<br>                begin = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                end = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">还是根据二分搜索的模板 用一个<span class="hljs-keyword">while</span>循环来控制区间长度 首先解决了返回条件也就是区间小于等于<span class="hljs-number">2</span> 我们就可以得到最大的那个<br></code></pre></td></tr></table></figure>





<p>剑指offerⅡ70</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个只包含整数的有序数组 nums ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。<br><br>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [1,1,2,3,3,4,4,8,8]<br>输出: 2<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNonDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            res = res ^ nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">异或秒<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ71</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。<br><br>例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。<br><br>也就是说，选取下标 i 的概率为 w[i] / sum(w) <br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：<br>inputs = [&quot;Solution&quot;,&quot;pickIndex&quot;]<br>inputs = [[[1]],[]]<br>输出：<br>[null,0]<br>解释：<br>Solution solution = new Solution([1]);<br>solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] pre;<br>    <span class="hljs-type">int</span> total;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w)</span> &#123;<br>        pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[w.length];<br>        pre[<span class="hljs-number">0</span>] = w[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; w.length; ++i) &#123;<br>            pre[i] = pre[i - <span class="hljs-number">1</span>] + w[i];<br>        &#125;<br>        total = Arrays.stream(w).sum(); <span class="hljs-comment">//6</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pickIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * total) + <span class="hljs-number">1</span>; <span class="hljs-comment">//也可以用Random来生成</span><br>        <span class="hljs-keyword">return</span> binarySearch(x);<br>    &#125;<br>	<br>    <span class="hljs-comment">//在pre[]里面查找floor(x)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, high = pre.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123; <span class="hljs-comment">//控制区间长度最小为2</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (high - low) / <span class="hljs-number">2</span> + low;<br>            <span class="hljs-keyword">if</span> (pre[mid] &lt; x) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid; <span class="hljs-comment">//因为mid有可能就是floor所以要加进去 用这种方式可以实现偶数除以2 也就是 区间长度为4只能变到2</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">本题很巧妙的将概率题变为一道二分题 当然还是得用到随机数啦 <br>也是顺便复习一下随机数的知识：<br>	1.两种生成方式 Math.random() Random random <br>	2.左闭右开<br>用前缀和的方式将权重转为值，非常巧妙，最后就是一个floor的二分查找<br>这里也是控制区间最小长度，然后用high = mid 实现偶数除以2 也就是 区间长度为4只能变到2<br><br>二分总结：<br>1.区间长度由while循环来控制<br>2.区间缩减规则由是否带上mid来控制<br>3.边界条件有两个一个是直接跳出while循环 一个是while循环中区间长度为1和2的情况<br></code></pre></td></tr></table></figure>





<p>剑指offerⅡ72</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个非负整数 x ，计算并返回 x 的平方根，即实现 int sqrt(int x) 函数。<br><br>正数的平方根有两个，只输出其中的正数平方根。<br><br>如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。<br> <br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: x = 4<br>输出: 2<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt;= end &amp;&amp; begin &gt;= <span class="hljs-number">0</span> &amp;&amp; end &gt;= <span class="hljs-number">0</span>)&#123;<br>            mid = begin + (end - begin)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)mid * mid &lt;= x)&#123;<br>                res = mid;<br>                begin = mid + <span class="hljs-number">1</span>; <br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                end = mid-<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">本题是一道水题 还是边界条件的控制问题，这里也顺便复习了一下大整数的处理方法 可用强转为long来比较<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ73</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">狒狒喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。<br><br>狒狒可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。  <br><br>狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。<br><br>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。<br> <br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：piles = [3,6,7,11], h = 8<br>输出：4<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> piles.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; len; i++)&#123;<br>            high = Math.max(high, piles[i]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (low+high)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(getTime(piles, middle) &gt; h)&#123;<br>                low = middle+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                high = middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> pile : piles)&#123;<br>            sum += pile/k;<br>            <span class="hljs-keyword">if</span>(pile%k != <span class="hljs-number">0</span>)&#123;<br>                sum += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">我只能说 凡是你觉得只能暴力遍历的题 首先要想到的就是二分<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ74</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。<br> <br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-type">MyComparator</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComparator</span>();<br>        Arrays.sort(intervals,m);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> intervals.length; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len; i++)&#123;<br>            <span class="hljs-comment">//先确定左边界</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> intervals[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j &lt; len;j++)&#123;<br>                <span class="hljs-keyword">if</span>(right &lt; intervals[j][<span class="hljs-number">0</span>])&#123;<br>                    i = j-<span class="hljs-number">1</span>; <br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(right &lt;= intervals[j][<span class="hljs-number">1</span>])&#123;<br>                    right = intervals[j][<span class="hljs-number">1</span>];            <br>                &#125;<br>                <span class="hljs-keyword">if</span>(j == len-<span class="hljs-number">1</span>)&#123;<br>                    i = j + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left,right&#125;); <br>        &#125;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size();i++)&#123;<br>            res[i] = list.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] i1, <span class="hljs-type">int</span>[] i2)</span> &#123;<br>		<span class="hljs-keyword">return</span> i1[<span class="hljs-number">0</span>]-i2[<span class="hljs-number">0</span>];<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题我怎么感觉之前写过 <br>首先我们对给的数组重新排序 按照第一个数进行排序<br>然后感觉有点像单调栈的思路 维护左边界，去拓展右边界 <br>然后就是控制好边界条件就行。<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ76</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">给定两个数组，arr1 和 arr2，<br><br>arr2 中的元素各不相同<br>arr2 中的每个元素都出现在 arr1 中<br>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]<br>输出：[2,2,2,1,4,3,3,9,6,7,19]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] relativeSortArray(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr2.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            map.put(arr2[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(arr1).boxed().sorted((i1, i2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(i1) &amp;&amp; map.containsKey(i2)) &#123;<br>                <span class="hljs-keyword">return</span> map.get(i1) - map.get(i2);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.containsKey(i1)) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.containsKey(i2)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> i1 - i2;<br>            &#125;<br>        &#125;).mapToInt(Integer::valueOf).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">思路我都懂 就是这个自定义排序有点难写<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ76</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br><br>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]<br>输出：[2,2,2,1,4,3,3,9,6,7,19]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer m, Integer n)</span> &#123;<br>                <span class="hljs-keyword">return</span> m -n ;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(queue.size() == k)&#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; queue.peek()) &#123;<br>                    queue.poll();<br>                    queue.offer(nums[i]);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                queue.offer(nums[i]);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题求出前k大就是之前的优先级队列实现大小根堆的方法 <br>前k大就是小根堆<br>前k小就是大根堆<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ77</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。<br><br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：head = [4,2,1,3]<br>输出：[1,2,3,4]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            list.add(head.val);<br>            head = head.next;<br>        &#125;<br>        list.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer m,Integer n)</span>&#123;<br>                <span class="hljs-keyword">return</span> m-n;<br>            &#125;<br>        &#125;);<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span>list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> newHead;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt; list.size();i++)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(list.get(i));<br>            pre.next = newNode;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">确实是一道水题 直接将链表的值存入list里面排序就行<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ78</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个链表数组，每个链表都已经按升序排列。<br><br>请将所有链表合并到一个升序链表中，返回合并后的链表。<br><br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        List&lt;Integer&gt; myList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(ListNode list: lists)&#123;<br>            <span class="hljs-keyword">while</span>(list!=<span class="hljs-literal">null</span>)&#123;<br>                System.out.println(list.val);<br>                myList.add(list.val);<br>                list = list.next;<br>            &#125;<br>        &#125;<br>        myList.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer m,Integer n)</span>&#123;<br>                <span class="hljs-keyword">return</span> m-n;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">if</span>(myList.size() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(myList.get(<span class="hljs-number">0</span>));<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;myList.size();i++)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(myList.get(i));<br>            pre.next = node;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">还是一道水题 直接将链表的值存入list里面排序就行<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ79</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<br><br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        res.add(list);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> res.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span> ;j &lt; num;j++)&#123;<br>                List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                newList.addAll(res.get(j));<br>                newList.add(nums[i]);<br>                res.add(newList);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题用到了数学上的知识 不难 复习了一下拷贝ArrayList的方法：<br>新的list.addAll(旧的list);<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ80</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        dfs(<span class="hljs-number">1</span>, n, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp </span><br>        <span class="hljs-keyword">if</span> (temp.size() + (n - cur + <span class="hljs-number">1</span>) &lt; k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 记录合法的答案</span><br>        <span class="hljs-keyword">if</span> (temp.size() == k) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(temp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 考虑选择当前位置</span><br>        temp.add(cur);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>        temp.remove(temp.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 考虑不选择当前位置</span><br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题可以作为枚举的一个模板来看 其实这种枚举就是一个dfs遍历的过程 只要符合长度就遍历结束，也就是剪枝，dfs有两条路径，一个是选择当前位置一个是不选择当前位置 那么就需要进行回溯。然后我们可以进行推广 凡是这种遍历每个节点有两种或者更多选择的题 我们都可以考虑使用dfs来写<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ81</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。<br><br>candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。 <br><br>对于给定的输入，保证和为 target 的唯一组合数少于 150 个。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: candidates = [2,3,6,7], target = 7<br>输出: [[7],[2,2,3]]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] candidates;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> target;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">boolean</span> flag;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.candidates = candidates;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        sum = <span class="hljs-number">0</span>;<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; target || n &gt;= candidates.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum == target &amp;&amp;  flag)&#123;<br>            <br>            System.out.println(n);<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        &#125;<br>        <span class="hljs-comment">//选择当前位置</span><br>        flag = <span class="hljs-literal">true</span>;<br>        sum += candidates[n];<br>        list.add(candidates[n]);<br>        dfs(n);<br>        <span class="hljs-comment">//不选择当前位置</span><br>        flag = <span class="hljs-literal">false</span>;<br>        sum -= candidates[n];<br>        list.remove(list.size()-<span class="hljs-number">1</span>);<br>        dfs(n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题还是dfs + 回溯 + 减枝的题 <br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ82</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个可能有重复数字的整数数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br><br>candidates 中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。 <br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>输出:<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> candidates.length;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// 关键步骤</span><br>        Arrays.sort(candidates);<br><br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(len);<br>        dfs(candidates, len, <span class="hljs-number">0</span>, target, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidates 候选数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> len        冗余变量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> begin      从候选数组的 begin 位置开始搜索</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target     表示剩余，这个值一开始等于 target，基于题目中说明的&quot;所有数字（包括目标数）都是正整数&quot;这个条件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path       从根结点到叶子结点的路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> res</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin; i &lt; len; i++) &#123;<br>            <span class="hljs-comment">// 大剪枝：减去 candidates[i] 小于 0，减去后面的 candidates[i + 1]、candidates[i + 2] 肯定也小于 0，因此用 break</span><br>            <span class="hljs-keyword">if</span> (target - candidates[i] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 小剪枝：同一层相同数值的结点，从第 2 个开始，候选数更少，结果一定发生重复，因此跳过，用 continue</span><br>            <span class="hljs-keyword">if</span> (i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.addLast(candidates[i]);<br>            <span class="hljs-comment">// 调试语句 ①</span><br>            <span class="hljs-comment">// System.out.println(&quot;递归之前 =&gt; &quot; + path + &quot;，剩余 = &quot; + (target - candidates[i]));</span><br><br>            <span class="hljs-comment">// 因为元素不可以重复使用，这里递归传递下去的是 i + 1 而不是 i</span><br>            dfs(candidates, len, i + <span class="hljs-number">1</span>, target - candidates[i], path, res);<br><br>            path.removeLast();<br>            <span class="hljs-comment">// 调试语句 ②</span><br>            <span class="hljs-comment">// System.out.println(&quot;递归之后 =&gt; &quot; + path + &quot;，剩余 = &quot; + (target - candidates[i]));</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] candidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        List&lt;List&lt;Integer&gt;&gt; res = solution.combinationSum2(candidates, target);<br>        System.out.println(<span class="hljs-string">&quot;输出 =&gt; &quot;</span> + res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这个确实太强了 暂时没完全搞懂 挖个坑 后面再填<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ83</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。 <br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; rest = Arrays.stream(nums).boxed().collect(Collectors.toList());<br>        dfs(list,rest);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; list,List&lt;Integer&gt; rest)</span>&#123;<br>        <span class="hljs-keyword">if</span>(rest.isEmpty())&#123;<br>            ans.add(list);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> rest.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> rest.get(i);<br>            List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list);<br>            newList.add(num);<br>            rest.remove(i);<br>            dfs(newList,rest);<br>            rest.add(i,num);<br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">和之前几道题一样，是典型的递归问题,这道题我们可以学到以下几点<br>1.首先是Arrays.stream(nums).boxed().collect(Collectors.toList());这个是int[]转ArrayList的方法 <br>2.对于递归我们可以先在脑海里想好递归树，是如何递归下去 其实这种递归也就是dfs 但是需要回溯<br>  本题的递归就是dfs带参下潜的过程 注意：List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(list);这里最好用一个新的list下潜<br>  最后的回溯过程就是左老师说的清理现场的过程，只需要将rest里面的数据复原即可<br></code></pre></td></tr></table></figure>

<p>剑指offerⅡ84</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个可包含重复数字的整数集合 nums ，按任意顺序 返回它所有不重复的全排列。 <br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>         List&lt;Integer&gt; rest = Arrays.stream(nums).boxed().collect(Collectors.toList());<br>        dfs(path,rest);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; path,List&lt;Integer&gt; rest)</span>&#123;<br>        <span class="hljs-keyword">if</span>(rest.isEmpty())&#123;<br>            ans.add(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> rest.size();<br>        <span class="hljs-type">boolean</span>[] flags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">25</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> rest.get(i);<br>            <span class="hljs-keyword">if</span>(!flags[num+<span class="hljs-number">10</span>])&#123;<br>                List&lt;Integer&gt; newPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path);<br>                newPath.add(num);<br>                rest.remove(i);<br>                dfs(newPath,rest);<br>                flags[num+<span class="hljs-number">10</span>] = <span class="hljs-literal">true</span>;<br>                rest.add(i,num);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">和上一道题一样，是典型的递归问题<br>所不同之处在于本题需要对多叉树每一节点的值进行去重 也就是说如果当前层每个数字我只能选一次，也就是说如果不同枝是相同数字，那么我们需要剪纸，否则会出现重复的情况<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ85</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">正整数 n 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 <br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：n = 3<br>输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">restl</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">restr</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        path = path +  <span class="hljs-string">&#x27;(&#x27;</span>;<br>        --restl;<br>        dfs(restl,restr,path,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> restl,<span class="hljs-type">int</span> restr,String path,<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-keyword">if</span>(restr == <span class="hljs-number">0</span> &amp;&amp;  restl == <span class="hljs-number">0</span>)&#123;<br>            ans.add(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//匹配完但没完全匹配完 剪枝头</span><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newString</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;(&#x27;</span>;<br>            dfs(restl-<span class="hljs-number">1</span>,restr,newString,<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(restl &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">newString</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;(&#x27;</span>;<br>                dfs(restl-<span class="hljs-number">1</span>,restr,newString,num+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newString</span> <span class="hljs-operator">=</span> path + <span class="hljs-string">&#x27;)&#x27;</span>;<br>            dfs(restl,restr-<span class="hljs-number">1</span>,newString,num-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">和上一道题一样，是典型的递归问题<br>所不同之处在于本题需要对多叉树每一节点的值进行去重 也就是说如果当前层每个数字我只能选一次，也就是说如果不同枝是相同数字，那么我们需要剪纸，否则会出现重复的情况<br></code></pre></td></tr></table></figure>



<p>剑指offerⅡ86</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">给定一个字符串 s ，请将 s 分割成一些子串，使每个子串都是 回文串 ，返回 s 所有可能的分割方案。<br><br>回文串 是正着读和反着读都一样的字符串。<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：s = &quot;google&quot;<br>输出：[[&quot;g&quot;,&quot;o&quot;,&quot;o&quot;,&quot;g&quot;,&quot;l&quot;,&quot;e&quot;],[&quot;g&quot;,&quot;oo&quot;,&quot;g&quot;,&quot;l&quot;,&quot;e&quot;],[&quot;goog&quot;,&quot;l&quot;,&quot;e&quot;]]<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; solutions; <span class="hljs-comment">// 所有分割方案</span><br>    List&lt;String&gt; solution; <span class="hljs-comment">// 当前分割方案</span><br>    <span class="hljs-type">boolean</span>[][] dp;<br>    <span class="hljs-type">int</span> n;<br>    String s;<br>    <span class="hljs-keyword">public</span> String[][] partition(String s) &#123;<br>        <span class="hljs-built_in">this</span>.n = s.length();<br>        <span class="hljs-built_in">this</span>.s = s;<br>        <span class="hljs-built_in">this</span>.solutions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-built_in">this</span>.solution = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        getDPMatrix(); <span class="hljs-comment">// 计算dp数组</span><br>        backtrack(<span class="hljs-number">0</span>); <span class="hljs-comment">// 回溯求解</span><br>        String[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[solutions.size()][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.length; i++)&#123; <span class="hljs-comment">// 转换输出</span><br>            List&lt;String&gt; solution = solutions.get(i);<br>            res[i] = solution.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[solution.size()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDPMatrix</span><span class="hljs-params">()</span>&#123;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 边界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123; <span class="hljs-comment">// 边界</span><br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>            dp[i - <span class="hljs-number">1</span>][i] = s.charAt(i - <span class="hljs-number">1</span>) == s.charAt(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123; <span class="hljs-comment">// 自底向上对右上三角区域递推</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">2</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == n) &#123;<br>            solutions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(solution));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i][j])&#123;<br>                solution.add(s.substring(i, j + <span class="hljs-number">1</span>));<br>                backtrack(j + <span class="hljs-number">1</span>);<br>                solution.remove(solution.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">和上一道题一样，是典型的递归问题<br>所不同之处在于本题需要对多叉树每一节点的值进行去重 也就是说如果当前层每个数字我只能选一次，也就是说如果不同枝是相同数字，那么我们需要剪纸，否则会出现重复的情况<br></code></pre></td></tr></table></figure>











<p>剑指offerⅡ98</p>
<hr>
<p><strong>题目描述</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br><br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br><br>问总共有多少条不同的路径？<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：m = 3, n = 7<br>输出：28<br></code></pre></td></tr></table></figure>

<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            f[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这道题可以说是dp里面的经典题 f[i][j] = f[i - 1][j] + f[i][j - 1];就是转移方程 根据状态转移方程正向求解比反向递归速度快很多<br></code></pre></td></tr></table></figure>




















































                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0-%E7%AE%97%E6%B3%95-%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/" class="category-chain-item">/学习/算法/做题总结</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%88%B7%E9%A2%98/">#刷题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>剑指offerⅡ</div>
      <div>http://example.com/2022/08/25/剑指offerⅡ/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Tao Chen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月25日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/25/%E5%9B%B4%E6%A3%8B%E5%A4%8D%E7%9B%98/" title="2022-08-21围棋复盘">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2022-08-21围棋复盘</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
